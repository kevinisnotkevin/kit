# LOGGING

> Модуль предоставляет функции и классы, которые реализуют гибкую систему логирования для приложений и библиотек.

Регистраторы (Loggers) - интерфейс кода приложения. 

Обработчики (Handlers) - отправляют записи журнала, созданные регистраторами, в соответствующее место назначения. 

Фильтры (Filters) - более детальное определение, какие записи журнала следует выводить. 

Форматтеры (Formatters) - определяют расположение записей логирования в конечном выводе.

## Использование

- Отслеживание и исследование проблем в приложении.
- Фиксация важных событий в приложении (успешные операции, загрузка данных и т.д.).
- Ведение аудита приложения (записи событий, которые могут быть полезны для анализа безопасности и отслеживания действий пользователей).
- Динамическое изменение уровней логирования во время выполнения приложения.

## Примеры

```python
logging.warning('Watch out!') # WARNING:root:Watch out!


# Конфигурирование логгера
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Пример логирования
logging.debug('Это сообщение уровня DEBUG')
logging.info('Это информационное сообщение')
logging.warning('Это предупреждение')
logging.error('Это сообщение об ошибке')
logging.critical('Это критическая ошибка')
```

## Использование модуля logging

Чтобы включить вывод журнальных сообщений в процессе выполнения программы, скопируйте приведенный ниже код в начало программы

```python
import logging
logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s')
```

Детали того, как все это работает, для вас несущественны, но вам будет полезно знать, что каждый раз, когда Python протоколирует событие, он создает объект `LogRecord`, в котором хранится информация о данном событии. Функция `basicConfig()` модуля `logging` позволяет конкретизировать, какую именно информацию об объекте `LogRecord` вы хотите видеть и в каком формате.

Предположим, вы написали программу, в которой реализовали функцию для вычисления факториала числа. Однако в программе была допущена ошибка и для ее обнаружения были предусмотренны журнальные сообщения.

```python
import logging
logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s')
logging.debug('Начало программы')

def factorial(n):
    logging.debug(f'Начало factorial({n})')
    total = 1
    for i in range(n + 1) :
        total *= i
        logging.debug('i = ' + str(i) + ', total = ' + str (total))
    logging.debug(f'Конец factorial({n})')
    return total

print(factorial(5))

logging.debug('Конец программы')
```
- Функция `factorial()` возвращает значение 0 в качестве факториала числа 5, что неверно. В цикле `for` значение переменной `total` должно умножаться на числа от 1 до 5. Однако сообщения, отображаемые функцией `logging.debug()`, показывают, что начальное значение переменной `i` — 0, а не 1. Поскольку результатом умножения любого числа на 0 всегда будет 0, в последующих итерациях значение переменной `total` уже не меняется.

## Не выполняйте отладку с помощью print

Для кого-то импорт модуля `logging` и громоздкий вызов функции `logging.basicConfig` может показаться не самой удачной стратегией. Почему бы не использовать вместо этого функцию `print()`? Не стоит поддаваться такому искушению! Завершив отладку, вы потратите массу времени на удаление из кода вызовов `print()` для каждого сообщения. Более того, не исключено, что вы случайно удалите полезные вызовы `print()`, никак не связанные с журнальными сообщениями. Механизм протоколирования удобен тем, что в программе можно предусмотреть столько сообщений, сколько вам нужно, и впоследствии вы сможете в любой момент отключить их, добавив единственный вызов `logging.disable(logging.CRITICAL)`. В отличие от функции `print()`, модуль `logging` упрощает переключение между режимами отображения и сокрытия сообщений.

Журнальные сообщения предназначены для программистов, а не для пользователей. Пользователя не интересует содержимое словаря, за которым вы хотите наблюдать в процессе отладки. Сообщения, адресованные пользователю, такие как “_Файл не найден_” или “_Введите число_”, следует выводить с помощью функции `print()`. Пользователя нельзя лишать этой информации после отключения журнальных сообщений.

## Уровень критичности сообщений

Уровни протоколирования позволяют классифицировать журнальные сообщения по степени важности. Всего существует пять уровней протоколирования, перечисленных в таблице ниже в порядке возрастания важности. Сообщения каждого уровня выводятся с использованием разных функций.

|**Уровень**|**Функция протоколирования**|**Описание**|
|---|---|---|
|DEBUG|`logging.debug()`|Самый низкий уровень. Предназначен для вывода|
|малозначимой информации. Такие сообщения представляют интерес только при диагностике проблем|||
|INFO|`logging.info()`|Предназначен для записи информации об обычных событиях, происходящих в программе, или для подтверждения нормального хода работы программы|
|WARNING|`logging.warning()`|Предназначен для индикации потенциально опасных|
|ситуаций, которые не препятствуют работе программы, но|||
|могут привести к этому в будущем|||
|ERROR|`logging.error()`|Предназначен для записи информации об ошибке, которая|
|помешала программе выполнить требуемые действия|||
|CRITICAL|`logging.critical()`|Наивысший уровень. Предназначен для индикации|
|фатальных ошибок, которые привели или могут привести|||
|к аварийному завершению программы|||

Сообщения следует передавать функциям в строковом виде. Сами по себе уровни протоколирования — это не более чем рекомендации. В конечном счете только вы решаете, к какой категории следует отнести то или иное сообщение.

```python
import logging
logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s')

logging.debug('Отладочная информация.')
logging.info('Работает модуль logging.')
logging.warning('Риск получения сообщения об ошибке.')
logging.error('Произошла ошибка.')
logging.critical('Программа не может выполняться.')
```

Преимущество уровней протоколирования в том, что у вас есть возможность задать граничный приоритет сообщений, подлежащих отслеживанию. Если передать функции `basicConfig()` значение `logging.DEBUG` в качестве аргумента `level`, то будут отображаться сообщения всех уровней (поскольку `DEBUG` — самый низкий уровень). На последующих этапах разработки программы вас уже будет интересовать только информация об ошибках. В таком случае вы сможете передать функции `basicConfig()` аргумент `logging`. `ERROR`. В результате будут отображаться лишь сообщения категорий `ERROR` и `CRITICAL`, а сообщения категорий `DEBUG`, `INFO` и `WARNING` будут игнорироваться.

## Отключение логгирования

После завершения отладки программы вам уже будут не нужны журнальные сообщения, захламляющие экран. Функция `logging.disable()` позволяет отключить их, не внося изменения в программный код. Вы просто сообщаете ей требуемый уровень протоколирования, и она подавляет вывод сообщений, относящихся к этому и более низким уровням. Таким образом, чтобы полностью отключить режим протоколирования, достаточно добавить в программу вызов `logging.disable(logging.CRITICAL)`.

```python
import logging
logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s')
logging.disable(logging.CRITICAL)

logging.debug('Отладочная информация.')
logging.info('Работает модуль logging.')
logging.warning('Риск получения сообщения об ошибке.')
logging.error('Произошла ошибка.')
logging.critical('Программа не может выполняться.')
```

В результатате выполнения программы ничего выведено не будет.

Поскольку функция `logging.disable()` отключает все последующие инструкции протоколирования, ее нужно вставить после строки `import logging`. Благодаря этому вы сможете быстро находить ее, чтобы при необходимости закомментировать или раскомментировать включения или отключения режима протоколирования.

## Запись логов в файл журнала

Вместо того чтобы отображать журнальные сообщения на экране, их можно записывать в текстовый файл. Для этого следует воспользоваться функцией `logging.basicConfig()`, которая поддерживает именованный аргумент `filename`.

```python
import logging
logging.basicConfig(filename='myProgramLog.txt', level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s', encoding="utf-8")

logging.debug('Отладочная информация.')
logging.info('Работает модуль logging.')
logging.warning('Риск получения сообщения об ошибке.')
logging.error('Произошла ошибка.')
logging.critical('Программа не может выполняться.')
```

В данном случае сообщения сохраняются в файле `myProgramLog.txt`, который будет создан автоматически, также необходимо указать кодировку `utf-8`, для корректного отображения русского языка.
