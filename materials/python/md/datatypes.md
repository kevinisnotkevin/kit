# Типы данных
1. [datetime - Основные типы даты и времени](#1)
2. [zoneinfo - Поддержка часовых поясов IANA](#2)
3. [calendar - Общие функции, связанные с календарем](#3)
4. [collections - Типы данных контейнера](#4)
5. [collections.abc - Абстрактные базовые классы для контейнеров](#5)
6. [heapq - Алгоритм очереди в куче](#6)
7. [bisect - Алгоритм деления массива пополам](#7)
8. [array - Эффективные массивы числовых значений](#8)
9. [weakref - Слабые ссылки](#9)
10. [types - Динамическое создание типов и имена для встроенных типов](#10)
11. [copy - Операции поверхностного и глубокого копирования](#11)
12. [pprint - Симпатичный принтер данных](#12)
13. [reprlib - Альтернативная реализация repr()](#13)
14. [enum - Поддержка перечислений](#14)
15. [graphlib - Функционал для работы с графоподобными структурами](#15)





## <div id="2">2. zoneinfo - Поддержка часовых поясов IANA</div>
> Модуль предоставляет улучшенный способ работы с временными зонами по сравнению с устаревшими модулями (datetime, pytz). Модуль позволяет переводить даты и время из одной временной зоны в другую.

## <div id="3">3. calendar - Общие функции, связанные с календарем</div>
> Модуль предоставляет функции для работы с календарем.


## <div id="4">4. collections - Типы данных контейнера</div>
> Модуль реализует специализированные типы данных контейнеров, предоставляя альтернативу встроенным контейнерам (dict, list, set, tuple).
### Использование
- Создание частотных словарей для подсчета количества элементов в итерируемом обьекте.
- Создание словарей со значениями по умолчанию.
- Создание словарей с сохранением порядка вставки элементов.
- Создание именнованных кортежей с явными именами полей.
- Создание двустронней очереди, которая более эффективна при удалении и добавлении элементов с начала или конца.
- Реализация очередей, поиск по дереву в ширину.
### Пример
Модуль предоставляет `deque`, похожий на список, с более быстрым добавлением и извлечением с левой стороны, но более медленным поиском в середине. Подходит для реализации очередей и поиска по дереву в ширину:
```python
d = deque(["task1", "task2", "task3"])
d.append("task4")
d.popleft()
```

## <div id="5">5. collections.abc - Абстрактные базовые классы для контейнеров</div>
> Модуль предоставляет абстрактные базовые классы для коллекций. Эти классы определяют общий интерфейс для различных типов данных (списки, множества, словари и т.д.). 


## <div id="6">6. heapq - Алгоритм очереди в куче</div>
> Модуль предоставляет реализацию двоичной кучи. Кучи — это двоичные деревья, в которых каждый родительский узел имеет значение, меньшее или равное любому из его дочерних узлов. В этой реализации используются массивы, для которых `heap[k] <= heap[2*k+1]` и `heap[k] <= heap[2*k+2]` для всех k, считая элементы с нуля. Для сравнения несуществующие элементы считаются бесконечными. Интересное свойство кучи состоит в том, что ее наименьший элемент всегда является корнем, `heap[0]`.
### Использование
- Очередь с приоритетами.
- Сортировка по частям.
- Алгоритмы поиска.
- Планирование задач.
### Пример
Модуль с функциями для реализации кучи на основе обычных списков. Запись с наименьшим значением всегда сохраняется в начале. Это полезно, когда неоднократно обращаются к наименьшему элементу, но не хотят выполнять полную сортировку списка:
```python
data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
heapify(data)
heappush(data, -5)
[heappop(data) for i in range(3)] 
```


## <div id="7">7. bisect - Алгоритм деления массива пополам</div>
> Модуль предоставляет поддержку хранения списка в отсортированном порядке без необходимости сортировки списка после каждой вставки. Использует базовый алгоритм деления пополам для поиска точки вставки. Вместо метода `__eq__()` использует метод `__lt__()`.
### Использование
- Поиск места вставки элемента в отсортированный список или массив.
- Эффективно для поиска диапазонов значений. Для поиска конкретных значений словари более эффективны.
- Функции поиска не сохраняют соостояние и отбрасывают результаты ключевых функций после их использования.
- Для длинных списков с дорогостоящими операциями сравнения это более эффективно, по сравнению с линейным поисков или частым обращением.
### Примеры
1\. Функция `bisect` может быть полезна для поиска в числовых таблицах. В этом примере используется поиск буквенной оценки за экзамен на основе набора упорядоченных числовых контрольных точек: от 90 и выше — «А», от 80 до 89 — «В» и так далее:
```python
def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
    i = bisect(breakpoints, score)
    return grades[i]

[grade(score) for score in [33, 99, 77, 70, 89, 90, 100]] # ['F', 'A', 'C', 'C', 'B', 'A', 'A']
```
2\. Этот код находит индекс, в который можно вставить число 4 в отсортированный массив, чтобы сохранить порядок сортировки:
```python
arr = [1, 3, 3, 5, 7, 9]
bisect.bisect_left(arr, 4)  # 3
```


## <div id="8">8. array - Эффективные массивы числовых значений</div>
> Модуль определяет тип объекта, который может компактно представлять массив основных значений: символов, целых чисел, чисел с плавающей запятой. Массивы представляют собой типы последовательностей и ведут себя очень похоже на списки, за исключением того, что тип хранящихся в них объектов ограничен. Тип указывается во время создания объекта с помощью кода типа, который представляет собой один символ.
### Использование
- Использование меньшего количества памяти, чем обычные списки.
- Более эффективный доступ к памяти, чем в обычных списках.
- Добавление, удаление элементов более эффективно, чем в обычных списках.
- Эффективен при манипулировании большими обьемами данных.
### Примеры
```python
a = array('H', [4000, 10, 700, 22222])
```


## <div id="9">9. weakref - Слабые ссылки</div>
> Модуль позволяет создавать слабые ссылки на обьекты.
### Использование
- Реализация кэшей и отображений, содержащих большие обьекты, где желательно, чтобы большой обьект не оставался активным только потому, что он появляется в кэше или сопоставлении.
### Примеры
Например, если у вас есть несколько больших объектов двоичного изображения, вы можете захотеть связать имя с каждым. Если вы использовали словарь Python для сопоставления имен с изображениями или изображений с именами, объекты изображений оставались бы живыми только потому, что они появлялись в словарях как значения или ключи. Классы `WeakKeyDictionary` и `WeakValueDictionary`, предоставляемые модулем `weakref`, являются альтернативой, использующей слабые ссылки для создания отображений, которые не поддерживают активность объектов только потому, что они появляются в объектах сопоставления. Если, например, объект изображения является значением в a `WeakValueDictionary`, то, когда последние оставшиеся ссылки на этот объект изображения являются слабыми ссылками, содержащимися в слабых сопоставлениях, сборщик мусора может вернуть объект, а соответствующие записи в слабых сопоставлениях просто удаляются.


## <div id="10">10. types - Динамическое создание типов и имена для встроенных типов</div>
> Модуль определяет служебные функции, помогающие в динамическом создании новых типов. Предоставляет некоторые дополнительные служебные классы и функции, связанные с типами, которые недостаточно фундаментальны, чтобы быть встроенными.
### Использование
- Создание новых типов или функций.
- Использование типов для проверки типов обьектов.


## <div id="11">11. copy - Операции поверхностного и глубокого копирования</div>
> Модуль обеспечивает общие операции поверхностного и глубокого копирования, так как операторы Python не копируют обьекты, а создают привязки между целью и обьектом.
### Использование
- Создание поверхностных копий обьектов.
- Создание глубоких копий обьектов.
- Для коллекций, которые являются изменяемыми или содержат изменяемые элементы, иногда требуется копия, чтобы можно было изменить одну копию, не изменяя другую.
### Примеры
```python
original_list = [1, 2, [3, 4]]
copied_list = copy.copy(original_list)
original_list[2][0] = 999
print(original_list)  # [1, 2, [999, 4]]
print(copied_list)    # [1, 2, [999, 4]]
```
```python
original_list = [1, 2, [3, 4]]
deep_copied_list = copy.deepcopy(original_list)
original_list[2][0] = 999
print(original_list)      # [1, 2, [999, 4]]
print(deep_copied_list)   # [1, 2, [3, 4]]
```


## <div id="12">12. pprint - Симпатичный принтер данных</div>
> Модуль предоставляет "красивый" вывода структур данных, таких как словари и списки. Он предоставляет функциональность для форматирования и вывода этих данных в более читаемом виде, что особенно полезно при отладке или выводе информации для пользователя.


## <div id="13">13. reprlib - Альтернативная реализация repr()</div>
> Модуль предоставляет средства для создания представлений обьектов с ограничениями на размер результирующих строк. Предоставляет версию repr() для сокращенного отображения больших или глубоко вложенных контейнеров
### Использование
- Используется в отладчике.
- Создание краткого представления обьектав отладочных сообщениях, логах.
### Примеры
```python
reprlib.repr(set('supercalifragilisticexpialidocious'))
```

## <div id="14">14. enum - Поддержка перечислений</div>
> Модуль используется для создания перечислений, что упрощает работу с набором именованных констант. Перечисления предоставляют более понятные и читаемые способы представления данных, которые имеют фиксированных набор значений.
### Использование
- Создание перечислений.
- Работа с опциями конфигурации, статусами, цветами.
### Примеры
```python
class Color(enum.Enum):
    RED = 1
    GREEN = 2
    BLUE = 3
```


## <div id="15">15. graphlib - Функционал для работы с графоподобными структурами</div>
> Модуль предоставляет функции для работы с графами. Включает инструменты для создания и манипуляций направленными и ненаправленными графами.
### Использование
- Топологическая сортировка для направленных ациклических графов. Полезно при работе с зависимостями между задачами.
- Преобразования направленного ациклического графа в древовидную структуру.
- Определение наличия циклов в графе.
### Примеры
```python
graph = {'a': {'b', 'c'}, 'b': {'d'}, 'c': {'d'}, 'd': {}}

ts = graphlib.TopologicalSorter(graph)
sorted_nodes = list(ts.static_order())

print("Topologically sorted nodes:", sorted_nodes)
```
