# RE

- [Что такое регулярные выражения?](materials/unknown/regex.md)


re - модуль, который предоставляет инструменты регулярных выражений для расширенной обработки строк. Предлагает краткие и оптимизированные решения для сложных сопоставлений и манипуляций.

## Символы регулярных выражений

Symbol | Matches
--- | ---
`?` | 0 или 1 повторение предыдущего шаблона.
`*` | 0 или более повторений предыдущего шаблона.
`+` | 1 и более повторений предыдущего шаблона.
`{n}` | n повторений предыдущего шаблона.
`{n,}` | От n и более повторений предыдущего шаблона.
`{,m}` | От 0 до n повторений предыдущего шаблона.
`{n,m}` | Не менее n и не более m.
`{n,m}?` | Нежадное сопоставление предыдущего шаблона.
`*?` | Нежадное сопоставление предыдущего шаблона.
`+?` | Нежадное сопоставление предыдущего шаблона.
`^spam` | Строка должна начинаться spam.
`spam$` | Строка должна заканчиваться spam.
`.` | Любой символ, кроме символов новой строки.
`\d` | Цифра.
`\w` | Слово.
`\s` | Пробел.
`\D` | Что угодно, кроме цифры.
`\W` | Что угодно, кроме слова.
`\S` | Что угодно, кроме пробела.
`[abc]` | Любой символ в скобках.
`[^abc]` | Любой символ, не заключенный в скобки.

## Методы

- **`compile`**: Компилирует шаблон регулярного выражения в обьект регулярного выражения, который можно использовать с помощью `match`, `search`.
- **`search`**: Сканирует строку в поисках первого совпадения шаблона.
- **`match`**: Соответствие символов в начале строки шаблону.
- **`fullmatch`**: Соответствие строки шаблону.
- **`split`**: Разделяет строку по шаблону указанное количество раз и возвращает список.
- **`findall`**: Возвращает все совпадения шаблона в строке в виде списка строк или кортежей.
- **`finditer`**: Возвращает итератор, возвращающий `Match` обьекты по всем совпадениям шаблона в строке.
- **`sub`**: Возвращает строку, полученную путем замены крайних левых вхождений шаблона в строке.
- **`subn`**: Выполняет то же, что и `sub`, но возвращает кортеж.
- **`escape`**: Экранирует специальные символы в шаблоне.
- **`purge`**: Очищает кеш регулярных выражений.

## Практика

```python
# Поиск всех совпадений
phone_num_regex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d') # has no groups
phone_num_regex.findall('Cell: 415-555-9999 Work: 212-555-0000')  # ['415-555-9999', '212-555-0000']

# Сопоставление без учета регистра:
robocop = re.compile(r'robocop', re.I)
robocop.search('Robocop is part man, part machine, all cop.').group()  # 'Robocop'
robocop.search('ROBOCOP protects the innocent.').group()  # 'ROBOCOP'
robocop.search('Al, why does your programming book talk about robocop so much?').group()  # 'robocop'


# Замена строк:
names_regex = re.compile(r'Agent \w+')
names_regex.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.')  # 'CENSORED gave the secret documents to CENSORED.'


# Распределение регулярного выражения на несколько строк с помощью VERBOSE:
phone_regex = re.compile(r'((\d{3}|\(\d{3}\))?(\s|-|\.)?\d{3}(\s|-|\.)\d{4}(\s*(ext|x|ext.)\s*\d{2,5})?)')
# Становится:
phone_regex = re.compile(r'''(
    (\d{3}|\(\d{3}\))?            # area code
    (\s|-|\.)?                    # separator
    \d{3}                         # first 3 digits
    (\s|-|\.)                     # separator
    \d{4}                         # last 4 digits
    (\s*(ext|x|ext.)\s*\d{2,5})?  # extension
    )''', re.VERBOSE)
```

## 1 Поиск номера телефона

В Python все функции, предназначенные для работы с регулярными выражениями, содержатся в модуле re.

Поскольку символы обратной косой черты часто используются в регулярных выражениях, удобно передавать методу `re.compile()` "сырые" строки, а не вводить дополнительные символы обратной косой черты. 

```python
import re


def findPhoneNumber(phoneNumber):
    phoneNumberRegex = re.compile(r'\\d{1}-\\d{3}-\\d{3}-\\d{2}-\\d{2}')
    mo = phoneNumberRegex.search(phoneNumber)
    if mo:
        print('Найденный телефонный номер: ' + mo.group())
    else:
        print("В строке '" + phoneNumber + "' не содержится номер телефона")
    
findPhoneNumber("Мой номер телефона: 8-987-653-21-00")
findPhoneNumber("Мой адрес: 3-ая улица Строителей, дом 25")
```
- В этом примере мы используем функцию, которая принимает строку. Функция генерирует обьект regex с помощью метода `re.compile()` по заданному шаблону и сохраняет в переменную phoneNumberRegex. Далее функция ищет в переданной строке совпадение по обьекту regex с помощью метода `search()`. Метод `search()` объекта Regex ищет в переданной ему строке любые совпадения с регулярным выражением. В случае отсутствия в строке совпадений с регулярным выражением он возвращает значение `None`. Если совпадения были обнаружены, то метод возвращает объект `Match`. Объекты `Match` имеют метод `group()`, который возвращает найденные соответствия шаблону. Если находит, то выводит сообщение о том, что номер найден и сам номер, иначе выводит сообщение о том, что в строке номера нет.

## 2 Другие возможные шаблоны регулярных выражений

### 2.1 Создание групп с помощью круглых скобок

```python
phoneNumRegex = re.compile(r'\\d{1} \\((\\d{3})\\) (\\d{3}-\\d{2}-\\d{2})')
mo = phoneNumRegex.search("Мой номер телефона: 8 (987) 653-21-00")
print(mo.group())
areaCode, mainNumber = mo.groups()
print(areaCode)
print(mainNumber)
```
- Используем круглые скобки для создания групп в регулярных выражениях. Первый набор круглых скобок в строке регулярного выражения будет группой 1. Второй набор будет группой 2. Передавая целые числа 1 или 2 методу `group()` объекта совпадения, можно избирательно захватывать различные части совпавшего текста. Если методу `group()` передается 0 или вообще ничего не передается, то он возвращает весь найденный текст, соответствующий шаблону. Метод `groups()` позволяет извлечь сразу все группы. Чтобы найти в тексте сами скобки нужно предшествовать символ обратной косой черты.

### 2.2 Выбор альтернативных групп

```python
batRegex = re.compile(r'Bat(man|mobile|copter|bat) ')
mo = batRegex.search('Batmobile потерял колесо')
print(mo.group()) # Batmobile
print(mo.group(1)) # mobile
```
- В этом примере реализован поиск совпадений с помощью канала (`|`). Канал позволяет находить соответствие одному из нескольких альтернативных выражений. Вызов `mo.group()` возвращает весь совпавший с шаблоном текст, тогда как вызов `mo.group(1)` возвращает лишь часть совпавшего текста, соответствующую первой группе в круглых скобках.

### 2.3 Указание необязательной группы символов

```python
batRegex = re.compile(r'Бэт(ву)?мен')
mo1 = batRegex.search('Мой герой - Бэтмен')
print(mo1.group()) # Бэтмен

mo2 = batRegex.search('Мой герой - Бэтвумен')
print(mo2.group()) # Бэтвумен
```
- В этом примере реализован поиск с помощью шаблона, который содержит необязательные символы. Регулярное выражение должно найти совпадение независимо от того, содержится ли в строке определенный фрагмент текста. Символ `?` означает, что предшествующая ему группа представляет собой необязательную часть поискового шаблона. Регулярному выражению будет соответствовать текст, в котором подстрока либо вообще не встречается, либо встречается один раз.

### 2.4 Указание соответствия группе символов, повторяющейся нуль или несколько раз

```python
batRegex = re.compile(r'Бэт(ву)*мен')
mo1 = batRegex.search('Мой герой - Бэтмен') 
print(mo1.group()) # Бэтмен

mo2 = batRegex.search('Моя героиня - Бэтвумен')
print(mo2.group()) # Бэтвумен

mo3 = batRegex.search('Моя героиня - Бэтвувувувувувувумен')
print(mo3.group()) # Бэтвувувувувувувумен
```
- В этом примере слово ’`Бэтмен`’ часть `(ву)*` регулярного выражения соответствует нулевому количеству (т.е. отсутствию) экземпляров группы ’`ву`’ в строке. В случае слова ’`Бэтвумен`’ часть `(ву)*` совпадает с одним экземпляром '`ву`’, а в случае слова ' `Бэтвувувувувувувумен`’ часть `(ву)*` совпадает с семью экземплярами ’`ву`’. Звездочка `*` означает “найти нулевое или большее количество экземпляров”, т.е. группа, предшествующая звездочке, может встречаться в тексте любое количество раз. Она может либо вообще отсутствовать, либо повторяться снова и снова.

### 2.5 Указание соответствия одному или нескольким повторениям группы

```python
batRegex = re.compile(r'Бэт(ву)+мен')
mo1 = batRegex.search('Мой герой - Бэтмен') 
print(mo1 == None) # True

mo2 = batRegex.search('Моя героиня - Бэтвумен')
print(mo2.group()) # Бэтвумен

mo3 = batRegex.search('Моя героиня - Бэтвувувувувувувумен')
print(mo3.group()) # Бэтвувувувувувувумен
```
- В этом примере используется символ `+`. Символ `+` означает совпадение с единичным или большим количеством экземпляров. Группа, предшествующая знаку `+`, должна появиться в строке хотя бы один раз.

### 1.2.6 Указание соответствия определенному количеству повторений группы

Если имеется группа, которая должна повторяться определенное количество раз, укажите за ней число повторений в фигурных скобках. Вместо одного числа можно указать диапазон, записав в фигурных скобках минимальное и максимальное число допустимых повторений. Например, регулярному выражению `(На){3,5}` будут соответствовать строки ’НаНаНа’, 'НаНаНаНа’ и ’НаНаНаНаНа’. Как первое, так и второе из чисел в фигурных скобках можно опустить, оставив минимальное или максимальное количество повторений неограниченным.

```python
(На){3}
(На)(На)(На)
```
- Фигурные скобки позволяют записывать регулярные выражения в более компактном виде. Следующие два регулярных выражения идентичны

```python
haRegex = re.compile(r'(Ha){3}')
mo1 = haRegex.search('HaHaHa')
print(mo1.group()) # HaHaHa

mo2 = haRegex.search('Ha')
print(mo2 == None) # True
```
- В этом примере регулярное выражение ожидает вхождение `HaHaHa`

## 3 Жадный и нежадный виды поиска

Регулярные выражения Python по умолчанию жадные в том смысле, что в неоднозначных ситуациях они будут пытаться соответствовать как можно более длинной строке. Нежадная версия выражения с фигурными скобками, которая пытается соответствовать самой короткой из возможных строк, помечается вопросительным знаком после закрывающей фигурной скобки.

```python
greedyHaRegex = re.compile(r'(Ha){3,5}')
mo1 = greedyHaRegex.search('HaHaHaHaHa')
print(mo1.group()) # HaHaHaHaHa

nongreedyHaRegex = re.compile(r'(Ha){3,5}?')
mo2 = nongreedyHaRegex.search('HaHaHaHaHa')
print(mo2.group()) # HaHaHa
```
- В этом примере используется ? для указания использования нежадного поиска.

## 4 Метод findall

```python
phoneNumRegex = re.compile(r'\\d{1} \\(\\d{3}\\) (\\d{3}-\\d{2}-\\d{2})')
mo = phoneNumRegex.search("Номер мобильного телефона: 8 (987) 653-21-00, \\
                            Номер рабочего телефона: 8 (000) 000-00-00")
print(mo.group()) # 8 (987) 653-21-00

mo = phoneNumRegex.findall("Номер мобильного телефона: 8 (987) 653-21-00, \\
                            Номер рабочего телефона: 8 (000) 000-00-00")
print(mo) # [('987', '653-21-00'), ('000', '000-00-00')]
```
- В этом примере используется метод findall, который возвращает список кортежей всех вхождений, в отличие от метода search, который возвращает обьект Match первого вхождения. Каждый элемент кортежа содержит совпавшие строки для каждой группы в регулярном выражении

## 5 Символьные классы

Из предыдущих примеров вам уже известно, что символ `\d` означает любую цифру. Другими словами, `\d` - это сокращенное обозначение регулярного выражения `(0|1|2|3|4|5|6|7|8|9)`. Аналогичные сокращения существуют для многих других символьных классов.

|Сокращение|Представляемые символы|
|---|---|
|\d|Любая цифра в диапазоне от 0 до 9|
|\D|Любой символ, не являющийся цифрой в диапазоне от 0 до 9|
|\w|Любая буква, цифра или символ подчеркивания|
|\W|Любой символ, не являющийся буквой, цифрой или символом подчеркивания|
|\s|Пробел, табуляция или символ новой строки|
|\S|Любой символ, не являющийся пробелом, табуляцией или символом новой строки|

```python
xmasRegex = re.compile(r'\\d+\\s\\w+')
mo = xmasRegex.findall('12 барабанщиков, 11 волынщиков, 10 лордов, \\
                    9 леди, 8 горничных, 7 лебедей, 6 гусей, 5 колец, 4 птицы, \\
                    3 курицы, 2 голубя, 1 куропатка')

print(mo)
# ['12 барабанщиков', '11 волынщиков', '10 лордов', 
# '9 леди', '8 горничных', '7 лебедей', '6 гусей', '5 колец', '4 птицы', 
# '3 курицы', '2 голубя', '1 куропатка']
```
- В этом примере используется регулярное выражение, которому соответствует текст, содержащий одну или несколько цифр, за которыми идет пробел, а за ним какое-то кол-во символов. В итоге возвращается список кортежей.

## 6 Создание собственных символьных классов

```python
vowelRegex = re.compile(r'[^aeiouAEIOU]')
mo = vowelRegex.findall('RoboCop eats baby food. BABY FOOD.')
print(mo) # ['R', 'b', 'C', 'p', ' ', 't', 's', ' ', 'b', 'b', 'y', ' ', 'f', 'd', '.', ' ', 'B', 'B', 'Y', ' ', 'F', 'D', '.']
```
- В этом примере используется регулярное выражение, являющееся собственным символьным классом, которому соответствуют все символы, не являющиеся гласными. Чтобы определить собственный символьный класс используются квадратные скобки. Внутри квадратных скобок обычные символы регулярных выражений как таковые не интерпретируются. Это означает, что перед символами ( и ) не следует ставить обратную косую черту. Например, классу `[0-5.]` будут соответствовать цифры от 0 до 5 и точка. Не следует записывать этот класс как `[0-5\\.]`. В классы можно также включать диапазоны букв и цифр, используя дефис. Например, классу `[a-zA-ZO-9]` будут соответствовать все буквы в нижнем и верхнем регистрах, а также цифры. Символ `^` сразу за открывающей квадратной скобкой говорит о том, что это инвертированный символьный класс, т.е. такому классу будет соответствовать любой символ, не входящий в исходный класс.

## 7 Символ крышки и знак доллара

```python
wholestringlsNum = re.compile(r'^\d+$')
mo1 = wholestringlsNum.search('1234567890')
mo2 = wholestringlsNum.search('123456 7890')
print(mo1.group()) # 1234567890
print(mo2 == None) # True
```
- В этом примере используется регулярное выражение, которому соответствуют строки, которые состоят из цифр. Символ `^` означает, что строка должна начинаться данным шаблоном. Символ `$` означает, что строка должна заканчиваться данным шаблоном. Последние два вызова метода `search()` показывают, что при одновременном использовании символов `^` и `$` вся строка должна соответствовать регулярному выражению.

## 8 Символ подстановки

```python
atRegex = re.compile(r'.at')
mo = atRegex.findall('The cat in the hat sat on the flat mat.')
print(mo) # ['cat', 'hat', 'sat', 'lat', 'mat']
```
- В этом примере в регулярном выражении используется `.`, которой соответствует только один символ.

### 8.1 Указание соответствия любому тексту с помощью комбинации “точка-звездочка”

```python
nongreedyRegex = re.compile(r'<.*?>')
mo1 = nongreedyRegex.search('<Приготовить мужу> ужин.>')
print(mo1.group()) # <Приготовить мужу>
greedyRegex = re.compile(r'<.*>')
mo2 = greedyRegex.search('<Приготовить мужу> ужин.>')
print(mo2.group()) # <Приготовить мужу> ужин.>
```
- В этом примере используются регулярные выражения, которые ищут открывающую угловую скобку, за которой следует произвольный текст, завершающийся закрывающейся угловой скобкой. Первая версия является нежадной, а вторая жадной.

### 8.2 Указание соответствия символам новой строки с помощью точки

```python
noNewlineRegex = re.compile('.*')
mo1 = noNewlineRegex.search('Служить обществу.\\nЗащищать невиновных.\\nСоблюдать закон.')
print(mo1.group()) # Служить обществу.

newlineRegex = re.compile('.*', re.DOTALL)
mo2 =  newlineRegex.search('Служить обществу.\\nЗащищать невиновных.\\nСоблюдать закон.')
print(mo2.group()) 
#Служить обществу.
#Защищать невиновных.
#Соблюдать закон.
```
- В этом примере используется регулярное выражение, которому соответствуют все символы, включая символ новой строки. Это достигается путем указания дополнительного аргумента re.DOTALL (По умолчанию `.^` соответствует все, кроме символа новой строки).

## 9 Сводка символов регулярных выражений

| Элемент регулярных выражений | Описание                                                                                                |
| ---------------------------- | ------------------------------------------------------------------------------------------------------- |
| ?                            | Нулевое или единичное вхождение предшествующей группы.                                                  |
| *                            | Нулевое или произвольное количество вхождений предшествующей группы.                                    |
| +                            | Одно или несколько вхождений предшествующей группы.                                                     |
| {n}                          | Ровно n вхождений предшествующей группы.                                                                |
| {n,}                         | n или более вхождений предшествующей группы.                                                            |
| {,m}                         | Отсутствие или вплоть до m вхождений предшествующей группы.                                             |
| {n,m}                        | Не менее чем n и не более, чем m вхождений предшествующей группы.                                       |
| {n,m}?, или *?, или +?       | Нежадный поиск вхождений предшествующей группы.                                                         |
| ^spam                        | Строка должна начинаться символами ’spam’.                                                              |
| spam$                        | Строка должна заканчиваться символами ’spam’.                                                           |
| .                            | Любой символ, за исключением символа новой строки.                                                      |
| \d                           | Любая цифра в диапазоне от 0 до 9                                                                       |
| \D                           | Любой символ, не являющийся цифрой в диапазоне от 0 до 9                                                |
| \w                           | Любая буква, цифра или символ подчеркивания                                                             |
| \W                           | Любой символ, не являющийся буквой, цифрой или символом подчеркивания                                   |
| \s                           | Пробел, табуляция или символ новой строки                                                               |
| \S                           | Любой символ, не являющийся пробелом, табуляцией или символом новой строки                              |
| [abc]                        | Любой одиночный символ из числа тех, которые указаны в квадратных скобках (например, 'а’, 'b’ или ’с’). |
| [^abc]                       | Любой одиночный символ, кроме тех, которые указаны в квадратных скобках.                                |

## 10 Игнорирование регистра при поиске соответствий

```python
robocop = re.compile(r'робокоп', re.I)
rbcp1 = robocop.search('РобоКоп - это полицейский, частично человек, частично машина.').group()
print(rbcp1) # РобоКоп

rbcp2 = robocop.search('РОБОКОП защищает невиновных.').group()
print(rbcp2) # РОБОКОП

rbcp3 = robocop.search('Кто этот ваш робокоп?').group()
print(rbcp3) # робокоп
```
- В этом примере используется регулярное выражение, которое игнорирует регистр. Это достигается с помощью дополнительного аргумента re.IGNORECASE или re.I.

## 11 Замена строк с помощью метода sub

```python
agentNamesRegex = re.compile(r'агент (\w)\w*', re.I)
msg = agentNamesRegex.sub(r'\1****', 'Агент Алиса передала, что агент Ева знает: агент Боб - двойной агент.')
print(msg) # А**** передала, что Е**** знает: Б**** - двойной агент.
```
- В этом примере реализована замена строк с помощью метода sub. Найденный текст включается в строку замены. В примере скрываются имена секретных агентов, показывая лишь первые буквы.
## 12 Опережающие и ретроспективные проверки в регулярных выражениях

Опережающие и ретроспективные проверки - это возможность создать свои аналоги `$` и `^`: они задают условие, которое должно выполнятся или не выполнятся в начале или конце строки, и не являются частью найденного выражения.

- Look-behind - смотрит назад, соответственно ставится в начале регулярного выражения.
- Look-ahead - в конце, и смотрит вперед.

**Синтаксис**

- (?=pattern) положительное look-ahead условие
- (?!pattern) отрицательное look-ahead условие
- (?<=pattern) положительное look-behind условие
- (?<!pattern) отрицательное look-behind условие

### 12.1 Опережающие (lookahead) проверки

Используется, когда нужно, чтобы выходные данные возвращали утреждающую часть, присутствующую в строке поиска для сопоставления с шаблоном, за которым следует определенный раздел.

```python
example2 = re.search(r'orange([a-z])', 'orangehouse') 
print('Без использование опережающего условия:', example2.group())

example1 = re.search('orange(?=[a-z])', 'orangehouse') 
print('Positive Lookahead:', example1.group()) 

example2 = re.search('orange(?![a-z])', 'orange123') 
print('Negative Lookahead:', example2.group()) 
```
- В этом примере используется отрицательное опережающее утверждение, обычное опережающее утверждение и просто регулярное выражение. Все они проверяют, что после определенной строки должен идти определенный символ. Опережающее утверждение не является частью строки поиска. Опережающее утверждение `(?=[a-z])` указывает, что то, что следует за словом “orange”, должно быть буквенным символом нижнего регистра. В данном случае это символ “h”, совпадение найдено.

### 12.2 Ретроспективные (lookbehind) проверки

```python
tring = 'orange123'
example1 = re.search(r'(?<=[a-z])\\d', string) 
print(example1.group()) 

example2 = re.search(r'([a-z])\\d', string) 
print(example2.group())

example1 = re.search('(?<=[a-z])house',  'orangehouse') 
print(example1.group()) 

example2 = re.search('(?<![a-z])123',  'orange123')  
print(example2)
```
- Утверждение ретроспективного выражения регулярного выражения `(?<=orange)` указывает, что то, что предшествует любому словесному символу `\w`, должно быть строкой “orange”. В данном случае это символ “h”, перед которым стоит строка “orange”. Ретроспективное утверждение также не является частью строки поиска. Негативное ретроспективное выражение является противоположностью ретроспективного выражения. Это необходимо для того, чтобы строке поиска не предшествовало <lookbehind_regex>.
