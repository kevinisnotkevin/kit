# OS

> Модуль предоставляет функции, для взаимодействия с ОС, обработки и манипуляций путями к файлам и директориям. `os.path`  манипулирование путями.

## Использование

- Работа с переменными окружения.
- Выполнение команд в командной строке.
- Работа с файлами и директориями.
- Работа с путями файлов.

## Примеры

```python
# Получение списка файлов в текущей директории
files = os.listdir('.')
print(files)

# Создание новой директории
os.mkdir('new_directory')

# Выполнение команды в командной строке
os.system('ls')

# Получение значения переменной окружения
print(os.getenv('HOME'))
```


## Определение размеров файлов и содержимого папок

Модуль `os.path` содержит функции, позволяющие узнавать размеры файлов (в байтах) и определять, какие файлы и папки содержатся в заданной папке.

```python
print(os.path.getsize('/path/file'))
print(os.listdir('/path/dir'))

totalSize = 0
for file in os.listdir('/path/dir'):
    totalSize += os.path.getsize((os.path.join('/path/dir', file)))

print(totalSize)
print(round(totalSize / pow(2, 30), 2))
```
- Функция `os.path.getsize(путь)` возвращает размер заданного файла в байтах.
- Функция `os.listdir(путь)` возвращает список всех файлов в каталоге (путь). (Эта функция содержится в модуле `os`, а не `os.path`).
- В цикле последовательно перебираются все файлы, содержащиеся в папке `/dir/path`, и значение переменной `totalsize` каждый раз увеличивается на размер очередного файла. Функция `os.path.join()` используется для присоединения имени папки к текущему имени файла при вызове функции `os.path.getsize()`. Целочисленное значение, возвращаемое функцией `os.path.getsize()`, суммируется с текущим значением переменной `totalSize`. По завершении цикла выводится значение `totalsize`, содержащее суммарный объем содержимого папки.

## Проверка существования пути

Многие функции Python аварийно завершаются с выдачей сообщения об ошибке, если предоставленный им путь не существует. К счастью, у объектов `Path` есть методы для проверки того, существует ли заданный путь и соответствует ли он файлу или папке. Если переменная `р` содержит объект `Path`, то можно ожидать следующее:

- метод `р.exists()` возвращает `True`, если путь существует; в противном случае возвращается `False`;
- метод `р.is_file()` возвращает `True`, если путь существует и соответствует файлу; в противном случае возвращается `False`
- • метод `р.is_dir()` возвращает `True`, если путь существует и соответствует каталогу; в противном случае возвращается `False`.

```python
d = Path('/path/dir') 
unknown_dir = Path('/home/faith')
file = Path('/path/dir/file')
print(d.exists())
print(d.is_dir())
print(unknown_dir.exists())
print(file.is_file())
print(file.is_dir())
```

## Процесс чтения и записи файлов

```python
pth = Path('spam.txt')
rtn = pth.write_text('Привет, мир!')
print(rtn)
print(pth.read_text())
```
- Метод `read_text()` модуля pathlib возвращает строку с полным содержимым текстового файла. `Метод write_text()` создает новый текстовый файл (или перезаписывает существующий) на основе переданной ему строки содержимого.
- Здесь создается файл `spam.txt`, содержащий строку '`Привет, мир!`'. Значение `12`, возвращаемое методом `write_text()`, сообщает о том, что в файл было записано 12 символов (обычно эта информация игнорируется). Метод `read_text()` считывает содержимое нового файла и возвращает его в виде строки.

Методы объекта `Path` реализуют только базовые операции с файлами. Более распространенный способ записи в файл предполагает использование функции `open()` и файловых объектов. В Python операции чтения/записи файлов выполняются в три этапа:

1. Вызов функции `open()`, которая возвращает объект `File`;
2. Вызов метода `read()` или `write()` объекта `File`;
3. Закрытие файла путем вызова метода `close()` объекта `File`.


## Обход дерева каталогов

Предположим, вы хотите переименовать все файлы, находящиеся в определенной папке, а также во всех ее подпапках. Следовательно, вам необходимо выполнить обход всего дерева каталогов, обрабатывая при этом каждый файл. Написание соответствующей программы - задача нетривиальная; в Python для этого есть готовая функция из модуля `os.walk()` .

```python
import os
from pathlib import Path

pth = Path.cwd()

for folderName, subfolders, filenames in os.walk(pth):
    print('Текущая папка - ' + folderName)

    for subfolder in subfolders:
        print('ПОДПАПКА ПАПКИ - ' + folderName + ': ' + subfolder)

    for filename in filenames:
        print('Файл в подпапке - ' + folderName + ': '+ filename)

    print('')
```
- В функцию `os.walk()` передается единственное строковое значение: путь к папке. Ее можно использовать в цикле `for` для обхода дерева каталогов примерно так же, как и функцию `range()` для перебора всех целых чисел из заданного диапазона. Но, в отличие от функции `range()`, функция `os.walk()` на каждой итерации цикла возвращает три значения:
- строку, содержащую текущее имя папки;
- список строк, представляющих имена подпапок, которые содержатся в текущей папке;
- список строк, представляющих имена файлов, которые содержатся в текущей папке.

Под текущей папкой подразумевается папка, используемая на текущей итерации цикла. Применение функции `os.walk()` не приводит к смене текущего каталога программы.
