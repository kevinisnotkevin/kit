# Linux

## Contents

- [Linux](#linux)
    - [Contents](#contents)
    - [Introduction](#introduction)
    - [Components](#components)
    - [Architecture](#architecture)
    - [Terminal Hotkeys](#terminal-hotkeys)
    - [File descriptor and redirections](#file-descriptor-and-redirections)
    - [Permission Management](#permission-management)
        - [SUID & SGID](#suid--sgid)
        - [Sticky Bit](#sticky-bit)
    - [Service and Process Management](#service-and-process-management)
        - [Background processes](#background-processes)
        - [Executing multiple commands](#executing-multiple-commands)
    - [Task Scheduling](#task-scheduling)
        - [systemd](#systemd)
        - [CRON](#cron)
            - [Operators](#operators)
            - [Special lines](#special-lines)
            - [Usage](#usage)
    - [PTY](#pty)
    - [Bonding](#bonding)
    - [**UMASK**](#umask)
    - [CLI](#cli)

    - Labs
        - [Practice_1](#practice_1)
        - [Practice_2](#practice_2)
        - [Lab 1](materials/labs/linux_labs/lab_1.md)
        - [Lab 2](materials/labs/linux_labs/lab_2.md)
        - [Lab 3](materials/labs/linux_labs/lab_3.md)
        - [Lab 4](materials/labs/linux_labs/lab_4.md)
        - [Lab 5](materials/labs/linux_labs/lab_5.md)
        - [Lab 6](materials/labs/linux_labs/lab_6.md)
        - [Lab 7](materials/labs/linux_labs/lab_7.md)
        - [Lab 8](materials/labs/linux_labs/lab_8.md)

## Introduction

- Все есть файл
- Содержит множество небольших программ
- Возможность объединения программ для выполнения сложных задач
- Не привязан к GUI
- Данные конфигураций хранятся в текстовых файлах

## Components

- __Bootloader__: Загрузчик управляет процессом загрузки ОС (Например, GRUB);
- __OS Kernel__: Код ядра управляет ресурсами системных устройств ввода-вывода на аппаратном уровне;
- __Daemons__: Фоновые службы обеспечивают правильную работу функций (Например, печать, планирование, мультимедиа);
- __OS Shell__: Интерфейс между пользователем и ОС (Например, Bash, Tcsh/Csh, Ksh, Zsh, Fish);
- __Graphics server__: Обеспечивает графическую подсистему X-server, которая позволяет графическим программам запускаться локально или удаленно в системе X-windowing;
- __Window manager__: GUI позволяет пользователю получать доступ к основным функциям и службам ОС (Например, GNOME, KDE, Mate, Unity, Cinnamon);
- __Utilities__: Программы выполняют определенные функции для пользователей или других программ.

## Architecture

- __Hardware__: Аппаратное обеспечение, периферийные устройства (Например, CPU, RAM, жесткий диск);
- __Kernel__: Ядро предоставляет каждому процессу собственные виртуальные ресурсы и предотвращает конфликты между различными процессами;
- __Shell__: Интерфейс командной строки (Command-line interface, CLI) позволяет пользователю вводить команды для выполнения функций ядра;
- __System utility__: Предоставляет пользователю все функциональные возможности ОС.

## Terminal Hotkeys

- __CTRL+C__: Прерывает выполнение текущей команды;
- __CTRL+D__: Завершает текущий процесс;
- __CTRL+Z__: Приостанавливает выполнение процесса (Продолжить - `fg`);
- __CTRL+A__: Перемещает курсор в начало строки;
- __CTRL+E__: Перемещает курсор в конец строки;
- __CTRL+U__: Удаляет текст от курсора до начала строки;
- __CTRL+K__: Удаляет текст от курсора до конца строки;
- __CTRL+L__: Очищает экран;
- __CTRL+R__: Ищет вводимую строку в истории команд;
- __CTRL+W__: Удаляет слово перед курсором;
- __CTRL+Y__: Вставляет удаленный текст;
- __CTRL+P__: Перемещает курсор на одну строку вверх в истории команд;
- __CTRL+N__: Перемещает курсор на одну строку вниз в истории команд;
- __CTRL+T__: Меняет местами символы до и после курсора;
- __CTRL+F__: Перемещает курсор на одно слово вперед;
- __CTRL+B__: Перемещает курсор на одно слово назад;
- __CTRL+D__: Удаляет слово после курсора;
- __Alt+.__: Вставляет поледний аргумент предыдущей команды;
- __Tab__: Автодополнение имен файлов и команд;
- __CTRL+Alt+Del__: Перезагрузка системы.

## File descriptor and redirections

**stdin, stdout, stderr**

Оболочка bash имеет три основных потока; она принимает входные данные из stdin (поток 0), отправляет выходные данные в stdout (поток 1) и отправляет сообщения об ошибках в stderr (поток 2). Клавиатура часто служит в качестве stdin, тогда как stdout и stderr выводятся на дисплей. Отделение выходных данных от ошибок может быть очень полезным.

**Cтандартный вывод stdout** может быть перенаправлен со знаком больше, чем. При сканировании строки оболочка увидит знак > и очистит файл. Обозначение > на самом деле является аббревиатурой 1> (стандартный вывод упоминается как поток 1). 1> - это то же самое, что >.

**Используйте >> для добавления выходных данных в файл.**

**Перенаправление ошибок stderr**. Перенаправление stderr выполняется с помощью 2>. Это может быть очень полезно для предотвращения загромождения экрана сообщениями об ошибках.

По умолчанию вы не можете выполнять grep внутри stderr при использовании каналов в командной строке, поскольку передается только стандартный вывод. С помощью 2>&1 вы можете принудительно перевести stderr в стандартный вывод. Это позволяет команде в канале воздействовать на оба потока.

Файловый дескриптор — натуральное число (идентификатор), закреплённое за определённым потоком ввода-вывода. В Linux библиотека libc открывает для каждого запущенного приложения (процесса) 3 файл дескриптора, с номерами 0, 1, 2:
- Файл дескриптор 0 называется STDIN и ассоциируется с вводом данных у приложения;
- Файл дескриптор 1 называется STDOUT и используется приложениями для вывода данных, например командами print;
- Файл дескриптор 2 называется STDERR и используется приложениями для вывода данных, сообщающих об ошибке.

```bash
# Перенаправление стандартного ввода
cat < stdout.txt

# Перенаправление результата работы функции find в функцию grep, а затем перенаправление в функцию wc
find /etc/ -name *.conf 2>/dev/null | grep systemd | wc -l

# Перенаправление файлового дескриптора ошибок на нулевое устройство, которое отбрасывает все данные и перенаправление файлового дескриптора вывода в файл results.txt. `>` создает или перезаписывает файл, `>>` добавляет в файл
find /etc/ -name shadow 2>/dev/null > results.txt
# Явное перенаправление стандартного вывода:
find /etc/ -name shadow 2> stderr.txt 1> stdout.txt

# Перенаправление stdout и stderr в один и тот же файл
find / > allfiles_and_errors.txt 2>&1

# Нельзя использовать как 1>&2, так и 2>&1 для переключения stdout и stderr. Нужен третий поток для переключения stdout и stderr после символа канала
rm file1 3>&1 1>&2 2>&3 | sed 's/file1/FILE1/'

# Конструкция &> поместит как stdout, так и stderr в один поток (в файл)
rm file1 &> out_and_err
```

## Permission Management

![](materials/images/permissions.png)

- Разрешения назначаются пользователям и группам. Каждый пользователь может быть членом различных групп, и членство в этих группах дает пользователю особые дополнительные разрешения. 
- Каждый файл и каталог принадлежит определенному пользователю и определенной группе. 
- При создании новых файлов или каталогов, они принадлежат группе, к которой принадлежит пользователь, и пользователю.
- Для перемещения по каталогу необходимы разрешения на выполнение, независимо от уровня доступа пользователя. Разрешения на выполнение каталога не позволяют пользователю выполнять или изменять какие-либо файлы или содержимое в каталоге, а только просматривать и получать доступ к содержимому каталога.
- Чтобы изменить содержимое каталога (создать, удалить или переименовать файлы и подкаталоги), пользователю необходимы права на запись в каталоге.
- Вся система разрешений основана на восьмеричной системе счисления, и файлу или каталогу можно назначить три различных типа разрешений (`r` - Read, `w` - Write, `x` - Execute).
- Команда [chmod](#chmod) позволяет изменить разрешения (u — владелец, g — группа, o — другие, a — все пользователи), `+` или `-` для добавления и удаления назначенных разрешений.

### SUID & SGID

Set User Identifier (SUID) - На время выполнения файла (запущенного им процесса) непривилегированному пользователю получить права владельца файла

Set Group Identifier (SGID) Аналогичен SUID, но устанавливаются права группы — владельца файла. Также все файлы, создаваемые в каталогк с установленным SGID, будут получать идентификатор группы — владельца каталога, а не файла

Помимо назначения прямых разрешений для пользователей и групп, также можно настроить специальные разрешения для файлов, установив биты Set User ID (SUID) и Set Group ID (SGID). Эти биты SUID/SGID позволяют, например, пользователям запускать программы с правами другого пользователя. Администраторы часто используют это, чтобы предоставить своим пользователям особые права для определенных приложений или файлов. Вместо буквы «x» используется буква «s». При выполнении такой программы используется SUID/SGID владельца файла.

Если администратор установит бит SUID для «journalctl», любой пользователь сможет запустить оболочку от имени пользователя root.

### Sticky Bit

Sticky Bit — это тип прав доступа к файлам, которые можно установить для каталогов. Этот тип разрешений обеспечивает дополнительный уровень безопасности при контроле удаления и переименования файлов в каталоге. Обычно он используется в каталогах, которые используются несколькими пользователями, чтобы предотвратить случайное удаление или переименование одним пользователем файлов, которые важны для других. 

При использовании пользователь сможет удалить файл, только если будет являться владельцем этого файла или владельцем катаога, в котором содержится файл

Например, в общем домашнем каталоге, где несколько пользователей имеют доступ к одному и тому же каталогу, системный администратор может установить Sticky Bit для каталога, чтобы гарантировать, что только владелец файла, владелец каталога или пользователь root может удалять или переименовывать файлы в каталоге. Это означает, что другие пользователи не могут удалять или переименовывать файлы в каталоге, поскольку у них нет необходимых разрешений. Это обеспечивает дополнительный уровень безопасности для защиты важных файлов, поскольку только те, у кого есть необходимый доступ, могут удалять или переименовывать файлы. Установка Sticky Bit для каталога гарантирует, что только владелец, владелец каталога или пользователь root смогут изменять файлы в каталоге.

Когда для каталога установлен Sticky Bit, он обозначается буквой «t» в разрешении на выполнение разрешений каталога. Например, если каталог имеет разрешения «rwxrwxrwt», это означает, что установлен Sticky Bit, что дает дополнительный уровень безопасности, чтобы никто, кроме владельца или пользователя root, не мог удалять или переименовывать файлы или папки в каталоге.

Если Sticky Bit написан с заглавной буквы (T), то это означает, что все остальные пользователи не имеют разрешений на выполнение (x) и, следовательно, не могут видеть содержимое папки и запускать из нее какие-либо программы. Sticky Bit в нижнем регистре (t) — это Sticky Bit, в котором установлены разрешения на выполнение (x).

## Service and Process Management

Существует два типа служб: __внутренние__, которые требуются при запуске системы и которые, например, выполняют задачи, связанные с оборудованием, и __пользовательские__, которые обычно включают в себя все серверные службы. Такие службы работают в фоновом режиме без какого-либо взаимодействия с пользователем. Их также называют демонами и обозначают буквой «d» в конце имени программы, например, sshd или systemd.

Большинство дистрибутивов Linux перешли на systemd. Этот демон представляет собой инициализирующий процесс, запускаемый первым, и поэтому имеет PID 1. Этот демон контролирует и обеспечивает упорядоченный запуск и остановку других служб. Всем процессам присвоен PID, который можно просмотреть в /proc/ с соответствующим номером. Такой процесс может иметь идентификатор родительского процесса (PPID), и если имеет, то он называется дочерним процессом.

Процесс может находиться в следующих состояниях:
- Running;
- Waiting (ожидание события или системного ресурса);
- Stopped;
- Zombie (остановлен, но запись в таблице процессов все еще есть).

Чтобы взаимодействовать с процессом, мы должны послать ему сигнал. Мы можем просмотреть все сигналы с помощью `kill -l`. Из них часто используемые:
- __1 SIGHUP__: Отправляется процессу, когда терминал, который им управляет, закрывается;
- __2 SIGINT__: Отправляется, когда пользователь нажимает `Ctrl+C` в управляющем терминале, чтобы прервать процесс;
- __3 SIGQUIT__: Отправляется, когда пользователь нажимает `Ctrl+D` для выхода;
- __9 SIGKILL__: Немедленное завершение процесса без операций очистки;
- __15 SIGTERM__: Завершение программы;
- __19 SIGSTOP__: Остановить программу. С этим уже невозможно справиться;
- __20 SIGTSTP__: Отправляется, когда пользователь нажимает `Ctrl+Z`, чтобы запросить приостановку службы. Пользователь может справиться с этим позже.

### Background processes

Иногда необходимо перевести процесс в фоновый режим, чтобы продолжить использование текущего сеанса для взаимодействия с системой или запуска других процессов. Перевести процесс в фоновый режим можно с помощью `CTRL+Z`, указания `&` в конце командной строки. `bg` отображает все фоновые процессы. `fg <id>` позволяет вывести фоновый процесс в основной поток. Фоновые процессы позволяют использовать тот же сеанс оболочки, не дожидаясь, пока процесс сначала завершится. Как только сканирование или процесс завершат свою работу, терминал уведомит нас о завершении процесса.

### Executing multiple commands

Способы запуска нескольких команд разделителями:
- __;__: Игнорирует код возврата предыдущей команды;
- __&&__: Если код возврата предыдущей команды не 0, то выполнение команд прерывается;
- __|__: Зависит не только от корректной и безошибочной работы предыдущих процессов, но и от результатов предыдущих процессов.

## PTY

- Псевдотерминалы (PTY) - это абстрактные устройства в операционной системе Linux, предназначенные для обеспечения взаимодействия между процессами и терминалами. PTY используются для обеспечения доступа к текстовому вводу/выводу, такому как командная оболочка, через различные уровни абстракции
- Виртуальные терминалы используют псевдотерминалы (PTY), чтобы обеспечить взаимодействие пользователя с текстовой оболочкой
- В Linux каждый псевдотерминал имеет пару: мастер и слейв. Мастер является "внешним" интерфейсом, через который пользователь взаимодействует с псевдотерминалом, а слейв - "внутренним" интерфейсом, используемым программами
- VT создаются при загрузке системы и могут быть управляемыми с помощью утилит, таких как chvt и openvt. Пользователь может переключаться между VT с помощью клавиш Ctrl+Alt+F1, Ctrl+Alt+F2 и так далее
- Пользователь может войти в VT, введя логин и пароль. Для выхода из VT можно использовать команду exit. VT можно завершить, нажав Ctrl+Alt+Del (важно отметить, что это не то же самое, что перезагрузка системы). Управление VT можно выполнять с помощью утилиты chvt для переключения между VT
- PTY может быть создан с помощью системных вызовов, таких как openpty(), forkpty(), posix_openpt(), и других
- Процесс, создающий PTY, становится мастером, а второй процесс (обычно оболочка) становится слейвом

Один из наиболее распространенных способов использования PTY - это выполнение удаленных команд через SSH. При подключении к удаленному хосту, SSH использует PTY для обеспечения интерактивного текстового ввода/вывода между клиентом и сервером

## Bonding

**Бондинг (объединение сетевых интерфейсов, агрегирование каналов)** - это технология, позволяющая объединять несколько сетевых интерфейсов в одну виртуальную сетевую карту для увеличения пропускной способности и/или обеспечения отказоустойчивости.

Поведение связанных интерфейсов зависит от режима; режимы предоставляют либо услуги горячего резерва, либо услуги балансировки нагрузки. Кроме того, может выполняться мониторинг целостности канала.

Крайне важно указать параметры miimon или arp_interval и arp_ip_target , в противном случае во время сбоев канала произойдет серьезная деградация сети. Очень немногие устройства не поддерживают хотя бы miimon, поэтому нет причин не использовать его.

```bash
/etc/netplan/_____.yaml
cat /proc/net/bonding/bond0
```
- Конфигурационные файлы, отвечающие за конфигурирование Bond
```bash
ip a
ethtool
bmon
```
- Утилиты для проверки работоспособности Bond
```jsx
network:
	bonds:
		bond0:
			dhcp4: true
			interfaces: [ens38, ens33]
			parameters:
				mode: balance-rr
				transmit-hash-policy: layer3+4
				mii-monitor-interval: 1
	ethernets:
		ens38:
				dhcp4: false
				dhvp6: false
		ens33:
				dhcp4: false
				dhcp6: false
	version: 2
```
- Пример конфигурирования файлов для корректной работы Bond

## UMASK

**UMASK (user file-creation mode mask (маска режима создания файлов пользователя))** - маска доступа определяет, какие разрешения не будут установлены при создании новых файлов и каталогов.

**022** - это значение маски доступа, выраженное в восьмеричной системе счисления. В Linux права доступа к файлам и каталогам обычно представлены в восьмеричной нотации. Здесь каждая цифра представляет собой бит прав доступа.
- Права доступа для владельца файла: 0666 (восьмеричное) - 022 (маска) = 0644 (восьмеричное)
- Права доступа для владельца каталога: 0777 (восьмеричное) - 022 (маска) = 0755 (восьмеричное)

**UMASK 022**: При создании нового файла или каталога, права доступа к нему будут установлены так, чтобы владелец имел полные права (**`rw-`**), а группа и другие пользователи имели только права на чтение (**`r--`**) для файлов и на чтение и выполнение (**`r-x`**) для каталогов.

 **UMASK 077**: При создании новой учетной записи сам пользователь будет иметь полный доступ к своему домашнему каталогу и его содержимому, а все остальные пользователи не будут иметь никаких прав доступа к этим файлам и каталогам. Подробно:
1. **Создание новой учетной записи**:
    - При создании нового пользователя в системе учетная запись будет создана с указанным именем пользователя и UID (идентификатором пользователя).
    - Команда **`useradd`** или **`adduser`** используется для этой цели.
    - **Например: `sudo adduser igor`**
2. **Назначение домашнего каталога**:
    - По умолчанию новому пользователю будет назначен домашний каталог, обычно расположенный в **`/home/igor`**.
3. **Установка прав доступа к домашнему каталогу**:
    - Поскольку значение маски доступа (umask) установлено на **`077`**, права доступа к домашнему каталогу будут установлены таким образом, что только сам пользователь будет иметь доступ к своему домашнему каталогу, а остальные пользователи системы не будут иметь никаких прав доступа к этому каталогу.
    - Права доступа к домашнему каталогу будут: **`rwx------`** (чтение, запись и выполнение только для владельца).
4. **Назначение владельца и группы**:
    - Владельцем домашнего каталога будет новый пользователь, а группой будет также установлена группа с тем же именем, что и пользователь.
    - Например, если имя пользователя - **`igor`**, то владельцем и группой будет также **`igor`**.
5. **Ограничения доступа к файлам и каталогам**:
    - При создании файлов или каталогов в домашнем каталоге нового пользователя, права доступа будут ограничены по маске доступа (umask), установленной на **`077`**.
    - Для файлов права доступа будут: **`rw-------`** (чтение и запись только для владельца).
    - Для каталогов права доступа будут: **`drwx------`** (чтение, запись и выполнение только для владельца).

## CLI

- **CLI (Command Line Interface)** - текстовый интерфейс для работы с ОС
- **Терминал:** это окно или приложение, в котором пользователь взаимодействует с CLI. В Linux есть множество терминалов, включая виртуальные терминалы (VT) и терминалы в графической среде
- **Виртуальные терминалы (или VT)** - это механизм в операционной системе Linux, который предоставляет текстовые консоли, позволяющие пользователям взаимодействовать с системой в текстовом режиме. **Локальные VT** доступны напрямую с физической консоли, обычно через клавиши Ctrl+Alt+F1, Ctrl+Alt+F2 и так далее. **Удаленные VT** могут быть доступны посредством SSH или других удаленных протоколов
- **Оболочка (Shell):** оболочка - это программа, которая обрабатывает команды, введенные пользователем, и выполняет их. Примеры оболочек включают Bash, Zsh, Fish и другие
- **Команда:** это текст, введенный пользователем, который указывает системе, какое действие выполнить
- **Аргументы:** это дополнительные параметры, передаваемые команде, чтобы уточнить ее действие
- **Путь (Path):** это указание на файл или каталог в файловой системе
- **Псевдоним (Alias):** это короткое имя, которое может быть связано с длинной командой для удобства

### System Information

#### whoami

```bash
# Имя текущего пользователя
whoami
```

#### id

-

#### hostname

-

#### uname

```bash
# Архитектура процессора
uname -m
# Версия ядра ОС
uname -r
```

#### pwd

```bash
# Полный путь текущей директории
pwd
```

#### ifconfig

**ifconfig (настройка интерфейса)** - это инструмент управления сетью. Он используется для настройки и просмотра состояния сетевых интерфейсов в Linux. С помощью ifconfig вы можете назначать IP-адреса, включать или отключать интерфейсы, управлять кешем ARP, маршрутами и т. д.

- Конфигурации, установленные с помощью ifconfig, не являются постоянными. После перезапуска системы все изменения теряются. Чтобы сделать изменения постоянными, необходимо отредактировать файлы конфигурации конкретного дистрибутива или добавить команды в сценарий запуска.

> [!INFO] Кстати
> Только root или пользователи с привилегиями sudo могут настраивать сетевые интерфейсы

> [!ERROR] Внимание
> Команда ifconfig устарела, заменена ip на новых дистрибутивах Linux и может не входить в их состав

```bash
# Информация о всех сетевых устройствах
ifconfig -a

# Информация о конкретном сетевом устройстве
ifconfig eth0

# Отключить сетевой интерфейс
ifconfig eth0 down

# Включить сетевой интерфейс
ifconfig eth0 up

# Назначить интерфейсу eth0 IP-адрес и маску подсети
ifconfig eth0 192.168.1.1 netmask 255.255.255.0

# Назначить интерфейсу eth0 доп. IP-адрес и маску подсети
ifconfig eth0:0 192.168.1.1 netmask 255.255.255.0

# Включение/Отключение беспорядочного режима. Режим позволяет получать доступ ко всем пакетам сети
ifconfig eth0 promisc (OR -promisc)

# Изменение MTU сетевого устройства. Позволяет ограничить размер пакетов, передаваемых через интерфейс
ifconfig eth0 mtu 500

# Изменение MAC-адреса сетевого интерфейса
ifconfig eth0 hw ether 01:01:01:01:01:01
```

#### ip

**ip** - инструмент для настройки сетевых интерфейсов. Он используется для включения или выключения интерфейсов, назначения и удаления адресов и маршрутов, управления кешем ARP и многого другого. Утилита ip является частью пакета iproute2, который установлен во всех современных дистрибутивах Linux.

- Конфигурации, установленные с помощью ip, не являются постоянными. После перезапуска системы все изменения теряются. Чтобы сделать изменения постоянными, необходимо отредактировать файлы конфигурации конкретного дистрибутива или добавить команды в сценарий запуска.

> [!INFO] Кстати
> Только root или пользователи с привилегиями sudo могут настраивать сетевые интерфейсы

```bash
# Таблица маршрутизации
ip route

# Список всех сетевых интерфейсов
ip addr
# Или
ip a

# Отображение только IPv4-адресов
ip -4 addr

# Информация об интерфейсе
ip addr show dev eth0

# Добавление IP-адреса с маской сетевому устройству eth0. Таким образом можно назначать несколько IP-адресов одному интерфейсу
ip address add 0.0.0.0/24 dev eth0

# Удалить IP-адрес из интерфейса
ip address del 0.0.0.0/24 dev eth0

# Список всех сетевых интерфейсов. Не выводит информацию об IP-адресах
ip link show

# Информация о конкретном сетевом интерфейсе
ip link show dev eth0

# Включение интерфейса
ip link set dev eth0 up

# Выключение интерфейса
ip link set dev eth0 up

# Таблица маршрутизации
ip route
ip route list

# Маршрутизация для определенной сети
ip r list 127.0.0.0/24

# Добавление маршрута к 127.0.0.0/24 через шлюз 127.0.0.1
ip route add 127.0.0.0/24 via 127.0.0.1

# Добавление маршрута к 127.0.0.0/24, который может быть достигнут на устройстве eth0
ip route add 127.0.0.0/24 dev eth0

# Добавление маршрута по умолчанию через локальный шлюз 192.168.121.1, который может быть достигнут на устройстве eth0
ip route add default via 127.0.0.1 dev eth0

# Удаление маршрута по умолчанию
ip route del default

# Удаление маршрута для 127.0.0.0/24 через шлюз 127.0.0.1
ip route del 127.0.0.0/24 via 127.0.0.1
```

#### ethtool

- **ethtool** позволяет использовать утилиту с соответствующим именем для изменения низкоуровневых параметров сетевых карт. Данная утилита способна изменять огромное количество параметров сетевых карт, большая часть из которых не интересна обычным пользователям. Кроме того, драйверы сетевых карт домашних компьютеров и ноутбуков не позволяют изменять большую часть поддерживаемых утилитой параметров, поэтому в большинстве случаев она используется для проверки и установки скорости сетевого соединения, а также режима работы сетевой карты.

```bash
# Получение параметров сетевой карты
ethtool eth0

# Установка параметром сетевого соединения
ethtool -s eth0 speed 10 duplex full autoneg off

# Получение параметров драйвера сетевой карты
ethtool -i eth0

# Идентификация порта сетевой карты с помощью мигающего индикатора (7 сек)
ethtool -p eth0 7
```

#### netplan

- Начиная с релиза Ubuntu 17.10, для управления конфигурацией сети используется утилита netplan. Раньше для этих целей применялся скрипт ifupdown, конфигурационные файлы которого находились в папке /etc/network/interfaces. Недостатком такого подхода было то, что файлы настройки сети были разбросаны по всей системе, частью настроек мог управлять NetworkManager, частью systemd-networkd, а часть вообще делалась с помощью ifupdown
- Все конфигурационные файлы Netplan находятся в папке /etc/netplan/. Во время запуска службы, она преобразовывает свою конфигурацию в конфигурацию той службы, которая будет управлять сетью и помещает её в каталог /run/
- По умолчанию управление всей сетью передаётся утилите NetworkManager

> [!NOTE] Параметры netplan
> - **renderer** - программа для обработки конфигурации
> - **dhcp4** - получение IPv4 адреса по DHCP
> - **dhcp6** - получение IPv6 адреса по DHCP
> - **dhcp-identifier** - если передать значение "mac", то будет использоваться MAC-адрес в качестве идентификатора DHCP
> - **addresses** - добавляет статические адреса к интерфейсу, можно несколько
> - **gateway4** - указывает шлюз IPv4
> - **gateway6** - указывает шлюз IPv6
> - **nameservers** - указывает DNS-серверы
> - **macaddress** - устанавливает новый MAC-адрес
> - **routes** - позволяет настроить маршруты таблицы маршрутизации
> - **routing-policy** - дополнительная настройка маршрутов, для IP или подсети
> - **access-points** - список точек доступа для Wi-Fi
> - **password** - пароль для точки доступа Wi-Fi
> - **mode** - режим работы сетевой карты Wi-Fi

```yaml
ls /sys/class/net
```
- Названия сетевых интерфейсов в системе
```yaml
# /etc/netplan/02-networkd.yaml

network:
  version: 2
  renderer: networkd
   ethernets:
    ens33:
     dhcp4: yes
```
- Настройка динамического IP-адреса для интерфейса enp3s0
```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    ens33:
      dhcp4: yes
      nameservers:
        addresses:
          - 8.8.8.8
          - 8.8.4.4
```
- В качестве программы для обработки конфигурации используем Networkd, далее указываем сетевой интерфейс и включаем получение IPv4 адреса по DHCP. Все остальные параметры тоже подтянутся по DHCP. Или мы можем вручную настроить DNS для этого интерфейса
```bash
netplan generate
netplan apply
```
- Проверка и применение конфигурации. Для детального вывода добавить флаг debug
```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    ens33:
      dhcp4: no
      addresses: [ 192.168.1.10/24 ]
      gateway4: 192.168.1.1
      nameservers:
        addresses: [ 8.8.8.8, 8.8.4.4 ]
```
- Статический IP-адрес в netplan настроить немного сложнее. Нужно будет задать не только непосредственно сам адрес, но и другие параметры, которые система раньше получала по DHCP. Надо указать шлюз для доступа в интернет и DNS-серверы. Отключаем получение IP адреса по DHCP (dhcp4).  **addresses** параметр ожидает список IP-адресов, которые нужно присвоить сетевой карте. В конце адреса указывается префикс маски (/24). Маску можно указать только с помощью префикса. **gateway4** задаёт адрес роутера, через который компьютер сможет получить доступ в интернет. Списки можно оформлять не только с помощью черточек, для каждого пункта с новой строки, но и с помощью квадратных скобок, тогда элементы записываются в одну строку через запятую
```yaml
network:
  version: 2
  renderer: networkd
  wifis:
    wlp3s0b1:
      dhcp4: yes
      dhcp6: no
      nameservers:
        addresses: [ 8.8.8.8, 8.8.4.4 ]
      access-points:
        "AccessPoint":
          password: "12345678"
```
- Кроме проводного подключения, система конфигурации netplan умеет управлять подключением к Wi-Fi. Для работы Wi-Fi через Networkd необходим пакет wpasupplicant. На примере показано подключение к точке доступа AccessPoint с паролем 12345678


```
network:
    version: 2
    renderer: networkd
    ethernets:
        ens3:
            dhcp4: true
        ens7:
            dhcp4: no
            addresses: [192.168.122.195/24]
            routes:
              - to: default
                via: 192.168.122.1
            mtu: 1500
            nameservers:
                addresses: [8.8.8.8, 77.88.8.8]
                search: [ dmosk.local ]
        ens9:
            dhcp4: no
            addresses: [192.168.1.10/24, 192.168.1.20/24]
            nameservers:
                addresses:
                    - 8.8.8.8
                    - 77.88.8.8
                search: [ dmosk.local, dmosk.ru ]
```
- Пример настройки 3-х сетевых интерфейсов. Два из них будут с IP-адресами назначенными вручную (static IP), один по DHCP
- **version** - версия YAML. На момент обновления статьи, была 2
- **renderer** - менеджер сети (networkd или NetworkManager)
- **ethernets** - настройка сетевых адаптеров ethernet
- **ens3, ens7, ens9** - настройки для соответствующих сетевых адаптеров. В данном примере мы настраиваем 3 сетевых адаптера
- **dhcp4** - будет ли получать сетевой адаптер IP-адрес автоматически. Возможны варианты yes/true - получать адрес автоматически; no/false - адрес должен быть назначен вручную
- **addresses** - задает IP-адреса через запятую
- **routes** - настройка маршрутов. Для шлюза по умолчанию используем опцию и значение to: default. Ранее использовалась директива gateway4, но теперь она считается устаревшей (при применении настройки с ней система вернет предупреждение gateway4 has been deprecated, use default routes instead)
- **mtu** - при желании, можно задать значение MTU
- **nameservers** - настройка серверов имен (DNS)
- **nameservers addresses** - указываем серверы DNS. Обратите внимание на разный формат записи для ens7 и ens9. Приемлемы оба варианта
- **nameservers search** - дописывает окончание домена, если мы обращаемся к узлу сети только по его имени. Стоит обратить внимание, что мы можем указать несколько доменов через запятую
```
network:
    version: 2
    renderer: networkd
    ethernets:
        ens9:
            dhcp4: no
            addresses: 192.168.1.10/24
            nameservers:
                addresses:
                    - 8.8.8.8
                    - 77.88.8.8
            routes:
              - to: 192.168.0.0/24
                via: 192.168.1.1
                on-link: true
```
- Настройка маршрута для сетевого интерфейса ens9
- **to** - направление маршрута (в какую сеть мы должны попадать). В данном примере, 192.168.0.0/24
- **via** - через какой шлюз мы попадаем в сеть to
- **on-link** - активация маршрута при поднятии линка на сетевом интерфейсе


```
network:
    version: 2
    renderer: networkd
    ethernets:
        ens2f0: {}
        ens2f1: {}
    bonds:
        bond0:
            dhcp4: no
            interfaces:
            - ens2f0
            - ens2f1
            parameters:
                mode: active-backup
            addresses:
                - 192.168.122.195/24
            gateway4: 192.168.122.1
            mtu: 1500
            nameservers:
                addresses:
                    - 8.8.8.8
                    - 77.88.8.8
```
- Пример объединения интерфейсов (bonds). Объединяем физические интерфейсы ens2f0 и ens2f1; настройка parameters mode указываем на тип объединения:
- **balance-rr** (задействуются оба интерфейса по очереди, распределение пакетов по принципу Round Robin)
- **active-backup** (используется только один интерфейс, второй активируется в случае неработоспособности первого)
- **balance-xor** (задействуются оба интерфейса по очереди, распределение пакетов на основе политики хеширования xmit_hash_policy)
- **broadcast** (задействуются оба интерфейса одновременно, пакеты передаются все интерфейсы)
- **802.3ad** (задействуются оба интерфейса по очереди, распределение пакетов на основе политики хеширования xmit_hash_policy)
- **balance-tlb** (задействуются оба интерфейса по очереди, пакеты распределяются в соответствии с текущей нагрузкой)

```
network:
    version: 2
    renderer: networkd
    ethernets:
        ens2f0: {}
    bridges:
        br0:
            macaddress: ce:ce:ce:45:45:45
            interfaces:
                - ens2f0
            addresses:
                - 192.168.1.15/24
            gateway4:
            nameservers:
                addresses:
                    - 77.88.8.8
                    - 8.8.8.8
            mtu: 1500
            parameters:
                stp: true
                forward-delay: 4
            dhcp4: false
            dhcp6: false

```
- Пример настройки сетевого моста (bridge). Сетевой мост позволяет пропускать сетевой трафик через другой сетевой адаптер. Это можно применить, например, для организации хоста виртуальных машин (для трансфера трафика к виртуальным машинам KVM через единственный сетевой интерфейс сервера)
- **bridges** — настройки для интерфейсов bridge
- **bridges br0** — настройка интерфейса br0
- **macaddress** — физический адрес (MAC) интерфейса. Настройка важна для некоторых провайдеров VPS — без нее бридж может не заработать
- **interfaces** — перечисление интерфейсов, из которых собираем мост. В данном примере ens2f0
- **addresses, gateway4, nameservers** — сетевые настройки (IP-адрес, шлюз, сервер имен)
- **mtu** — одноименный параметр. Для сетей ethernet обычно равен 1500
- **parameters stp** — включает или отключает устранение петель в сети. В данном примере включено
- **parameters forward-delay** — время в секундах в течение которого мост будет оставаться в состояниях «Listening» и «Learning»
- **dhcp4, dhcp6** — включает или отключает автоматическое получение IP-адреса. В нашем случае, отключает

```
network:
    version: 2
    renderer: networkd
    ethernets:
        ens3: {}
    vlans: 
        vlan5:
            id: 5
            link: ens3
            dhcp4: no
            addresses: [10.0.0.15/24]
            gateway: 10.0.0.1
```
- Пример настройки тегированного интерфейса vlan с тегом 5 на физическом адаптере ens3

**Отключение netplan и возврат к interfaces**

```bash
vi /etc/default/grub
```
- Открываем настройку grub

`GRUB_CMDLINE_LINUX="netcfg/do_not_use_netplan=true"`
- Находим опцию GRUB_CMDLINE_LINUX и дописываем в нее параметр. Если GRUB_CMDLINE_LINUX содержит другие настройки, то наш параметр добавляем через пробел

```bash
apt install ifupdown
```
- Устанавливаем пакет ifupdown

```bash
nano /etc/network/interfaces
```
- Настраиваем сеть в файле

```
auto lo
iface lo inet loopback

auto ens5
iface ens5 inet dhcp
```
- Настраиваем сетевой интерфейс ens5 на автоматическое получение IP-адреса

```bash
update-grub
```
- Применяем настройки загрузчика

```bash
shutdown -r now
```
- Перезагружаем систему

#### netstat

**netstat** - это инструмент командной строки, который отображает полезную информацию, такую как сетевые соединения, таблицы маршрутизации, статистику интерфейса и многое другое, о сетевой подсистеме Linux. Это полезно для устранения неполадок в сети и анализа производительности.


> [!ERROR] Устарел
> Инструмент устарел, его заменой является ss.

```bash
# Отобразить все установленные сетевые соединения по TCP, UDP без разрешения имен в IP-адреса и PID и имена процессов, обеспечивающих соединения
netstat -tulnp

# Таблица маршрутизации
netstat -r

# Количество активных соединений на порту 80
netstat -an | grep :80 | sort
```

#### ss

**ss (статистика сокетов)** - мощная утилита командной строки для исследования сокетов. Он сбрасывает статистику сокетов и отображает информацию, аналогичную netstat. Кроме того, он показывает больше информации о TCP и состоянии по сравнению с другими аналогичными утилитами.

```bash
# Вывод список всех открытых TCP-портов
ss -ta

# Вывод всех активных TCP-соединений вместе с их таймерами
ss -to
```

Опции:
    - **V** — Version показать версию утилиты
    - **n** — Numeric не определять имена служб
    - **r** — Resolve определять сетевые имена адресов с помощью dns
    - **a** — All отобразить все сокеты (открытые соединения)
    - **l** — Listening показать только прослушиваемые сокеты
    - **o** — Options показать информацию таймера
    - **e** — Extended выводить расширенную информацию о сокете
    - **p** — Processes, показать процессы, использующие сокет
    - **i —** Internal, посмотреть внутреннюю информацию TCP
    - **s** — Summary, статистика использования сокета
    - **D** — экспортировать текущее состояние TCP сокетов в файл
    - **F** — работать с информацией, взятой из файла
    - **4, —ipv4** — только сокеты протокола IP версии 4
    - **6 —ipv6** — только сокеты протокола IP версии 6
    - **0, —packet** — только PACKET сокеты
    - **t, —tcp** — TCP сокеты
    - **u, —udp** — UDP сокеты
    - **d, —dhcp** — DHCP сокеты
    - **r, —raw** — RAW сокеты
    - **x, —unix** — UNIX сокеты

#### nc

**NC (NetCat)** - мощная утилита, используемая практически для любых задач, связанных с сокетами TCP, UDP или UNIX-домена. Он используется для открытия TCP-соединений, прослушивания произвольных TCP- и UDP-портов, выполнения сканирования портов и многого другого.

Может использоваться в качестве простых TCP-прокси, для тестирования сетевых демонов, проверки доступности удаленных портов и многого другого. Может использоваться вместе с pv для передачи файлов между двумя компьютерами.

```bash
# Сканирование списка портов
nc -zv 192.168.1.1 21 22 80 443 3000

# Сканирование диапазона портов
nc -zv 192.168.1.1 20-90

# Открытие TCP-соединения с портом 22 на 192.168.1.1, используя порт 3000 в качестве исходного порта, с таймаутом в 10 секунд
nc -p 3000 -w 10 192.168.1.1 22

# Прослушивание (-l) порта с подробным режимом
nc -nlv 8080
```

Популярные опции:
- `6` – использовать протокол IPv6. По умолчанию используется параметр -4 и IPv4 соответственно
- `h` – вывести справку со списком доступных параметров
- `i` задержка – добавить задержку между отправкой строк или сканированием портов. Задаётся в секундах
- `l` – режим прослушивания. Используется с указанием порта
- `N` – закрыть соединение при достижении конца файла при его отправке
- `n` – Работать с IP-адресами напрямую, не задействуя DNS, также отключить поиск портов
- `P имя_пользователя` – указать имя пользователя для подключения к прокси; x адрес:порт – указать адрес и порт для подключения к прокси
- `p порт` – указать номер порта. В большинстве случаев порт считывается без указания параметра
- `U` – использовать сокет домена UNIX (для межпроцессного взаимодействия);u – использовать протокол UDP, по умолчанию используется TСP
- `v` – подробный режим. Используется при сканировании портов
- `W количество_пакетов` – закрыть соединение после получения определённого количества пакетов
- `w таймер` – включить таймер для ограничения времени соединения. Задаётся в секундах
- `z` – отключить отправку данных. Используется при сканировании портов

#### host

**host** - это простая утилита для поиска DNS, она переводит имена хостов в IP-адреса и наоборот.

```bash
host ya.ru
host google.com
```

#### dig

**dig (поиск информации о домене)** также является еще одной простой утилитой поиска DNS, которая используется для запроса информации, связанной с DNS, такой как A Record, CNAME, MX Record и т. д.

Основные флаги:
- **+[no]all** — отображает или скрывает все установленные по умолчанию флаги отображения
- **+[no]answer** — отображает только ответ на запрос
- **+[no]fail** — эта опция указывает, должна ли утилита переключаться на следующий DNS сервер, если текущий не отвечает (по умолчанию стоит **+fail)**
- **+short** — сокращает вывод утилиты
- **+[no]cmd** — отключает вывод заголовка и информации об использованных опциях утилиты
- **+[no]identify** — используется вместе с флагом **+short** и отображает информацию об IP-адресе сервера
- **+[no]comments** — удаляет все комментарии из вывода утилиты
- **+[no]trace** - позволяет вывести список DNS серверов через которые прошёл запрос на получение информации о домене, по умолчанию отключено

Основные опции:
- **4** — позволяет использовать только IPv4
- **6** — позволяет использовать только IPv6
- **x** — предназначена для получения домена по IP
- **f** — используется для чтения списка доменов из файла
- **b IP-адрес** — позволяет указать исходящий IP-адрес, с которого отправлен запрос к DNS-серверу, полезно, если к компьютеру подключено несколько сетевых карт
- **r** — предотвращает чтение настроек из файла ~/.digrc
- **t** — позволяет указать тип записи, которую надо получить
- **p** — позволяет указать номер порта DNS сервера
- **u** — отображает время в секундах вместо миллисекунд

```bash
# Получить информацию о домене
dig example.com

# Получить только IP-адрес домена
dig +short example.com

# Использовать конкретный DNS-сервер для запроса
dig @0.0.0.0 example.com
```

#### nslookup

**nslookup** - утилита командной строки для интерактивного и неинтерактивного запроса DNS-серверов. Она используется для запроса записей ресурсов DNS (RR). Вы можете узнать запись «A» (IP-адрес) домена, как показано.

Основные опции:
- **type** - тип информации, которую хотим получить, возможные типы: txt, soa, ptr, ns, mx, mr, minfo, mg, mb, hinfo, gid, cname, a, any;
- **port** - другой порт DNS сервера;
- **recurse** - использоваться другие DNS серверы, если на этом нет ответа;
- **retry** - количество попыток получить нужную информацию;
- **timeout** - время между попытками запросов к серверу;
- **fail** - пробовать другой сервер имен, если этот вернул ошибку.

```bash
nslookup ya.ru
nslookup google.com
```


### Анализаторы сетевых пакетов Linux

#### tcpdump

**Tcpdump** - очень мощный и широко используемый сетевой сниффер командной строки. Он используется для захвата и анализа пакетов TCP/IP, переданных или полученных по сети на определенном интерфейсе.

При вызове обязательно нужно передать интерфейс для отслеживания. Если интерфейс не указать, то будет использован первый в списке.

Основные опции:
- **A** - выводить все пакеты в формате ASCII;
- **c** - закрыть программу после перехвата n-ого количества пакетов;
- **C** - при записи пакетов в файл, проверять размер файла, и если он больше заданного - создать новый файл;
- **D** - вывести список доступных сетевых интерфейсов;
- **e** - выводить информацию уровня соединения для каждого пакета, это может быть полезно, например, для отображения MAC адреса;
- **f** - выводить доменное имя для ip адресов;
- **F** - читать пакеты из файла, а не интерфейса;
- **G** - создавать новый файл лога через указанный промежуток времени;
- **H** - обнаруживать заголовки 802.11s;
- **i** - имя интерфейса для перехвата пакетов. Вы можете захватывать пакеты со всех интерфейсов, для этого укажите any;
- **I** - переключить интерфейс в режим монитора для захвата всех проходящих пакетов;
- **j** - установить формат Timestamp для записи пакетов;
- **J** - посмотреть доступные Timestamp;
- **K** - не проверять контрольные суммы пакетов;
- **l** - добавить поддержку прокрутки к выводу;
- **L** - вывести поддерживаемые протоколы подключения для интерфейса;
- **n** - не отображать доменные имена;
- **r** - прочитать пакеты из файла, созданного с помощью -w;
- **v, -vv, -vvv** - более подробный вывод;
- **q** - выводить минимум информации;
- **w** - записать вывод в файл;
- **Z** - пользователь, от имени которого будут создаваться файлы.

```bash
# Перехват пакетов, проходящих через интерфейс eth0
tcpdump -i eth0

# Перехват пакетов, проходящих через порт 80 без изменения IP в имена
tcpdump -n port 80

# Перехвать 10 пакетов и запись их в файл
tcpdump -c 10 -w capture.pcap
```

#### wireshark

**Wireshark** - это инструмент для захвата и анализа пакетов в сети с коммутацией пакетов в режиме реального времени.

Wireshark позволяет сохранять полученные данные в файл для последующего просмотра.

#### bmon

**bmon** - это утилита для сетевого мониторинга и отладки на основе командной строки для Unix-подобных систем, она собирает статистику, связанную с сетью, и выводит ее визуально в удобном для человека формате. Это надежный и эффективный монитор полосы пропускания и оценщик скорости в реальном времени.

#### ps

```bash
# Все процессы
ps aux

# Процессы включающие аргументы командной строки
ps -AFl

# Все процессы потока в древовидном режиме
ps -AlFH

# Процессы по иерархии
ps -e -o pid,args --forest

# Список процессов по владельцу
ps -U user -u user u

# Топ 5 процессов по использованию памяти
ps auxf | sort -nr -k 4 | head -5
```

#### who

-

#### env

```bash
# Текущие переменные окружения
env

# Установить переменную окружения
env VARIABLE=value

# Удалить переменную окружения
env -u VARIABLE
```

#### lsblk

```bash
sudo lsblk
```
- Команда **`sudo lsblk`** используется для вывода информации о блочных устройствах (диски (sda, sdb), разделы (sda1, sda2, sda3, и так далее) и точки монтирования) в системе
- **`NAME`** - это имя устройства
- **`MAJ:MIN`** - это мажорный и минорный номера устройства
- **`RM`** - это флаг, указывающий, является ли устройство съемным (1 - да, 0 - нет)
- **`SIZE`** - размер устройства
- **`RO`** - флаг, указывающий, доступно ли устройство только для чтения (1 - да, 0 - нет)
- **`TYPE`** - тип устройства (disk - диск, part - раздел)
- **`MOUNTPOINT`** - точка монтирования устройства (если оно смонтировано)

#### lsusb

-

#### lsof

```bash
# Показать все открытые файлы и сокеты
lsof

# Показать открытые файлы для определенного процесса
lsof -p PID

# Найти процесс, который использует определенный порт
lsof -i :port_number
```

#### lspci

-

#### jobs

-

### User Management

#### sudo

**sudo** (substitute user and do, подменить пользователя и выполнить) позволяет строго определенным пользователям выполнять указанные программы с административными привилегиями без ввода пароля суперпользователя root.

Использование sudo позволяет выполнять привилегированные команды обычным пользователям без необходимости ввода пароля суперпользователя root. Список пользователей и перечень их прав по отношению к ресурсам системы может быть настроен оптимальным образом для обеспечения комфортной и безопасной работы. Например, команда sudo в Ubuntu Linux, используется в режиме, позволяющем выполнять любые задачи администрирования системы без интерактивного входа под учетной записью root.

Параметры командной строки:
- `A, --askpass` - использовать вспомогательную программу для ввода пароля
- `b, --background` - выполнить команду в фоновом режиме
- `C, --close-from=num` - закрыть все дескрипторы файлов >= num
- `E, --preserve-env` - сохранить пользовательское окружение при выполнении команды
- `e, --edit` - редактировать файлы вместо выполнения команды
- `g, --group=group` - выполнить команду от имени или ID указанной группы
- `H, --set-home` - установить для переменной HOME домашний каталог указанного пользователя
- `h, --help` - показать справку и выйти
- `h, --host=host` - выполнить команду на узле (если поддерживается модулем)
- `i, --login` - запустить оболочку входа в систему от имени указанного пользователя; также можно задать команду
- `K, --remove-timestamp` - полностью удалить файл с timestamp
- `k, --reset-timestamp` - объявить недействительным файл timestamp
- `l, --list` - показать список прав пользователя или проверить заданную команду; в длинном формате используется дважды
- `n, --non-interactive` - автономный режим без вывода запросов пользователю
- `P, --preserve-groups` - сохранить вектор группы вместо установки целевой группы
- `p, --prompt=prompt` - использовать указанный запрос пароля
- `S, --stdin` - читать пароль из стандартного ввода
- `s, --shell` - запустить оболочку от имени указанного пользователя; также можно задать команду
- `U, --other-user=user` - в режиме списка показывать права пользователя
- `u, --user=user` - выполнить команду (или редактировать файл) от имени или ID указанного пользователя
- `V, --version` - показать сведения о версии и выйти
- `v, --validate` - обновить временную метку пользователя без выполнения команды
- `–` - прекратить обработку аргументов командной строки

```bash
# Обновить список пакетов
sudo apt update

# Удалить все файлы журналов
sudo rm -rf /var/log

# Редактировать файл конфигурации nginx
sudo nano /etc/nginx/nginx.conf

# Отобразить список команд, доступных для выполнения текущему пользователю. Кроме списка команд отображаются параметры среды, которые будут применяться при их выполнении
sudo –l

# Отобразить список команд, доступных для выполнения текущему пользователю в расширенном формате
sudo -ll

# Отобразить информацию о сетевом оборудовании с правами суперпользователя root
sudo lshw -C network

# Посмотреть список команд, доступных для выполнения пользователю user1. Для выполнения данной команды пользователь должен быть root или иметь право на выполнение команды sudo -l, что обеспечивается настройками утилиты sudo в файле /etc/sudoers
sudo –l –U user1

# Выполнить команду ipmitool sensor с правами root
sudo ipmitool sensor

- **`sudo su`** - выполнить команду su, т.е. создать сеанс суперпользователя root
- **`sudo -i`** - запустить командную оболочку с правами суперпользователя root. Для выполнения данной команды пользователь должен иметь право на выполнение программы оболочки в среде sudo, например - /bin/bash
- **`sudo ls /usr/local/protected`** - получить список файлов каталога, доступного только root
- **`sudo -u user2 ls ~`** - получить список файлов домашнего каталога пользователя user2
- **`sudo -u www vi ~www/htdocs/index.html`** - редактировать файл ~www/htdocs/index.html от имени пользователя www
- **`sudo -g adm view /var/log/syslog`** - просмотреть файл системного журнала, доступного только суперпользователю root и членам группы adm
- **`sudo -u user1 -g users2 vi /home/users2/textfile.txt`** - редактировать текстовый файл как пользователь user1, с принадлежностью к первичной группе users2
- **`sudo -E /usr/bin/firefox`** - запустить браузер firefox от имени суперпользователя root, сохранив параметры среды текущего пользователя. Возможность выполнения команд с сохранением среды пользователя должна быть разрешена параметром SETENV в настройках файла конфигурации sudo

```
- Примеры использования команды

Настройки sudo определяется содержимым файла `/etc/sudoers`. Поскольку ошибочные данные в данном файле могут привести к серьезным проблемам доступа к ресурсам системы, рекомендуется выполнять его изменение с помощью специального редактора sudoedit (в некоторых дистрибутивах - visudo), который поддерживает функции проверки синтаксиса и значительно снижает риск создания неработоспособной конфигурации sudo.

Содержимое файла `/etc/sudoers` определяет имена пользователей и групп, перечень выполняемых программ, необходимость введения паролей, и некоторые другие настройки, связанные с формированием переменных окружения при смене пользователя.

Кроме данного файла, настройки sudo могут определяться содержимым файлов из каталога `/etc/sudoers.d`, что позволяет структурировать систему предоставления прав на использование sudo в виде набора файлов с осмысленными именами, что полезно при большом количестве пользователей и сложной системе разграничения прав. Имена файлов конфигураций в каталоге `/etc/sudoers.d` могут быть любыми, но их содержимое должно полностью соответствовать формату файла `/etc/sudoers`.

**Специальные псевдонимы (Alias-ы)**

Синтаксис настроек в файле /etc/sudoers позволяет использовать специальные псевдонимы (Alias-ы), с помощью которых значительно упрощается как настройка, так и восприятие конфигурационной информации sudo:

- **В файле конфигурации /etc/sudoers возможно использование четырех разновидностей псевдонимов**
    
    - **User_Alias** - списки пользователей, для которых настраивается политика использования sudo.
    - **Runas_Alias** - списки пользователей, от имени которых может быть задано выполнение команд через sudo.
    - **Host_Alias** - списки узлов, с которых выполняется подключение к системе.
    - **Cmnd_Alias** - списки команд, использующиеся в настройках, выполняемых директивами файла /etc/sudoers
    
    **Примеры:**
    
    - **Host_Alias ADMCOMPS = localhost, server, admin** - определяет псевдоним ADMCOMPS, который определяет группу компьютеров с именами localhost, server, admin.
    - **Host_Alias MAILSERVERS = 192.168.0.100, smtp2** - определяет группу из двух компьютеров с указанными IP и именем. Возможно использование адресов подсетей.
    - **User_Alias ADMINS = jsmith, admusr** - определяет группу ADMINS, в которую входят пользователи с именами jsmith и admusr.
    
    <aside> 💡 Аналогичным образом можно создать псевдонимы для различных наборов команд, доступных для выполнения в sudo
    
    </aside>
    
- **Группы команд**
    
    - **Для работы в сети, псевдоним Networking**
        - Cmnd_Alias NETWORKING = /sbin/route, /sbin/ifconfig, /bin/ping, /sbin/dhclient, /usr/bin/net, /sbin/iptables, /usr/bin/rfcomm, /usr/bin/wvdial, /sbin/iwconfig, /sbin/mii-tool
    - **Для управления установкой и удалением программ, псевдоним SOFTWARE**
        - Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/up2date, /usr/bin/yum
    - **Для управления системными службами, псевдоним SERVICES**
        - Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig
    
    <aside> 💡 _Аналогичным образом можно создать псевдонимы для групп команд, выполнение которых делегируется одиночным или объединенных псевдонимами пользователей._
    
    </aside>
    
- **Формат записей**
    
    Основная часть настроек в файле /etc/sudoers задает правила, определяющие, какие пользователи, каких компьютеров, какие команды могут выполнять. Формат записей:
    
    - `user MACHINE=COMMANDS`
        - user - имена или псевдонимы пользователей.
        - MACHINE - имена или псевдонимы компьютеров
        - COMMANDS - секция команд, включающая имена или псевдонимы команд и дополнительные параметры.

```bash
# Разрешить выполнение пользователю root любых команд
root ALL=(ALL) ALL

# Разрешить выполнение всех команд для user через sudo. При данной настройке, у пользователя будет запрашиваться пароль (его личный, а не пароль суперпользователя root)
user ALL=(ALL) ALL

# Не запрашивать пароль для команд при использовании параметра NOPASSWD
user ALL=(ALL) NOPASSWD: /usr/bin/su, /usr/bin/drakxconf

# Разрешить группе пользователей, определенной псевдонимом “ADMINS” выполнять любые команды при подключении через петлевой интерфейс “localhost” без ввода пароля
ADMINS localhost=(ALL) NOPASSWD:ALL

# Разрешить группе пользователей, объединенных псевдонимом “ADMINS” выполнять группы команд, объединенные псевдонимами “NETWORKING” и “SOFTWARE”
ADMINS ALL=NETWORKING, SOFTWARE

# Разрешить локальным пользователям выключение компьютера
users localhost=/sbin/shutdown -h now

# Разрешить членам группы “operators” монтирование и размонтирование указанных устройств
operators ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom

# Разрешить членам группы “powerusers” выполнять команды группы “NETWORKING” с вводом пароля и команду “su” без пароля
powerusers ALL=NETWORKING, NOPASSWD: /usr/bin/su

# Разрешить группе пользователей, объединенных псевдонимом “ADMINS” выполнение всех команд, кроме команд, объединенных псевдонимом “NETWORKING”
ADMINS ALL= ALL, !NETWORKING

# Разрешение выполнения через sudo для всех пользователей группы “ADMINS”, всех команд, кроме команд смены оболочки
ADMINS ALL= ALL, !/bin/bash, !/usr/bin/su

# Кроме настроек доступа, в файле /etc/sudoers присутствуют директивы Defaults, определяющие некоторые настройки путей исполняемых файлов и создание переменных окружения при выполнении команд
Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin
Defaults env_reset
Defaults env_keep = “COLOS DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR LS_COLORS”
Defaults env_keep += “MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE”
Defaults env_keep += “LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES”
Defaults env_keep += “LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE”
Defaults env_keep += “LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY”

# По умолчанию, если интервал выполнения команд с использованием sudo, не превышает 5 минут, то повторный ввод пароля не требуется. Однако, это значение можно изменить, добавив значение timestamp_timeout в минутах. В данном случае, если команда sudo будет выполняться не позже, чем через 1 минуту после ввода пароля для предыдущей команды, то повторно пароль запрашиваться не будет. Если значение `“timestamp_timeout”` сделать равным нулю, то пароль будет запрашиваться при каждом запуске sudo, если сделать отрицательным (-1), то повторный ввод пароля не будет запрашиваться никогда
Defaults timestamp_timeout=1

# Исключение возможности выполнения sudo-команд при подключении через ssh
# Для исключения возможности выполнения sudo-команд при подключении через ssh без авторизации, по умолчанию, должна использоваться команда “ssh –t “

# sudo можно запускать только из сеанса входа в систему, а не с помощью других средств, таких как скрипты `cron, shell/perl/python` или `cgi-bin scripts`. Этот флаг установлен по умолчанию на многих дистрибутивах
Defaults    requiretty

# Подробная справка по использованию sudo
man sudo
man sudoers
```
- Примеры конфигурации /etc/sudoers
- Использование псевдонимов позволяет уменьшить необходимое число записей для определения прав пользователей, которые могут подключаться к системе с разных компьютеров и входить в разные группы
- Довольно часто возникает необходимость исключения разрешения на выполнение отдельных команд из списка, объединенных псевдонимом. В этом случае, перед именем команды или псевдонима ставится восклицательный знак – !

> [Лаба](materials/labs/linux_labs/lab_10.md)

#### passwd

/etc/passwd - Представляет собой простую текстовую базу данных, которая содержит информацию обо всех учетных записях в системе

- Первое поле отвечает за имя пользователя
- Второе поле содержит «x». На устаревших Linux-системах второе поле содержало зашифрованных пароль для аутентификации, но фактически, сейчас все Linux-системы хранят эту информацию в файле /etc/shadow.
- Третье поле отвечает за числовой пользовательский идентификатор, связанный с конкретным пользователем
- Четвертое поле ассоциирует этого пользователя с конкретной группой; скоро мы увидим, где определена группа 1000.
- Пятое поле содержит текстовое описание аккаунта, в нашем случае это имя пользователя. 
- Шестое поле определяет домашний каталог пользователя 
- Седьмое устанавливает стартовую оболочку пользователя, которая будет автоматически запускаться когда пользователь входит в систему.

/etc/shadow - Это зашифрованный файл паролей, в котором хранится зашифрованная информация о паролях для учетных записей пользователей В дополнение к этому файл /etc/shadow хранит дополнительную информацию о сроке действия пароля

```bash
# Сменить пароль текущего пользователя
passwd

# Сменить пароль пользователя
passwd username
```

#### useradd

```bash
# Создать пользователя user1, назначить домашний каталог /home/user1, назначить shell /bin/bash, включить в группу admin и добавить комментарий Comment
useradd -c "Comment" -g admin -d /home/user1 -s /bin/bash user1

# Создать пользователя user1
useradd user1

# Создать пользователя с домашним каталогом
useradd -m user1

# Создать пользователя и добавить в группу sudo
useradd -G sudo user1
```

#### userdel

```bash
# Удалить пользователя и его каталог
userdel -r user1
```

#### usermod

```bash
# Добавить пользователя в группу sudo
usermod -aG sudo user1

# Изменение атрибутов пользователя
usermod -c "User FTP" -g system -d /ftp/user1 -s /bin/nologin user1
```

#### groupadd

```bash
# Создать группу
groupadd name

# Создать системную группу
groupadd -r name
```

#### groupdel

```bash
# Удалить группу
groupdel name

# Удалить группу без предупреждения
groupdel -f name

# Удалить группу, включая связанные файлы и каталоги
groupdel --remove name

# Удалить группу и перенести файлы в другую группу
groupdel --move-to=backupgroup name
```

#### groupmod

```bash
# Изменить название группы
groupmod -n newname oldname

# Изменить GID группы
groupmod -g 1000 name

# Добавить пользователей в группу
groupmod -m -g name user1,user2

# Исключить пользователей из группы
groupmod -g name user1,user2
```

### Package Management


#### git

Git - это очень популярная система контроля версий и совместной разработки проектов с открытым исходным кодом. С помощью Git вы можете отслеживать изменения в исходном коде своих проектов, возвращать предыдущие версии в случае критических ошибок, а также делиться своим кодом со всеми желающими и принимать от них исправления.Это мощная система, которая позволяет оптимизировать работу над вашими проектами. Здесь нет каких-либо требований к языку или структуре файлов, поэтому у разработчиков полная свобода действий.

#### dpkg

**DPKG (Debian Package)** - система управления пакетами в Debian и дистрибутивах на его основе, например Ubuntu. Низкоуровневый пакетный менеджер создан только для работы с локальными DEB пакетами и не может самостоятельно разрешать зависимости, а также скачивать пакеты из репозиториев.

Удаление пакетов с использованием dpkg в большинстве случаев не рекомендуется. Лучше использовать менеджер пакетов, отслеживающий зависимости, чтобы гарантировать, что система находится в связанном состоянии. Например, использование dpkg -r zip удалит пакет zip, однако любые пакеты, зависящие от него, останутся установленными и более не смогут работать правильно.

```bash
# Установить пакет
dpkg -i package.deb

# Удалить пакет из системы
dpkg -r package

# Показать все пакеты, установленные в системе
dpkg -l

# Найти пакет, содержащий в имени httpd
dpkg -l | grep httpd

# Информация о конкретном пакете
dpkg -s package

# Вывести список файлов, входящих в пакет, установленный в систему
dpkg -L package

# Отобразить список файлов, входящих в пакет, который еще не установлен в систему
dpkg --contents package.deb

# Найти пакет, в который входит указанный файл
dpkg -S /bin/ping
```

### Basic

#### date

```bash
# Текущая дата
date

# Установить системные дату и время ММДДЧЧммГГГГюСС (МесяцДеньЧасМинутыГод.Секунды)
date 123123592024.00

# Форматированный вывод текущей даты
date "+%Y-%m-%d %H:%M:%S %A %B %Y"

# Установка даты и времени через форматированный ввод
date --set="2024-04-28 09:30:00"
```

#### df

Отчёт об использовании дискового пространства в системе в процентах и килобайтах.

```bash
# Информация о дисках системы
df

# Информация о текущем диске в удобном формате
df -h .
```

#### du

```bash
# Размер файлов и каталогов в текущем каталоге, отсортированных по размеру
du -ah | sort -rh

# Размер файла
du file

# Размеры всех файлов и каталогов в каталоге
du -sh *

# Размер каждого подкаталога в текущем каталоге
du -h --max-depth=1
```

#### export

```bash
# Экспортировать переменную окружения
export VARIABLE=value

# Проверить экспортированные перменные окружения
export

# Сбросить экспортированную переменную окружения
export -n VARIABLE
```

#### find

```bash
# Найти файлы и каталоги с именем file1 в каталоге /
find / -name file1

# Найти файлы и каталоги с владельцем user1 в каталоге /
find / -user user1

# Найти файлы и каталоги, имена которых оканчиваются на .bin в каталоге /
find / -name "*.bin"

# Найти файлы в каталоге /, время последнего обращения к которым более 100 дней
find / -type f -atime +100

# Найти файлы в каталоге /, созданные или измененные в течение последних 10 дней
find / -type f -mtime -10

# Найти файлы и каталоги в каталоге /, размер которых больше 1 мбайта
find / -size +1M
```

#### free

```bash
# Информация об оперативной памяти
free

# Информация об оперативной памяти каждую секунду
free -s 1
```

#### gunzip

```bash
# Распаковать файл
gunzip file.gz

# Распаковать файл и вывести в файл uncompressed_file
gunzip -c file.gz > uncompressed_file
```

#### gzip

```bash
# Сжать файл и создать file.gz
gzip file
```

#### history

```bash
# Последние 20 выполненных команд
history 20

# Очистить историю команд
history -c
```

#### locate

```bash
# Найти файл по названию без учета регистра
locate -i file.txt

# Обновление БД для поиска файлов
updatedb
```

#### man 

Самой известной справочной системой, сопровождающей UNIX практически с момента ее рождения, является справочная система страниц руководства, информация из которой доступна при помощи команд `man`, `apropos` и `whatis`.

Справочная система `man-pages` состоит из отдельных страниц, посвященных отдельным командам, специальным файлам устройств, конфигурационным файлам, системным и библиотечным вызовам и другим понятиям, которые сгруппированы по восьми (обычно, но есть исключения из правил) секциям. Каждая секция имеет заголовочную страницу intro, описывающую назначение самой секции.

Команда **man** ответственна за поиск указанной пользователем страницы, распаковку ее сжатого файла при помощи распаковщика **gzip**, форматирования при помощи процессора **troff** и (по умолчанию) вывод результата на терминал при помощи постраничного листателя **less**.

```bash
# Доступные команды с помощью встроенной справки
man -k .

# Доступные команды с помощью руководства пользователя
info coreutils
```

```bash
whatis intro
whatis whatis
whatis apropos
whatis nan
```
- Секции справочной системы man
```bash
man -w man
file /usr/share/man/m/manl/man.l.gz
file -z /usr/share/man/ru/manl/man.l.gz
whatis file
```
- Формат страниц справочной системы man
```bash
man -t man > man.print.1
file man.print.1
man -T lz4 man > man.print.2
file man.print.2
man -thtml man > man.html
file man.html
```
- Форматирование справочных страниц руководства для печати и для html-браузера


Обычно название страницы совпадает с именем команды или названием программы. Вся справка разделена на несколько разделов. По умолчанию страницы справки выводятся из всех разделов, но вы можете выводить страницы справки из определённого раздела. Для этого достаточно передать номер раздела команде. Вот список основных разделов:

- 1 - команды оболочки или программы
- 2 - системные вызовы
- 3 - функции библиотек
- 4 - файлы из каталога /dev
- 5 - форматы файлов
- 6 - игры
- 7 - разное
- 8 - команды администрирования системы
- 9 - процедуры ядра

**Для просмотра информации и управлением страницей справки используются такие горячие клавиши:**

- стрелка вверх/вниз - прокрутка информации вверх или вниз
- e или j - переместиться на одну строку вверх
- y или h - переместиться на одну строку вниз
- z - переместиться на одно окно вниз
- w - переместиться на одно окно вверх
- d - переместиться на пол окна вниз
- u - переместиться на пол окна вверх
- / - поиск вхождений указанных после символов вперед
- ? - то же самое, что и предыдущее, только поиск назад
- n - в режиме поиска отображение следующего вхождения
- N - в режиме поиска отображение предыдущего вхождения

```bash
# Руководство по команде ls
man ls

# Описание системного вызова fork
man 2 fork
```

#### mount

Основные опции:
    - V - вывести версию утилиты;
    - h - вывести справку;
    - v - подробный режим;
    - a, --all - примонтировать все устройства, описанные в fstab;
    - F, --fork - создавать отдельный экземпляр mount для каждого отдельного раздела;
    - f, --fake - не выполнять никаких действий, а только посмотреть что собирается делать утилита;
    - n, --no-mtab - не записывать данные о монтировании в /etc/mtab;
    - l, --show-labels - добавить метку диска к точке монтирования;
    - c - использовать только абсолютные пути;
    - r, --read-only - монтировать раздел только для чтения;
    - w, --rw - монтировать для чтения и записи;
    - L, --label - монтировать раздел по метке;
    - U, --uuid - монтировать раздел по UUID;
    - T, --fstab - использовать альтернативный fstab;
    - B, --bind - монтировать локальную папку;
    - R, --rbind - перемонтировать локальную папку.

```bash
# Монтировать только для чтения
mount -r /dev/sdb /home2
mount -o ro /dev/sdb /home2

# Монтировать раздел hda2 в точку монтирования /mnt/hda2
mount /dev/hda2 /mnt/hda2

# Монтировать ISO-образ в каталог /mnt/cdrom
mount -o loop file.iso /mnt/cdrom

# Все примонтированные файловые системы, включая имя устройства, тип файловой системы, точка монтирования, параметры.
mount

# Отключение файловой системы, а именно смонтированного ISO-образа.
unmount /mnt/cdrom
```


```bash
echo "UUID=0000-0000-0000-0000 /home2 ext4 defaults 0 0" >> /etc/fstab
```
- Чтобы после перезагрузки диски не отмотировались, необходимо сделать запись в файле `/etc/fstab` для автоматического монтирования во время загрузки. Для записи потребуется ввести UUID раздела, его можно посмотреть с помощью команды `sudo blkid`

```bash
[устройство] [точка_монтирования] [файловая_система] [опции резерв{0,1}] [проверка{0,1,2}]
```
- Синтаксис конфига
- Устройство - это раздел диска, который нужно монтировать. Его можно указать в формате файла устройства Linux в каталоге /dev/, например, /dev/sda1 или с помощью уникального идентификатора UUID
- Файловая система указывает в какой файловой системе нужно монтировать это устройство (ext4, ext3, ext2, btrfs)
- Точка монтирования - куда нужно примонтировать это устройство (/home, /boot, /mnt)
- Опции - параметры монтирования файловой системы
- Проверка - указывает в какой очереди нужно проверять устройство на ошибки (1 - в первую очередь, 2 - вторую, 0 - не проверять)
- Резерв - указывает нужно ли делать резервную копию раздела (0 или 1)

#### reboot

```bash
# Перезагрузка системы
reboot
```

#### service

```bash
# Запуск сервиса nginx
service nginx start

# Статус сервиса ssh
service ssh status

# Остановить сервис Apache2
service apache2 stop
```

#### shutdown

```bash
# Остановка системы
shutdown -h now

# Запланированная остановка системы
shutdown -h hours:minutes &

# Отмена запланированной остановки системы
shutdown -c

# Перезагрузка системы через 5 минут
shutdown -r +5
```

#### tar

Команда **tar** является наиболее часто используемой командой для архивирования нескольких файлов в **tarball** — общий формат файлов Linux, аналогичный формату zip, при этом сжатие является опциональным.

Это довольно сложная команда с длинным списком функций, таких как добавление новых файлов в существующий архив, перечисление содержимого архива, извлечение содержимого из архива и многое другое.

```bash
# Создать сжатый архив из каталога folder
tar -czvf archive.tar.gz folder/

# Распаковать архив
tar -xvf archive.tar

# Показать содержимое архива без распаковки
tar -tf archive.tar
```

#### uptime

```bash
# Текущее время, время работы системы, количество пользователей, средняя нагрузка
uptime
```

#### w

```bash
# Отображение пользователей в системе и их действия
w
```

#### wget

Альтернативой Curl является инструмент wget. С помощью этого инструмента можно загружать файлы с FTP или HTTP-серверов прямо из терминала, и он служит хорошим менеджером загрузок.

```bash
# Загрузка файла file.tar.gz с сайта
wget http://example.com/file.tar.gz

# Рекурсивная загрузка всего сайта
wget -r http://example.com

# Загрузка файла и сохранение с указанным именем
wget -0 newfile.html http://example.com
```

#### whatis

```bash
# Краткое описание команды python
whatis python
```

#### which

```bash
# Полный путь к исполняемому файлу python
which python
```

#### zip

**Для создания zip-архива просто выполняем команду zip, в первом аргументе указываем имя будущего архива, а во втором сам файл, который мы сжимаем:**

```bash
zip myfile.zip myfile.txt
```

> Команда **`zip myfile.zip myfile.txt`** используется для создания нового архива с именем **`myfile.zip`**, в который включается файл **`myfile.txt`**.

- **`zip`**: Это утилита для архивации файлов и каталогов.
- **`myfile.zip`**: Это имя архива, который вы создаете.
- **`myfile.txt`**: Это файл, который вы добавляете в архив.

**Если нужно сжать несколько файлов то перечисляем их через пробел:**

```bash
zip myarchive.zip myfile.txt yourfile.txt theirfile.txt
```

> Команда **`zip myarchive.zip myfile.txt yourfile.txt theirfile.txt`** используется для создания нового архива с именем **`myarchive.zip`**, в который включены файлы **`myfile.txt`**, **`yourfile.txt`** и **`theirfile.txt`**.

- **`zip`**: Это утилита для архивации файлов и каталогов.
- **`myarchive.zip`**: Это имя архива, который вы создаете.
- **`myfile.txt`**, **`yourfile.txt`**, **`theirfile.txt`**: Это файлы, которые вы добавляете в архив.

Таким образом, после выполнения этой команды файлы **`myfile.txt`**, **`yourfile.txt`** и **`theirfile.txt`** будут добавлены в архив с именем **`myarchive.zip`**. Получившийся архив будет содержать все эти файлы. Создание архива позволяет объединить несколько файлов в один для удобства хранения, передачи или архивации.

**Создаем zip-архив папки, чтобы заархивировать папку, используется ключ -r:**

```bash
zip -r mydir.zip verygooddir
```

> Команда **`zip -r mydir.zip verygooddir`** используется для создания нового архива с именем **`mydir.zip`**, который содержит все файлы и подкаталоги в каталоге **`verygooddir`**, а также все файлы и подкаталоги внутри этих подкаталогов.

- **`zip`**: Это утилита для архивации файлов и каталогов.
- **`r`**: Опция **`r`** (или **`-recursive`**) указывает **`zip`**у рекурсивно включить в архив все файлы и подкаталоги в указанном каталоге и его подкаталогах.
- **`mydir.zip`**: Это имя архива, который вы создаете.
- **`verygooddir`**: Это имя каталога, содержимое которого вы хотите добавить в архив.

**Создаем zip-архив с паролем**

_Очень важной функцией утилиты zip является возможность задания пароля на распаковку архива. Для этого применяется опция -P, после которой следует написать пароль:_

```bash
zip -P мойпароль -r mysecretdir.zip mysecretdir
```

> Команда **`zip -P мойпароль -r mysecretdir.zip mysecretdir`** используется для создания зашифрованного архива с именем **`mysecretdir.zip`**, который содержит все файлы и подкаталоги в каталоге **`mysecretdir`**, а также все файлы и подкаталоги внутри этих подкаталогов. Архив будет зашифрован с помощью пароля **`мойпароль`**.

- **`zip`**: Это утилита для архивации файлов и каталогов.
- **`P мойпароль`**: Это опция **`P`**, которая используется для указания пароля для зашифровки архива. **`мойпароль`** здесь представляет ваш пароль.
- **`r`**: Опция **`r`** (или **`-recursive`**) указывает **`zip`**у рекурсивно включить в архив все файлы и подкаталоги в указанном каталоге и его подкаталогах.
- **`mysecretdir.zip`**: Это имя архива, который вы создаете.
- **`mysecretdir`**: Это имя каталога, содержимое которого вы хотите добавить в архив.

**Если вы не хотите вводить пароль в командной строке у всех на виду, то можно использовать опцию -e, чтобы вместо ввода пароля в открытую, вводить его в срытом виде:**

```bash
zip -er mysecretdir.zip mysecretdir
```

> Команда **`zip -er mysecretdir.zip mysecretdir`** используется для создания зашифрованного архива с именем **`mysecretdir.zip`**, который содержит все файлы и подкаталоги в каталоге **`mysecretdir`**.

- **`zip`**: Это утилита для архивации файлов и каталогов.
- **`e`**: Опция **`e`** (или **`-encrypt`**) используется для указания на необходимость зашифровки создаваемого архива. При использовании этой опции **`zip`** запросит у вас пароль для шифрования архива.
- **`r`**: Опция **`r`** (или **`-recursive`**) указывает **`zip`**у рекурсивно включить в архив все файлы и подкаталоги в указанном каталоге и его подкаталогах.
- **`mysecretdir.zip`**: Это имя архива, который вы создаете.
- **`mysecretdir`**: Это имя каталога, содержимое которого вы хотите добавить в архив.

**После выполнения данной команды, вам будет предложено дважды ввести пароль. Сам пароль виден при этом не будет:**

```
Enter password:
Verify password:
```

**Распаковка zip-архива**

_Для того, чтобы разархивировать zip-архив, используется команда unzip. Ее можно запускать без опций, только указывая имя архива:_

```bash
unzip myfile.zip
```

> Команда **`unzip myfile.zip`** используется для распаковки архива с именем **`myfile.zip`**.

- **`unzip`**: Это утилита для извлечения файлов из архивов.
- **`myfile.zip`**: Это имя архива, который вы хотите распаковать.

После выполнения этой команды содержимое архива **`myfile.zip`** будет извлечено и разархивировано в текущий рабочий каталог. Если в архиве есть подкаталоги, то они будут созданы в текущем каталоге, а файлы будут извлечены в соответствующие подкаталоги.

**По умолчанию распаковка происходит в текущей директории. Чтобы распаковать архив в другую директорию, используется опция -d, после которой нужно указать путь до директории:**

```bash
unzip myfile.zip -d mydir
```

> Команда **`unzip myfile.zip -d mydir`** используется для распаковки архива с именем **`myfile.zip`** и извлечения его содержимого в указанный каталог **`mydir`**.

- **`unzip`**: Это утилита для извлечения файлов из архивов.
- **`myfile.zip`**: Это имя архива, который вы хотите распаковать.
- **`d mydir`**: Опция **`d`** используется для указания каталога, в который вы хотите извлечь содержимое архива. **`mydir`** здесь представляет имя целевого каталога.

```bash
# Создание архива из содержимого каталога folder
zip -r archive.zip folder/

# Создание зашифрованного архива с файлом file.txt
zip -e secure.zip file.txt

# Распаковка архива в текущий каталог
unzip archive.zip
```

#### chattr

**chattr (Change Attribute)** - это утилита командной строки в linux, которая используется для установки/снятия специальных атрибутов файлов для предотвращения случайной модификации и удаления файлов или директорий, даже если вы авторизованы как root.

Предположим вы хотите защитить некоторые важные файлы в Linux. При чем они должны быть защищены не только от перезаписи но и от случайного или преднамеренного удаления и перемещения. Предотвратить перезапись или изменение битов доступа к файлов можно с помощью стандартных утилит chmod и chown, но это не идеальное решение, так как у суперпользователя по прежнему остается полный доступ. Но есть еще одно решение. Это команда chattr. Эта утилита позволяет устанавливать и отключать атрибуты файлов, на уровне файловой системы не зависимо от стандартных (чтение, запись, выполнение). Для просмотра текущих атрибутов можно использовать lsattr. Изначально атрибуты управляемые chattr и lsattr поддерживались только файловыми системами семейства ext (ext2,ext3,ext4). но теперь эта возможность доступна и в других популярных файловых системах таких как XFS, Btrfs, ReiserFS, и т д. Утилиты `chattr` и `lsattr` входят в пакет e2fsprogs и предустановлены во всех современных дистрибутивах.

```bash
chattr опции [оператор][атрибуты] файлы
```
- Базовый синтаксис chattr выглядит следующим образом
```
-R - рекурсивная обработка каталога;
-V - максимально подробный вывод;
-f - игнорировать сообщения об ошибках;
-v - вывести версию.
```
- Основные опции
```
+ - включить выбранные атрибуты;
- - отключить выбранные атрибуты;
= - оставить значение атрибута таким, каким оно было у файла.
```
- Основные операторы
```
a - файл может быть открыт только в режиме добавления;
A - не обновлять время перезаписи;
c - автоматически сжимать при записи на диск;
C - отключить копирование при записи;
D - работает только для папки, когда установлен, все изменения синхронно записываются на диск сразу же;
e - использовать extent'ы блоков для хранения файла;
i - сделать неизменяемым;
j - все данные перед записью в файл будут записаны в журнал;
s - безопасное удаление с последующей перезаписью нулями;
S - синхронное обновление, изменения файлов с этим атрибутом будут сразу же записаны на диск;
t - файлы с этим атрибутом не будут хранится в отдельных блоках;
u - содержимое файлов с этим атрибутом не будет удалено при удалении самого файла и потом может быть восстановлено.
А теперь давайте перейдем к примерам работы с утилитой chattr и сделаем файл неизменяемым.
```
- Основные атрибуты
```bash
# Просмотр текущих атрибутов файла
lsattr /etc/resolv.conf

# Сделать файл неизменяемым. Теперь файл неизменяемый, и ни один пользователь не сможет его изменить. И более того, даже суперпользователь не сможет модифицировать, перезаписать или удалить этот файл. Перед тем как что либо делать с этим файлом нужно отключить атрибут
chattr +i /etc/resolv.conf

# Сделать все файлы в директории неизменямыми
chattr -R +i /etc/

# Разрешать только добавлять информацию в файл, без возможности перезаписи
chattr +a /var/log/syslog
```

#### sg

**sg** (set group ID) - утилита выполнения команды с измененным эффективным идентификатором группы (GID). Она позволяет пользователю временно выполнять команду с правами определенной группы, что может быть полезным для решения различных задач в системах с множеством пользователей. Давайте рассмотрим практическую работу с **`sg`** на двух серверах Ubuntu (клиент и сервер).

```bash
sg [-] [группа] [-c команда] [-s shell] [аргументы команды]
```
- `-` : Опциональный параметр. Если указан, то среда пользователя (например, переменные окружения) не будет изменена при переключении группы.
- **`группа`**: Имя группы, в которую нужно переключиться.
- **`c команда`**: Выполнить указанную команду в новой группе.
- **`s shell`**: Использовать указанный интерпретатор команд (shell) в новой группе.
- **`аргументы команды`**: Аргументы, передаваемые выполненной команде.


```bash
# Выполнение команды от имени группы admin, получение доступа к файлам, к которым нет доступа
sg admin -c "ls /var/admin-files"

# Запуск интерактивной оболочки (shell) от имени другой группы
sg developers -c /bin/bash

# Вывод текущей переменной окружения от имени другой группы
sg - developers -c "echo \\$HOME"
```

> [Лаба](materials/labs/linux_labs/lab_9.md)

### Filter Contents

#### head

```bash
# Вывести первые 10 строк файла
head file

# Вывести первые 20 строк файла
head -n 20 file
```

#### less

```bash
# Содержимое файла с пролистыванием
less file

# Поиск слова в файле
less file
/pattern
```

#### more

-

#### tail

```bash
# Последние строки системного журнала
tail /var/log/syslog

# Последние 20 строк журнала доступа Nginx
tail -n 20 /var/log/nginx/access.log
```

#### sort

```bash
# Сортировка по алфавиту
sort file

# Сортировка двух файлов
sort file1 file2

# Сортировка файлов, отображая только повторяющиеся строки
sort file1 file2 | uniq -d

# Сортировка файлов, отображая только уникальные строки
sort file1 file2 | uniq -u

# Сортировка в обраном порядке
sort -nr file
```

#### grep

[Link](materials/linux/grep.md)

#### cut

```bash
# Вырезать первое поле из файла, разделенного запятыми
cut -d',' -f1 file.csv

# Вырезать символы 1-5 с каждой строки
cut -c1-5 file
```

#### tr

```bash
# Преобразовать все символы в файле в верхний регистр
tr '[:lower:]' '[:upper:]' < file

# Преобразововать символы строки hello в верхний регистр
echo "hello" | tr '[:lower:]' '[:upper:]'
```

#### column

-

#### awk

Чаще всего используется для выборки из колонок.

```bash
# Вывести первый столбец из файла
awk '{print $1}' file

# Разделить строки с помощью разделителя : и вывести первый и третий столбцы
awk -F: '{print $1, $3}' /etc/passwd

# Вывод нечетных строк файла
cat file | awk 'NR%2==1'
```

#### sed

```bash
# Заменить первое вхождение old на new в каждой строке файла
sed 's/old/new/' file

# Вывод 5-10 строк из файла
sed -n '5,10p' file

# Удалить пустые строки файла
sed '/^$/d' file

# Удалить первую строку файла
sed -r '1d' file

# Удалить str из текста файла
sed -e 's/str//g' file

# Заменить последовательность нулей одним нулем
sed -e 's/0*/0/g' file
```

#### uniq

```bash
# Удалить дублирующиеся последовательные строки
uniq file

# Подсчитать количество каждой уникальной строки
uniq -c file
```

#### cat

```bash
# Вывод содрежимого файла на экран
cat file

# Объединение двух файлов в один
cat file1 file2 > file3
```

#### echo

```bash
# Вывод строки на экран
echo "Hello"

# Очистка файла, запись строки в файл
echo "Hello" > file

# Запись строки в конец файла
echo "Hello" >> file

# Вывод значение переменной окружения
echo $PATH
```

#### fmt

```bash
# Форматирование файла для вывода с максимальной шириной строки 80 символов
fmt -w 80 file
```

#### wc

```bash
# Посчитать количество строк в файле
wc -l file

# Посчитать количество слов в строке
echo "Hello, world!" | wc -w
```

### Working with files

#### cd

```bash
# Переход в предыдущую директорию
cd -

# Переход в домашнюю директорию текущего пользователя
cd ~

# Переход в указанную директорию
cd /path/to/file

# Переход в на уровень выше
cd ../
```

#### chmod

```bash
# Аналогично chmod 777 dir1. Выдать права ugo(User Group Other)+rwx(Read Write eXecute) на директорию dir1
chmod ugo+rwx dir1

# Забрать права у группы и всех остальных все права для директории dir1
chmod go-rmw dir1

# Назначить SUID-бит файлу file1. Дает возможность любому пользователю запускать на выполнение файл с полномочиями владельца файла
chmod u+s file1

# Назначить SGID-бит для файла file1
chmod g+s file1

# Снять SGID-бит для файла file1
chmod g-s file1

# Назначить STIKY-бит для файла file1. Позволяет удалять только владельцам
chmod o+t file1

# Снять STIKY-бит для файла file1
chmod o-t file1

# Рекурсивная установка прав для всех каталогов и файлов в каталоге dir
chmod -R 755 dir
```

#### chown

```bash
# Изменить владельца и группу файла file.txt
chown user:group file.txt

# Рекурсивное изменение владельца файлов и каталогов в каталоге dir
chown -R user:group dir/

# Изменить владельца файла file.txt на user
chown user file.txt
```

#### cp

```bash
# Скопировать файл file1 в файл file2
cp file1 file2

# Скопировать каталог dir в каталог dir2 рекурсивно
cp -r dir dir2
```

#### ls

- **-h**: Вывод размера файлов
- **-t**: Вывод списка файлов по дате создания

```bash
# Файлы и директории содержащие в имени цифры
ls *[0-9]*

# Детальная информация о файлах, каталогах и скрытых файлах в текущем каталоге
ls -la
```

#### mv

```bash
# Переименовать файл
mv file1 file2

# Переместить файл в каталог
mv file1 dir

# Переименовать каталог dir1
mv dir1 dir2
```

#### mkdir

```bash
# Создать две директории
mkdir dir1 dir2

# Создать каталог и все промежуточные каталоги
mkdir -p /tmp/dir1/dir2
```

#### rm

- **-v**: Вывод информаци об удаляемых файлах
- **-r**: Удалить каталог и его содержимое рекурсивно
- **-f**: Удалить каталог и его содержимое рекурсивно принудительно

```bash
# Удалить файл
rm file
```

#### touch

```bash
# Создать файл
touch file

# Изменить дату и время создания файла, при отсутствии создать файл с такой датой и временем
touch -t 2412315900 file
```

### Process Management

#### top

Являясь эквивалентом диспетчера задач в Windows, команда top выводит список запущенных процессов, а также информацию о том, сколько ЦП использует каждый процесс. Отслеживать использование системных ресурсов очень полезно. Таким образом, вы сможете определить какой процесс необходимо прекратить, поскольку он потребляет слишком много ресурсов.

```bash
# Вывод список процессов в реальном времени
top
```

#### htop

```bash
# Интерактивный мониторинг процессов
htop

# Интерактивный мониторинг процесс отсортированных по CPU
htop --sort-key=PERCENT_CPU

# Процессы конкретного пользователя
htop -u username
```

#### kill

```bash
# Завершить процесс по идентификатору процесса
kill PID

# Завершить процесс сигналом TERM
kill -TERM PID

# Завершить процесс сигналом KILL
kill -KILL PID
```

#### killall

```bash
# Завершить все процессы с определенным именем
killall process_name

# Завершить все процессы, принадлежащие определенному пользователю
killall -u username

# Завершить все процессы сигналом TERM
killall -TERM process_name
```

#### journalctl

-

#### systemctl

- `start <uмя.service>` -> Запускает сервис
- `stop <uмя.service>` -> Останавливает сервис
- `restart <uмя.service>` -> Перезапускает сервис
- `try-restart <uмя.service>` -> Перезапуск сервиса только, если он запущен
- `reload <uмя.service>` -> Перезагружает конфигурацию сервиса
- `status <uмя.service>` -> Отображает подробное состояние сервиса
- `is-active <uмя.service>` -> Отображает только строку active (сервис запущен) или inactive (остановлен)
- `list-units --type service --all` -> Выводит состояние всех сервисов
- `еnаblе <uмя.service>` -> Включает сервис (обеспечивает его автоматический запуск)
- `disaЬle <uмя.service>` -> Отключает сервис (сервис не будет автоматически запускаться при запуске системы)
- `rееnablе <uмя.service>` -> Деактивирует сервис и сразу его использует
- `list-unit-files --type service` -> Выводит список всех сервисов и сообщает, какие из них активированы, а какие - нет

### Performance monitoring

#### nmon

```bash
# Мониторинг ресурсов
nmon

# Сохранить данные в файл
nmon -f -s 10 -c 144

# Мониторинг дисков
nmon -d
```

#### iostat

Контролирует ввод/вывод системы, наблюдая за временем активности устройств в зависимости от их средней скорости передачи. Отчеты iostat используются для изменения конфигов системы, чтобы повысить баланс ввода/вывода между физическими дисками.

Если нужно узнать статистику по устройствам или процессору воспользуемся командой iostat -c 
%user — процент загрузки процессора программами, запущенными пользователем 
%system — использование процессора ядром системы 
%iowait — время затраченное на ожидание процессов ввода-вывода 
%steal — означает время, в течение которого процессор виртуальной машины должен ждать, пока другие виртуальные машины завершат свою очередь на выполнение (Time Slice), или для выполнения задачи самого гипервизора. 
%idle — процент времени пока процессор не занят ничем

```bash
# Статистика по использованию дисков
iostat

# Статистика по использованию процессора
iostat -c

# Статистика по сетевым интерфейсам
iostat -n
```

#### sar

```bash
# Статистика по использованию CPU
sar -u

# Статистика по использованию дисков
sar -d

# Статистика по использованию памяти
sar -r
```

#### vmstat

```bash
# Статистика использования памяти и процессора
vmstat

# Статистика по вводу/выводу
vmstat -d

# Статистика по памяти каждую секунду 5 раз
vmstat 1 5
```

### Network

#### traceroute

**Traceroute** - это утилита командной строки для отслеживания полного пути от вашей локальной системы к другой сетевой системе. Он печатает количество переходов (IP-адреса маршрутизатора) на этом пути, по которому вы путешествуете, чтобы добраться до конечного сервера. Это простая в использовании утилита для устранения неполадок сети после команды ping.

Команда traceroute может применяться для тестирования, администрирования и оценки значений параметров сети.

Команда ping позволяет убедиться, что удаленная сеть IP достижима. Однако с ее помощью нельзя обнаружить и устранить неполадки. 

Рассмотрим следующий пример:
- Если маршрут от системы к целевому хосту содержит много транзитных узлов (например, шлюзов и маршрутизаторов), то неполадка может возникнуть на любом из этих узлов. В этом случае нужно выяснить, на каком этапе теряется пакет
- Если пакет не удается доставить, команда **ping** не сообщает причину ошибки.

Команда traceroute позволяет узнать, где в данный момент находится пакет, и почему его нельзя доставить по заданному маршруту. Если пакет будет передаваться через маршрутизаторы и каналы связи, принадлежащие другим организациям, то вам вряд ли удастся проверить состояние этих маршрутизаторов с помощью команды telnet. В этом случае можно воспользоваться командами traceroute и ping.


> [!NOTE] Основные опции
> - 4 или -6 - использовать ipv4 или ipv6 протокол
> - I - использовать ICMP пакеты вместо UDP
> - T - использовать TCP пакеты вместо UDP
> - F - не фрагментировать пакеты
> - f - указать TTL с которого нужно начать
> - g - передавать пакет через указанный шлюз
> - i - передавать пакет через указанный интерфейс
> - m - максимальное количество узлов, через которые пройдет пакет
> - q - количество пакетов, отправляемых за раз, по умолчанию три
> - n - не узнавать доменные имена
> - p - указать порт вместо порта по умолчанию
> - w - установить время ожидания ответа от узла, по умолчанию полсекунды
> - r - использовать другой роутер вместо того, что указанный в таблице маршрутизации
> - z - минимальный интервал между пакетами
> - U - использовать UDP с увеличением номера порта
> - UL - использовать протокол UDPLITE
> - D - использовать протокол DCCP
> - –mtu - указать размер пакета
> - P - протокол, доступны такие значения: raw, dccp, udplite, udp, tcpconn, tcp, icmp

Команда **traceroute** применяет протокол UDP и функцию создания отчета об ошибках, предусмотренную в ICMP. Эта команда трижды отправляет пакет UDP каждому шлюзу или маршрутизатору, входящему в маршрут. Первый пакет отправляется ближайшему шлюзу. Второй пакет отправляется следующему за ним транзитному узлу и т.д. Последний пакет отправляется целевой системе. В выводе команды указывается имя шлюза, IP-адрес шлюза и время оборота трех пакетов, отправленных шлюзу.

Если маршрут проходит через сеть с коммутацией каналов (WAN), то при передаче первого пакета дополнительное время будет затрачено на установление соединения. В результате может произойти тайм-аут. Тайм-аут по умолчанию составляет 3 секунды. Его можно изменить с помощью опции -w.

> [!ERROR] Неполадки, возникающие при выполнении команды traceroute
> Если маршрут к целевому хосту включает большое число транзитных узлов или проходит через сети со сложной конфигурацией, то при вызове команды traceroute часто возникают различного рода ошибки. Поскольку многие аспекты работы команды зависят от ее реализации, во многих случаях невозможно найти причину ошибки. Однако если все маршрутизаторы и системы, через которые передается пакет, относятся к вашей организации, то вы можете проанализировать причину ошибки.
> 
> Если в течение 3 секунд от целевой системы не будет получен ответ, то для всех запросов возникает тайм-аут, и в выводе команды указывается звездочка. Если предположительно ошибка связана с каналом связи, то увеличьте значение тайм-аута с помощью флага `-w`. Кроме того, возможно, хотя и маловероятно, что все порты были заняты. Попробуйте изменить номера портов и повторите запрос.

```bash
# Маршрут сетевых пакетов до example.com
traceroute example.com

# Указание использовать IPv6
traceroute -6 example.com

# Предотвращение фрагментации пакетов
traceroute -F example.com

# Маршрут без изменения IP в имена
traceroute -n example.com

# Использовать указанный порт при трассировке маршрута
traceroute -p 80 example.com
```

#### route

**route** - это утилита командной строки для отображения или управления таблицей IP-маршрутизации системы Linux. В основном он используется для настройки статических маршрутов к определенным хостам или сетям через интерфейс.

```bash
# Отклонение сетевых пакетов для одного хоста
route add -host 192.168.1.0 reject

# Отклонение сетевых пакетов для всей сети
route add -net 192.168.1.0 netmask 255.255.255.0 reject
```

#### nmcli

**Nmcli** - это простой в использовании инструмент командной строки с поддержкой сценариев для сообщения о состоянии сети, управления сетевыми подключениями и управления NetworkManager.

```bash
# Просмотр всех сетевых устройств
nmcli dev status

# Проверка сетевых подключений в системе
nmcli con show

# Вывод активных соединений
nmcli con show -a
```

#### ping

**ping (Packet INternet Groper)** - это утилита, обычно используемая для проверки возможности соединения между двумя системами в сети (локальная сеть (LAN) или глобальная сеть (WAN)). Он использует ICMP (протокол управляющих сообщений Интернета) для связи с узлами в сети.

```bash
# Пинговать сайт
ping example.com

# Выполнить пинг 5 раз
ping -c 5 example.com

# Пинговать с интервалом 2 секунды
ping -i 2 example.com
```

#### mtr

**MTR** - это современный инструмент диагностики сети с командной строкой, который сочетает в себе функции ping и traceroute в едином диагностическом инструменте. Его вывод обновляется в реальном времени по умолчанию, пока вы не выйдете из программы, нажав q .

```bash
# Комбинация traceroute и ping для поиска более узких мест в маршрутах
mtr example.com

# Ограничение кол-ва проверок до определенного значения
mtr -T -c 5 example.com

# Результаты без изменения IP в имена
mtr -n example.com

# Использовать реверсивный DNS при отображении результатов
mtr -r example.com
```

#### ufw

```bash
# Статус брандмауэра
ufw status

# Включить брандмауэр
ufw enable

# Запретить доступ к 22 порту
ufw deny 22
```

#### iptables

**iptables** - это инструмент командной строки для настройки, обслуживания и проверки таблиц фильтрации IP-пакетов и набора правил NAT. Он использовался для настройки и управления брандмауэром Linux (Netfilter). Это позволяет вам перечислить существующие правила фильтрации пакетов; добавлять, удалять или изменять правила фильтрации пакетов; список счетчиков правил фильтрации пакетов.

Осуществляется на основе набора правил, которые определяются в таблицах. `nftables` имеет схожий функционал. Цепочки – последовательности правил, которые применяются к пакетам. Действия – решения, которые принимает брандмауэр на основе правил для пакета. Команды – инструкции к действию, которые позволяют добавлять, удалять, сбрасывать все правила, задавать действия по умолчанию.

```bash
# Показать текущие правила
iptables -L

# Вывод таблиц с нумерацией правил
iptables -L -v -n --line-numbers

# Удаление правила из таблицы filter под номером 3
iptables -t filter -D INPUT 3

# Блокировать исходящие HTTP-соединения
iptables -t filter -A OUTPUT -p tcp --dport http -j DROP

# Включить логирование ядром пакетов, проходящих через цепочку INPUT, и добавлением к сообщению префикса DROP INPUT
iptables -t filters -A INPUT -j LOG --log-prefix "DROP INPUT"

# Разрешить входящие соединения на порт 80
iptables -A INPUT -p tcp --dport 80 -j ACCEPT

# Запретить доступ к определенной подсети
iptables -A INPUT -s 0.0.0.0/24 -j DROP

# Ограничение скорости трафика к новым SSH-соединениям
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m limit --limit 3/min -j ACCEPT

# Логирование всех отброшенных пакетов
iptables -A INPUT -j LOG --log-prefix “Dropped Packet: “ iptables -A INPUT -j DROP
```

#### ssh

[**Ссылка**](materials/ssh.md)

#### scp

Использует шифрование через ssh соединение.

```bash
# Копирование файла на удаленный сервер
scp file user@example.com:/path

# Рекурсивное копирование каталога на удаленный сервер
scp -r folder/ user@example.com:/path

# Копирование файла с сервера на локалку
scp user@example.com:/path/file
```

### Troubleshooting

#### hping3

**hping3** - это инструмент для работы с сетевым трафиком и тестирования сетевых соединений в среде Unix-подобных систем. Он позволяет отправлять и принимать сетевые пакеты различных типов, включая ICMP, TCP и UDP, и анализировать ответы от удаленных хостов.

```bash
# Традиционный пинг
hping3 -1 127.0.0.1

# SYN-флуд-атака
hping3 --flood -S -p 80 127.0.0.1

# UDP сканирование первых 100 портов
hping3 --udp -p 1-100 127.0.0.1
```
- Примеры использования
```bash
hping3 -c 100 -i u10000 --icmp 192.168.0.1
```
- Создание нагрузки на сеть с помощью ICMP флуда. Основной задачей является оценка сетевой доступности сервера и измерение задержки (RTT) с использованием утилиты hping3, отправляя ICMP-пакеты с большой интервальной задержкой
```bash
hping3 -c 10000 --icmp --flood --rand-source 192.168.0.1
```
- Перегрузка сетевого адаптера с фрагментированными ICMP-пакетами. Главной задачей является оценка того, как целевой сервер справляется с обработкой большого количества ICMP-пакетов, поступающих от разных источников. Это позволяет определить устойчивость сервера к потенциальным атакам сетевого флуда и идентифицировать возможные уязвимости
```bash
hping3 -c 4 -S -p 22 192.168.0.1
```
- Проверка доступности порта на сервере. Основной задачей является проверка возможности установки соединения с SSH-сервисом на указанном порту и анализ ответа, который сервер отправит на отправленные TCP-пакеты

#### memdump

-

#### masscan

-

#### arp

-

#### curl

cURL — это инструмент, который позволяет передавать файлы из оболочки по таким протоколам, как HTTP, HTTPS, FTP, SFTP, FTPS или SCP. Этот инструмент дает нам возможность удаленно контролировать и тестировать веб-сайты. Помимо содержимого удаленных серверов, мы также можем просматривать отдельные запросы, чтобы следить за взаимодействием клиента и сервера. Обычно cURL уже установлен в большинстве систем Linux.

```
curl -X POST -d “data=sample” https://example.com (Пример POST запроса)

curl -Iv https://example.com (Проверка конфига SSL/TLS)

curl -H “Cookie: session=12345” https://example.com (Отправка cookie)
```

### Backup and Restore

#### rsync

Быстрое и безопасное создание резервных копий файлов и папок в удаленном месте. Это особенно полезно для передачи больших объемов данных по сети, поскольку передаются только измененные части файла. Его также можно использовать для создания резервных копий локально или на удаленных серверах. Если нужно выполнить резервное копирование больших объемов данных по сети, Rsync может оказаться лучшим вариантом.

Чтобы включить автоматическую синхронизацию с помощью rsync, можно использовать комбинацию cron и rsync для автоматизации процесса синхронизации. Планирование запуска задания cron через регулярные промежутки времени гарантирует синхронизацию содержимого двух систем. Это может быть особенно полезно для организаций, которым необходимо синхронизировать данные на нескольких машинах.

Создание резервной копии локального каталога в резервной копии. Эта команда скопирует весь каталог (/path/to/mydirectory) на удаленный хост (backup_server) в каталог /path/to/backup/directory. Параметр archive (-a) используется для сохранения исходных атрибутов файла, таких как разрешения, временные метки и т. д., а использование подробного параметра (-v) обеспечивает подробный вывод хода операции rsync.

```bash
rsync -av /path/to/mydirectory user@backup_server:/path/to/backup/directory
```

В этом примере мы создаем резервную копию mydirectory на удаленном сервере backup_server, сохраняя исходные атрибуты файла, временные метки и разрешения, а также включаем сжатие (-z) для более быстрой передачи. Параметр --backup создает инкрементальные резервные копии в каталоге /path/to/backup/folder, а параметр --delete удаляет файлы с удаленного хоста, которых больше нет в исходном каталоге.

```bash
rsync -avz --backup --backup-dir=/path/to/backup/folder --delete /path/to/mydirectory user@backup_server:/path/to/backup/directory
```

Восстановление каталога с сервера резервного копирования в локальный каталог. Передача данных между локальным хостом и резервным сервером происходит через зашифрованное соединение SSH, что обеспечивает конфиденциальность и защиту целостности передаваемых данных. Этот процесс шифрования гарантирует, что данные защищены от любых потенциальных злоумышленников, которые в противном случае могли бы получить доступ к данным и изменить их без разрешения. Сам ключ шифрования также защищен комплексным набором протоколов безопасности, что еще больше затрудняет доступ к данным неавторизованному лицу.

```bash
rsync -av user@remote_host:/path/to/backup/directory /path/to/mydirectory
```

Безопасная передача резервной копии

```bash
rsync -avz -e ssh /path/to/mydirectory user@backup_server:/path/to/backup/directory
```

#### Deja Dup

Графический инструмент резервного копирования, который упрощает процесс резервного копирования, позволяя быстро и легко создавать резервные копии данных. Он предоставляет удобный интерфейс для создания резервных копий данных на локальном или удаленном носителе. Он использует Rsync в качестве бэкэнда, а также поддерживает шифрование данных.

#### duplicity

Графический инструмент резервного копирования, который обеспечивает пользователям комплексную защиту данных и безопасное резервное копирование. Он также использует Rsync в качестве бэкэнда и дополнительно предлагает возможность шифровать резервные копии и хранить их на удаленных носителях, таких как FTP-серверы, или в облачных службах хранения, таких как Amazon S3.

## Practice

### Practice_1

Практика утилит фильтрации текста. Практика выполняется с файлом `/etc/passwd`. Вывести содержимое файла и фильтровать:
	- Строки с именем пользователя root;
	- Столбец с именами пользователей;
	- Имя пользователя root и его UID;
	- Имя пользователя root и его UID, разделенные запятыми;
	- Имя пользователя root, установленная CLI и его UID, разделенные запятыми;
	- Все имена пользователей, их UID и CLi, разделенные запятыми;
	- Все имена пользователей, их UID и CLi, разделенные запятыми, кроме тех, что содержат nologin или false;
	- Все имена пользователей, их UID и CLi, разделенные запятыми, кроме тех, что содержат nologin, и подсчитать количество строк.

### Practice_2

```bash
vimtutor
```
- Запустить в терминале
