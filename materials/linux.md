# Linux

## Contents

- [Linux](#linux)
    - [Contents](#contents)
    - [Introduction](#introduction)
    - [Distros](#distros)
	    - [**Ubuntu**](#ubuntu): Пользовательский дистрибутив с широким сообществом, удобный для новичков
	    - [**Debian**](#debian): Стабильность и безопасность, часто используется на серверах
	    - [**Fedora**](#fedora): Современные технологии и новейшее ПО, идеален для разработчиков
	    - [**CentOS**](#centos): Корпоративный уровень стабильности, широко используется на серверах
	    - [**Kali**](#kali): Дистрибутив для тестирования на проникновение и информационной безопасности
	    - [**ParrotOS**](#parrotos): Дистрибутив для тестирования на проникновение, безопасности и цифровой криминалистики. Также включает инструменты для анонимности и защиты данных
	    - [**BlackArch**](#blackarch): Расширение для Arch Linux, предназначенное для тестирования на проникновение. Включает огромное количество инструментов для проведения всестороннего анализа безопасности
    - [Components](#components)
    - [Boot](#boot)
	    - [Stages](#stages)
    - [Architecture](#architecture)
    - [File System](#file-system)
        - [File System Management](#file-system-management)
        - [Linux file system](#linux-file-system)
        - [Disk Management](#disk-management)
        - [SWAP](#swap)
    - [Terminal Hotkeys](#terminal-hotkeys)
    - [File descriptor and redirections](#file-descriptor-and-redirections)
    - [Permission Management](#permission-management)
        - [SUID & SGID](#suid--sgid)
        - [Sticky Bit](#sticky-bit)
    - [Service and Process Management](#service-and-process-management)
        - [Background processes](#background-processes)
        - [Executing multiple commands](#executing-multiple-commands)
    - [Task Scheduling](#task-scheduling)
        - [systemd](#systemd)
        - [CRON](#cron)
            - [Operators](#operators)
            - [Special lines](#special-lines)
            - [Usage](#usage)
    - [PTY](#pty)
    - [Bonding](#bonding)
    - [CLI](#cli)
        - System Information
            - [__whoami__](#whoami): Имя текущего пользователя
            - [__id__](#id): Членство пользователя в группах
            - [__hostname__](#hostname): Устанавливает или печатает имя текущего хоста
            - [__uname__](#uname): Основная информация об ОС и системном оборудовании
            - [__pwd__](#pwd): Рабочая директория
            - [__ifconfig__](#ifconfig): Устанавливает или печатает адреса сетевых интерфейсов, настройка параметров сетевых интерфейсов
            - [__ip__](#ip): Отображение и управление маршрутизацией, сетевыми устройствами, интерфейсами, туннелями
            - [**ethtool**](#ethtool): Работа с сетевыми картами
            - [**netplan**](#netplan): Управление конфигурацией сети
            - [__netstat__](#netstat): Сетевые подключения, таблицы маршрутизации, статистика сетевого интерфейса
            - [__ss__](#ss): Исследование сокетов
            - [__ps__](#ps): Активные процессы
            - [__who__](#who): Кто вошел в систему
            - [__env__](#env): Устанавливает или печатает переменные среды
            - [__lsblk__](#lsblk): Список блочных устройств
            - [__lsusb__](#lsusb): Список USB устройств
            - [__lsof__](#lsof): Список открытых файлов
            - [__lspci__](#lspci): Список PCI устройств
            - [**jobs**](#jobs): Все процессы, запущенные в фоновом режиме, вместе с их статусами
        - User Management
            - [__sudo__](#sudo): Выполнение команды от имени другого пользователя
            - [__passwd__](#passwd): Смена пароля пользователя
            - [__useradd__](#useradd): Создание пользователя
            - [__userdel__](#userdel): Удаление пользователя
            - [__usermod__](#usermod): Изменение пользователя
            - [__groupadd__](#groupadd): Создание группы
            - [__groupdel__](#groupdel): Удаление группы
            - [__groupmod__](#groupmod): Изменение настроек группы
        - Package Management
            - [__apt__](#apt): Высокоуровневый интерфейс командной строки для системы управления пакетами
            - [__pip__](#pip): Управление Python-пакетами
            - [__git__](#git): Система контроля версий
            - [__dpkg__](#dpkg): Работа с DEB-пакетами
        - Basic
            - [__date__](#date): Системная дата
            - [__df__](#df): Информация об использовании дискового пространства
            - [__du__](#du): Определение объема файлов в директории
            - [__export__](#export): Экспорт переменных среды
            - [__find__](#find): Поиск файлов и директорий по фильтрам
            - [__free__](#free): Информация об оперативной памяти
            - [__gunzip__](#gunzip): Распаковка gzip архивов
            - [__gzip__](#gzip): Сжатие файлов алгоритмом LZ77
            - [__history__](#history): История введенных команд
            - [__locate__](#locate): Поиск файлов и папок
            - [__man__](#man): Справочная информация нужной команды
            - [__mount__](#mount): Монтирование файловой системы
            - [__reboot__](#reboot): Перезагрузка системы
            - [__service__](#service): Управление работой сервисов
            - [__shutdown__](#shutdown): Остановка системы
            - [__tar__](#tar): Сжатие и распаковка файлов
            - [__uptime__](#uptime): Время работы в системы
            - [__w__](#w): Список активных пользователей с момента запуска ОС
            - [__wget__](#wget): Прямая загрузка файлов через Интернет
            - [__whatis__](#whatis): Краткое описание искомой команды
            - [__which__](#which): Поиск расположения исполняемого файла
            - [__zip__](#zip): zip упаковка файлов
        - Filter Contents
            - [__head__](#head): Первые строки файла
            - [__less__](#less): Постраничный просмотр файлов
            - [__more__](#more): Постраничный просмотр файлов
            - [__tail__](#tail): Последние строки файла
            - [__sort__](#sort): Сортировка строк файлов
            - [__grep__](#grep): Поиск и фильтрация текста
            - [__cut__](#cut): Вырезание разделов из каждой строки файлов
            - [__tr__](#tr): Перевод или удаление символов
            - [__column__](#column): Отображение в табличной форме
            - [__awk__](#awk): Поиск, обработка и фильтрация текста в файлах
            - [__sed__](#sed): Фильтрация и преобразование текста
            - [__uniq__](#uniq): Исключение повторяющихся строк
            - [__cat__](#cat): Объединение файлов, отображение содержимого файла
            - [__echo__](#echo): Отображение строки текста
            - [__fmt__](#fmt): Простое оптимальное форматирование текста
            - [__wc__](#wc): Подсчет количества символов новой строки, слов и байт
        - Working with files
            - [__cd__](#cd): Изменение рабочей директории
            - [__chmod__](#chmod): Управление правами доступа
            - [__chown__](#chown): Управление владением
            - [__cp__](#cp): Копирование файлов и каталогов
            - [__ls__](#ls): Вывод содержимого директории
            - [__mv__](#mv): Перемещение или переименование файлов
            - [__mkdir__](#mkdir): Создание директории
            - [__rm__](#rm): Удаление файлов или директорий
            - [__touch__](#touch): Создание файлов
        - Process Management
            - [__top__](#top): Отсортированный список текущих системных процессов
            - [__htop__](#htop): Интерактивный просмотр процессов
            - [__kill__](#kill): Уничтожение активного процесса
            - [__killall__](#killall): Уничтожение всех процессов, соответствующих заданным параметрам
            - [__journalctl__](#journalctl): Журнал сообщений
            - [__systemctl__](#systemctl): Управление службами
        - Performance monitoring
            - [__nmon__](#nmon): Мониторинг производительности процессора, памяти, сети, дисков, файловой системы, ресурсов, микро раздела питания
            - [__iostat__](#iostat): Мониторинг статистики ввода-вывода системы для устройств и разделов
            - [__sar__](#sar): Генератор отчета с различной информацией об использовании и активности ресурсов в ОС
            - [__vmstat__](#vmstat): Статистика виртуальной памяти
        - Network
            - [__traceroute__](#traceroute): Отображает пути, пройденные пакетами по IP-сети
            - [__ping__](#ping): Проверка доступности сетевого хоста
            - [__mtr__](#mtr): Инструмент, который объединяет возможности `traceroute` и `ping`
            - [__ufw__](#ufw): Управление брандмауэром
            - [__iptables__](#iptables): Управление входящими и исходящими пакетами данных
            - [__tcpdump__](#tcpdump): Перехвата трафика, мониторинг сетевой активности
            - [__ssh__](#ssh): SSH консоль
            - [__dig__](#dig): Получение ценной информации о доменах, IP-адресах, DNS-записях
            - [__scp__](#scp): Безопасное копирование файлов и каталогов между двумя системами
            - [__nmap__](#nmap): Сканирует открытые порты, запущенные службы и выявляет уязвимости
        - Troubleshooting
            - [__hping__](#hping): Инструмент для создания пакетов, который позволяет манипулировать и анализировать сетевые пакеты на детальном уровне. Используется для стресс-тестирования, тестирования брандмауэра, сканирования и генерации пакетов
            - [**memdump**](#memdump): Инструмент для криминалистического анализа системной памяти. Извлекает ценную информацию из оперативной памяти компьютера во время инцидента или расследования
            - [**nslookup**](#nslookup): Инструмент для запроса серверов системы доменных имен (DNS) для получения информации о хосте или разрешения IP-адреса
            - [**masscan**](#masscan): Инструмент для сканирования портов. Способен сканировать весь Интернет за несколько минут
            - [**arp**](#arp): Инструмент для отображения ARP таблицы
            - [__curl__](#curl): Инструмент, который передает данные с использованием различных сетевых протоколов. Используется для тестирования и взаимодействия с веб-сервисами, API-интерфейсами
            - [__dd__](#dd): Инструмент для дублирования данных и криминалистической визуализации, который используется для обнаружения доказательств и сохранения цифровых данных для восстановления временных рамок событий. Используется для создания точной копии диска или файла, получения удаленных файлов из образа диска
        - Backup and Restore
            - [__rsync__](#rsync): Быстрое и безопасное создавание резервных копий файлов и папок в удаленном месте
            - [__Deja Dup__](#deja-dup): Графический инструмент резервного копирования на основе rsync
            - [__Duplicity__](#duplicity): Графический инструмент резервного копирования на основе rsync
    - Labs
        - [Practice_1](#practice_1)
        - [Practice_2](#practice_2)
        - [Lab 1](materials/labs/linux_labs/lab_1)
        - [Lab 2](materials/labs/linux_labs/lab_2)
        - [Lab 3](materials/labs/linux_labs/lab_3)
        - [Lab 4](materials/labs/linux_labs/lab_4)

## Introduction

- Все есть файл
- Содержит множество небольших программ
- Возможность объединения программ для выполнения сложных задач
- Не привязан к GUI
- Данные конфигураций хранятся в текстовых файлах

## Distros

**Дистрибутив Linux** - установочный пакет для развертывания ОС, состоящей из ядра Linux, утилит GNU, дополнительного ПО и диспетчера пакетов. Он также может включать пакет для установки дисплейного сервера и развертывания среды рабочего стола. Таким образом, Linux - ядро ОС, а дистрибутив Linux - установочный пакет какой-то из разновидностей этой ОС + доп. компоненты. Такие разновидности называют ОС на базе Linux. Дистрибутивы Linux используются в серверах, встроенных устройствах, настольных ПК, мобильных устройствах, облачных вычислениях

Распространенные дистрибутивы в кибербезопасности: ParrotOS, Raspberry Pi OS, BlackArch, Ubuntu, CentOS, Pentoo, Debian, Backbox. Распространенные дистрибутивы: Ubuntu, Fedora, CentOS, Red Hat, Debian. 

### Ubuntu

- Основан на Debian и существует с 2004 года
- Есть версия для настольных компьютеров и серверов
- Большое комьюнити
- Лучший дистрибутив для домашнего использования и рабочих станций
- Имеет фиксированный график релизов: LTS выходит раз в два года в апреле и поддерживается 5 лет, а обычные версии выходят раз в пол года и поддерживаются 9 месяцев
- Почти все основные действия по настройке могут выполняться в графическом режиме
- Релиз имеет числовое обозначение вида ГОД.МЕСЯЦ.ВЕРСИЯ выхода релиза
- Среда рабочего стола: Unity
- Формат пакетов DEB

### Debian

- Open-source
- Создан и развивается только сообществом с 1995 года
- Новые версии выходят раз в два года и поддерживаются 5 лет
- Больше подходит для серверов
- Среда рабочего стола: GNOME, KDE Plasma, LXQt, MATE, Cinnamon, Xfce
- Формат пакетов DEB

### Fedora

- Поддерживает Red Hat
- Выход новых версий каждые 6-8 месяцев и поддерживается 13 месяцев
- Формат пакетов RPM
- Есть версии для настольных компьютеров, IoT, серверов, области обработки облачных вычислений
- Среда рабочего стола: Gnome

### CentOS

- Бесплатный аналог коммерческого Red Hat
- Создан и развивается только сообществом
- Надежное решение для серверов
- Выход новых версий раз в пол года и поддерживаются 10 лет
- Меньше руководств и документации по сравнению с Ubuntu
- Среда рабочего стола: GNOME
- Формат пакетов RPM

### Kali

- Дистрибутив для проведения тестирования на проникновение и аудита безопасности
- Основан на Debian
- Среда рабочего стола: GNOME 3
- Содержит много предустановленных утилит для проведения тестов, поиска уязвимостей, анализа данных, сниффинга, спуфинга, взлома сетей и систем
- Поддерживаются платформы 32-bit x86, 64-bit x86, ARM
- Может запускаться на Raspberry Pi, Odroid, Cubox, Beaglebone, Samsung Chromebook

### ParrotOS

- Основан на Debian
- Предназначен для тестирования системы на проникновение, оценки уязвимостей и ликвидации из последствий, компьютерной криминалистики и анонимного просмотра веб-страниц
- Среда рабочего стола: MATE
- Содержит готовый набор инструментов для разработки приложений, различные фреймворки, библиотеки, компиляторы, дизассемблеры, IDE, редакторы кода, криптографическое ПО (Для защиты данных)
- Всю систему можно установить в полностью зашифрованных раздел на диске
- AnonSurf позволяет запускать TOR и пропускать весь интернет трафик через TOR
- Есть возможность использовать DNS-сервера, отличные от тех, которые предоставлены провайдером
- Еще один пример использования Parrot Linux в качестве мониторинга уязвимостей - сканер уязвимостей виртуальной телефонной станции “Rtpflood”. Простой, но в то же время мощный инструмент для перебора корпоративной директории VoIP, который имитирует поведение IP телефона чтобы загрузить имя и расширенные записи, которые данный телефон может отобразить на своём экране

### BlackArch

- Предназначен для проведения тестирования на проникновение
- Спонсор разработки NullSecurity
- Понимает только оконные менеджеры (OpenBox, i3, Fluxbox)
- Быстрая, стабильная и плавная система

## Components

- __Bootloader__: Загрузчик управляет процессом загрузки ОС (Например, GRUB);
- __OS Kernel__: Код ядра управляет ресурсами системных устройств ввода-вывода на аппаратном уровне;
- __Daemons__: Фоновые службы обеспечивают правильную работу функций (Например, печать, планирование, мультимедиа);
- __OS Shell__: Интерфейс между пользователем и ОС (Например, Bash, Tcsh/Csh, Ksh, Zsh, Fish);
- __Graphics server__: Обеспечивает графическую подсистему X-server, которая позволяет графическим программам запускаться локально или удаленно в системе X-windowing;
- __Window manager__: GUI позволяет пользователю получать доступ к основным функциям и службам ОС (Например, GNOME, KDE, Mate, Unity, Cinnamon);
- __Utilities__: Программы выполняют определенные функции для пользователей или других программ.

## Boot

![](unix__boot.png)
- Шаги загрузки Linux

- Под начальной загрузкой подразумевается самозапуск компьютера при включении питания. Поскольку средства операционной системы на данном этапе недоступны, компьютер должен в буквальном смысле «обслужить себя сам». Процесс включает загрузку системного ядра в память и его последующую активизацию. Затем выполняется ряд инициализационных задач, после чего система готова к обслуживанию пользователей
- Начальная загрузка – это период особой уязвимости в жизни системы. Ошибки в конфигурационных файлах, сбои в работе оборудования, повреждения файловых систем могут помешать компьютеру нормально начать работу. Настройка режимов загрузки во многих случаях является одной из первых задач, которую приходится решать администратору в новой системе
- Когда происходит включение питания, запускается на выполнение загрузочный код, хранящийся в ПЗУ. В его обязанность входит запуск ядра. Ядро опрашивает состояние оборудования, а затем запускает системный процесс init, идентификатор которого всегда равен 1
- Прежде чем на экране появляется регистрационное приглашение, происходит целый ряд событий. Файловые системы должны быть проверены и смонтированы, а системные демоны – запущены. Соответствующие процедуры реализуются с помощью сценариев интерпретатора shell, которые один за другим запускаются процессом init
- Стартовые сценарии часто называют rc-файлами, поскольку они имеют префикс rc. Он расшифровывается как run command– «команда запуска» - и является пережитком, доставшимся UNIX в наследство от операционной системы CTSS. Конкретная структура стартовых сценариев и способ их выполнения зависят от системы

В наиболее общем смысле запуск ОС UNIX и загрузка - это упорядоченный метод выполнения предопределенного набора задач. К таким задачам обычно относятся:
- Выполнение ограниченной процедуры самотестирования основных компонентов машины
- Обнаружение загрузочного устройства
- Считывание ядра системы с загрузочного устройства
- Использование ядра для обнаружения и инициализации периферийного оборудования
- Запуск основных задач системы
- Выполнение сценариев, которые запускают программы для предоставления сервиса
- Выполнение других приложений

- При нормальной работе системы сами выполняют начальную загрузку в автономном режиме, после чего к ним могут получить удаленный доступ администраторы и пользователи. Однако администраторам необходимо иметь инструмент восстановления системы в случае, если неожиданный отказ дисковода или какая-нибудь проблема конфигурации помешает системе нормально выполнить процесс начальной загрузки
- Системы UNIX (вместо загрузки “по полной программе”) могут ограничиться только самым необходимым, а именно активизацией командной оболочки на системной консоли. Этот вариант называют входом системы в так называемый “однопользовательский режим”, режим восстановления или профилактический режим — все эти термины взаимозаменяемы. Однопользовательский режим не позволяет выполнять сетевые операции, а для использования системной консоли вам нужно иметь физический доступ к ней
- В большинстве систем для входа в однопользовательский режим во время начальной загрузки необходимо передать ядру в командной строке определенный параметр. Если система уже загружена и работает, вы можете перевести ее в однопользовательский режим с помощью команды shutdown или telinit

### Stages

Типичная процедура начальной загрузки состоит из шести отдельных этапов:
- Считывание начального загрузчика с главной загрузочной записи
- Загрузка и инициализация ядра
- Обнаружение и конфигурирование устройств
- Создание процессов ядра
- Вмешательство администратора (только в однопользовательском режиме)
- Выполнение системных сценариев запуска
- Завершение процесса загрузки

**Инициализация ядра**

Ядро UNIX само по себе является программой, и первый этап начальной загрузки заключается в считывании этой программы в память для последующего выполнения. Имя файла ядра определяется разработчиком конкретной системы, но традиционное его название `/unix` или `/vmunix`. В настоящее время разработчики не придерживаются строго этого соглашения.

В большинстве систем загрузка ядра осуществляется в два этапа. Сначала в память машины с диска или магнитной ленты считывается (с помощью кода, записанного в ПЗУ) небольшая программа начальной загрузки, которая затем выполняет собственно загрузку ядра. Весь процесс происходит еще вне UNIX, поэтому в разных системах он реализован по-разному.

Ядро выполняет тестовые программы, позволяющие определить, сколько памяти имеется в наличии. Большинство внутренних структур ядра обладают фиксированным размером, поэтому ядро точно знает, сколько памяти нужно зарезервировать для самого себя. Эта память будет недоступной пользовательским процессам. В большинстве систем ядро выдает на консоль сообщение об общем объеме физической памяти и объеме памяти, не занятой ядром.

**Конфигурирование аппаратных средств**

Одна из первых задач, стоящих перед ядром, – выявление компонентов аппаратного обеспечения. Создавая ядро для своей системы, вы можете указать, какие устройства оно должно проверять. Когда ядро начинает выполняться, оно пытается найти и инициализировать все устройства, о которых ему было сообщено. Большинство ядер выводят на консоль краткую информацию о каждом обнаруженном устройстве.

Информация об устройствах, задаваемая при конфигурировании ядра, зачастую является неполной. В таких случаях ядро пытается получить необходимые сведения, опрашивая системную шину на предмет наличия устройств и запрашивая нужную информацию у соответствующих драйверов. Драйверы отсутствующих или не отвечающих на контрольный сигнал устройств отключаются. Даже если позже устройство подключить к системе, оно будет недоступно для UNIX-процессов до тех пор, пока вы не перезагрузите машину.

**Создание процессов ядра**

После завершения этапа базовой инициализации ядро создает в области памяти, выделенной для пользовательских программ, несколько «самовыполняющихся» процессов. Это происходит «в обход» стандартного системного механизма fork.

Количество таких процессов зависит от операционной системы, хотя демон init всегда имеет идентификатор процесса (PID), равный 1. Большинство систем UNIX использует sched в качестве процесса с идентификатором 0. В Linux процесс с идентификатором PID, равным 0, отсутствует.

Демон init работает в сопровождении с различными обработчиками памяти и сигналов ядра. Все эти процессы имеют идентификаторы с низкими номерами, а их имена в листингах команды ps заключены в квадратные скобки (например, `kacpid`). Иногда имена процессов могут содержать в конце символ косой черты и цифру, как, например, `kblockd/0`.

Частые процессы ядра в Linux-системах:
- **kjournald**: Записывает обновления журнала на диска
- **kswapd**: Выполняет подкачку процессов при недостаточном объеме физической памяти
- **ksoftirqd**: Обрабатывает мягкие прерывания, если ими нельзя заняться во время переключения контекста
- **khubd**: Выполняет конфигурирование USB-устройств

Для каждой смонтированной файловой системы ext3 или ext4 существует один процесс kjoumald.

Из этих процессов только init является полноценным пользовательским процессом; остальные фактически представляют собой части ядра, которые были сделаны процессами из концептуальных соображений.

После создания этих процессов ядро больше не принимает участия в процедуре начальной загрузки системы. К этому моменту, однако, еще не создан ни один из процессов, управляющих базовыми операциями (например, регистрацией пользователей в системе), и большинство демонов не запущено. Обо всем этом позаботится (в некоторых случаях косвенно) демон init.

**Действия оператора (только в режиме восстановления)**

Если систему нужно запустить в режиме восстановления, оператор устанавливает в командной строке специальный флаг, а ядро передает эту информацию демону init в качестве уведомления о запуске.

Во время однопользовательской загрузки вы должны получить приглашение ввести пароль пользователя root. Если он введен правильно, запускается интерпретатор команд с правами суперпользователя. Можно не задавать пароль, а просто нажать комбинацию клавиш `Ctrl+D`, после чего загрузка продолжится в многопользовательском режиме.

В однопользовательском режиме команды выполняются почти так же, как и в полностью загруженной системе. Однако иногда монтируется только корневой раздел. Для того чтобы можно было использовать программы, находящиеся вне каталогов `/bin`, `/sbin` или `/etc`, необходимо вручную смонтировать остальные файловые системы.

Во многих однопользовательских средах корневой каталог файловой системы монтируется в режиме только для чтения. Если каталог `/etc` является частью корневой файловой системы (обычная ситуация), редактирование многих файлов конфигурации будет невозможно. Чтобы выйти из положения, придется начать однопользовательский сеанс с повторного монтирования каталога / в режиме чтения/записи. Нужное действие в Linux-системах выполняет следующая команда: `mount -о rw, remount /`

В большинстве других систем вы можете выполнить команду `mount /`, чтобы реализовать обращение к файлу fstab или vfstab и выяснить, как должна быть смонтирована файловая система.

Команда fsck, которая проверяет и восстанавливает поврежденные файловые системы, обычно выполняется в ходе автоматической загрузки. Если система запускается в однопользовательском режиме, команду `fsck` придется вводить вручную.

Когда интерпретатор команд однопользовательского режима завершит свою работу, система продолжит загрузку в нормальном режиме.

**Выполнение сценариев запуска системы**

В тот момент, когда система сможет выполнять сценарии запуска, ее уже можно назвать UNIX. Это еще не полностью загруженная система, но «загадочных» этапов процесса загрузки больше не осталось. Файлы сценариев представляют собой обычные командные файлы, которые выбираются и запускаются демоном init по сложному, но, в общем-то, понятному алгоритму.

Точное местонахождение, содержимое и организация сценариев запуска заслуживают отдельного изучения.

**Завершение процесса загрузки**

После выполнения сценариев инициализации система полностью готова к работе. Такие системные демоны, как DNS и SMTP-серверы, принимают и обслуживают подключения. Не забывайте о том, что демон `init` продолжает играть важную роль даже по завершении начальной загрузки.

У демона `init` есть один однопользовательский и несколько многопользовательских «уровней выполнения», определяющих, какие ресурсы системы будут доступны пользователю.

## Architecture

- __Hardware__: Аппаратное обеспечение, периферийные устройства (Например, CPU, RAM, жесткий диск);
- __Kernel__: Ядро предоставляет каждому процессу собственные виртуальные ресурсы и предотвращает конфликты между различными процессами;
- __Shell__: Интерфейс командной строки (Command-line interface, CLI) позволяет пользователю вводить команды для выполнения функций ядра;
- __System utility__: Предоставляет пользователю все функциональные возможности ОС.

## File System

### File System Management

- Управление файловой системой - процесс создания и поддержки хранилищ данных на диске или других устройствах хранения данных. Линукс поддерживает различные файловые системы (ext2, ext3, ext4, XFS, Btrfs, NTFS), которые используются в различных ситуациях в зависимости от требований приложения или пользователя.
- Файловая система Линукс основана на файловой системе Unix, которая представляет собой иерархическую структуру, состоящую из различных компонентов. Наверху этой структуры находится таблица inode, основа всей файловой системы. Таблица inode — это таблица информации, связанной с каждым файлом и каталогом в системе Линукс. inodes содержат метаданные о файле или каталоге, такие как его разрешения, размер, тип, владелец и т. д. Таблица inode похожа на БД с информацией о каждом файле и каталоге в системе Линукс, что позволяет ОС быстро получать доступ к файлам и управлять ими. Файлы могут храниться в файловой системе Линукс одним из двух способов: файлы, каталоги и ссылки на другие файлы/каталоги. Каталоги используются для хранения набора файлов. Символические ссылки используются для быстрого доступа к файлам, расположенным в разных частях файловой системы. 

### Linux file system

- __/__: Директория верхнего уровня является корневой файловой системой и содержит все файлы, необходимые для загрузки ОС до монтирования других файловых систем, а также файлы, необходимые для загрузки других файловых систем. После загрузки все остальные файловые системы монтируются в стандартные точки монтирования как подкатологи корня
- __/bin__: Двоичные файлы многих основных программ, которые должны присутствовать при монтировании системы (Например, cat, ls cp)
- __/sbin__: Исполняемые файлы, используемые для системного администрирования
- __/boot__: Файлы для загрузки системы (Статический загрузчик, исполняемый файл ядра и файлы, необходимые для загрузки ОС)
- __/dev__: Файлы устройств для облегчения доступа к каждому аппаратному устройству, подключенному к системе
- __/etc__: Файлы конфигурации локальной системы и установленных приложений (Например, файл паролей или файлы настроек сетей)
- __/home__: Домашний каталог пользователей
- __/lib__: Файлы библиотек, необходимые двоичным файлам в каталогах bin, sbin для загрузки системы
- __/media__: Место монитрования внешних съемных носителей (Например, USB drives)
- __/mnt__: Временная точка монтирования для обычных файловых систем. Используется администратором системы для ручного монтирования файловых систем
- __/opt__: Используется проприентарным ПО для хранения дополнительных пакетов ПО
- __/proc__: Автоматически сгенерированные файлы системы, которые содержат информацию о запущенных процессах и состоянии ядра
	- __/proc/cpuinfo__: Информация о процессоре
	- __/proc/interrupts__: Информация о прерываниях
	- __/proc/swaps__: Информация о файлах подкачки
	- __/proc/version__: Информация о версии ядра
	- __/proc/meminfo__: Информация об использовании памяти
	- __/proc/netdev__: Информация о сетевых интерфейсах и их статистики
	- __/proc/mounts__: Информация о смонтированных файловых системах
- __/root__: Домашняя директория для пользователя root
- __/run__: Данные программ во время выполнения (Например, сокеты, ID процессов)
- __/srv__: Специфичные данные, обслуживаемые этой системой (Например, файлы Apache)
- __/sys__: Виртуальный диалог, представляющий информацию о системе
- __/tmp__: Временные файлы, которые удаляются при перезагрузке системы
- __/usr__: Исполняемые файлы пользовательских программ
- __/var__: Файлы переменных данных (Например, файлы журналов, кэш программ, cron)
	- **/var/cache**: Данные кэша приложений. Сюда скачиваются пакеты перед их установкой в систему
	- **/var/lib**: Информация о состоянии. Постоянные данные, изменяемые программами в процессе работы
	- **/var/lock**: Lock-файлы, указывающие на занятость некоторого ресурса
	- **/var/log**: Файлы событий
	- **/var/mail**: Почтовые ящики пользователей
	- **/var/run**: Информация о запущенных программах
	- **/var/spool**: Задачи, ожидающие обработки (Например, очередь печати, непрочитанные или неотправленные письма)
	- **/var/tmp**: Временные файлы, которые должны быть сохранены между перезагрузками
	- **/var/www**: Директорий веб-сервера Apache

### Disk Management

- Управление дисками включает управление физическими устройствами хранения данных (SSD, HDD, сьемные устройства хранения данных).
- __fdisk__ - основная утилита для управления дисками, которая позволяет создавать, удалять и управлять разделами диска. Также отображает информацию о таблице разделов, их размеры и типы. Разделение диска позволяет разделить физическое пространство на отдельные разделы для форматирования в различные файловые системы.
- Монтирование (mounting) - подключение диска к определенному каталогу, что делает его доступным для иерархии файловой системы. После монтирования диска, к нему можно получить доступ и управлять также, как и любым другим каталогом в системе. 
- Нельзя отключить монтированную файловую систему, если она имеет запущенный процесс. Посмотреть список открытых файлов [__lsof__](#lsof).
- Файл __/etc/fstab__ содержит информацию обо всех файловых системах, смонтированных в системе, включая параметры автоматического монтирования во время загрузки и другие параметры монтирования. Чтобы автоматически размонтировать файловую систему при завершении работы, необходимо добавить запись с параметром __noauto__ в файл __/etc/fstab__.

### SWAP

- __Swapping__ - ​процесс ​переноса ядром неактивных страниц памяти в _swap space_, освобождая физическую память для использования активными процессами, когда в системе заканчивается физическая память.
- __Swap space__ можно создать либо во время установки ОС, либо в любое время после нее с помощью команд __mkswap__ и __swapon__.
- Команда __mkswap__ используется для настройки _swap space_ Линукс на устройстве или в файле, а команда __swapon__ используется для активации _swap space_. Размер _swap space_ зависит от личных предпочтений и зависит от объема физической памяти, установленной в системе, и типа использования, которому будет подвергаться система. При создании _swap space_ важно убедиться, что оно размещено в выделенном разделе или файле, отдельном от остальной файловой системы. Это помогает предотвратить фрагментацию _swap space_ и гарантирует, что в системе будет достаточно _swap space_, когда это необходимо. Также важно убедиться, что _swap space_ зашифровано, поскольку конфиденциальные данные могут временно храниться в _swap space_.
- Помимо использования в качестве расширения физической памяти, _swap space_ также можно использовать для спящего режима, который представляет собой функцию управления питанием, которая позволяет системе сохранять свое состояние на диск, а затем выключаться вместо полного выключения. При последующем включении системы она может восстановить свое состояние из _swap space_, вернувшись в состояние, в котором она находилась до выключения.

## Terminal Hotkeys

- __CTRL+C__: Прерывает выполнение текущей команды;
- __CTRL+D__: Завершает текущий процесс;
- __CTRL+Z__: Приостанавливает выполнение процесса (Продолжить - `fg`);
- __CTRL+A__: Перемещает курсор в начало строки;
- __CTRL+E__: Перемещает курсор в конец строки;
- __CTRL+U__: Удаляет текст от курсора до начала строки;
- __CTRL+K__: Удаляет текст от курсора до конца строки;
- __CTRL+L__: Очищает экран;
- __CTRL+R__: Ищет вводимую строку в истории команд;
- __CTRL+W__: Удаляет слово перед курсором;
- __CTRL+Y__: Вставляет удаленный текст;
- __CTRL+P__: Перемещает курсор на одну строку вверх в истории команд;
- __CTRL+N__: Перемещает курсор на одну строку вниз в истории команд;
- __CTRL+T__: Меняет местами символы до и после курсора;
- __CTRL+F__: Перемещает курсор на одно слово вперед;
- __CTRL+B__: Перемещает курсор на одно слово назад;
- __CTRL+D__: Удаляет слово после курсора;
- __Alt+.__: Вставляет поледний аргумент предыдущей команды;
- __Tab__: Автодополнение имен файлов и команд;
- __CTRL+Alt+Del__: Перезагрузка системы.

## File descriptor and redirections

Файловый дескриптор — натуральное число (идентификатор), закреплённое за определённым потоком ввода-вывода. В Linux библиотека libc открывает для каждого запущенного приложения (процесса) 3 файл дескриптора, с номерами 0, 1, 2:
- Файл дескриптор 0 называется STDIN и ассоциируется с вводом данных у приложения;
- Файл дескриптор 1 называется STDOUT и используется приложениями для вывода данных, например командами print;
- Файл дескриптор 2 называется STDERR и используется приложениями для вывода данных, сообщающих об ошибке.

```bash
find /etc/ -name shadow 2>/dev/null > results.txt
# Явное перенаправление стандартного вывода:
find /etc/ -name shadow 2> stderr.txt 1> stdout.txt
```
- Перенаправление файлового дескриптора ошибок на нулевое устройство, которое отбрасывает все данные и перенаправление файлового дескриптора вывода в файл results.txt. `>` создает или перезаписывает файл, `>>` добавляет в файл.

```bash
cat < stdout.txt
```
- Перенаправление стандартного ввода.

```bash
find /etc/ -name *.conf 2>/dev/null | grep systemd | wc -l
```
- Перенаправление результата работы функции find в функцию grep, а затем перенаправление в функцию wc.

## Permission Management

![](materials/images/permissions.png)

- Разрешения назначаются пользователям и группам. Каждый пользователь может быть членом различных групп, и членство в этих группах дает пользователю особые дополнительные разрешения. 
- Каждый файл и каталог принадлежит определенному пользователю и определенной группе. 
- При создании новых файлов или каталогов, они принадлежат группе, к которой принадлежит пользователь, и пользователю.
- Для перемещения по каталогу необходимы разрешения на выполнение, независимо от уровня доступа пользователя. Разрешения на выполнение каталога не позволяют пользователю выполнять или изменять какие-либо файлы или содержимое в каталоге, а только просматривать и получать доступ к содержимому каталога.
- Чтобы изменить содержимое каталога (создать, удалить или переименовать файлы и подкаталоги), пользователю необходимы права на запись в каталоге.
- Вся система разрешений основана на восьмеричной системе счисления, и файлу или каталогу можно назначить три различных типа разрешений (`r` - Read, `w` - Write, `x` - Execute).
- Команда [chmod](#chmod) позволяет изменить разрешения (u — владелец, g — группа, o — другие, a — все пользователи), `+` или `-` для добавления и удаления назначенных разрешений.

### SUID & SGID

Помимо назначения прямых разрешений для пользователей и групп, также можно настроить специальные разрешения для файлов, установив биты Set User ID (SUID) и Set Group ID (SGID). Эти биты SUID/SGID позволяют, например, пользователям запускать программы с правами другого пользователя. Администраторы часто используют это, чтобы предоставить своим пользователям особые права для определенных приложений или файлов. Вместо буквы «x» используется буква «s». При выполнении такой программы используется SUID/SGID владельца файла.

Если администратор установит бит SUID для «journalctl», любой пользователь сможет запустить оболочку от имени пользователя root.

### Sticky Bit

Sticky Bit — это тип прав доступа к файлам, которые можно установить для каталогов. Этот тип разрешений обеспечивает дополнительный уровень безопасности при контроле удаления и переименования файлов в каталоге. Обычно он используется в каталогах, которые используются несколькими пользователями, чтобы предотвратить случайное удаление или переименование одним пользователем файлов, которые важны для других.

Например, в общем домашнем каталоге, где несколько пользователей имеют доступ к одному и тому же каталогу, системный администратор может установить Sticky Bit для каталога, чтобы гарантировать, что только владелец файла, владелец каталога или пользователь root может удалять или переименовывать файлы в каталоге. Это означает, что другие пользователи не могут удалять или переименовывать файлы в каталоге, поскольку у них нет необходимых разрешений. Это обеспечивает дополнительный уровень безопасности для защиты важных файлов, поскольку только те, у кого есть необходимый доступ, могут удалять или переименовывать файлы. Установка Sticky Bit для каталога гарантирует, что только владелец, владелец каталога или пользователь root смогут изменять файлы в каталоге.

Когда для каталога установлен Sticky Bit, он обозначается буквой «t» в разрешении на выполнение разрешений каталога. Например, если каталог имеет разрешения «rwxrwxrwt», это означает, что установлен Sticky Bit, что дает дополнительный уровень безопасности, чтобы никто, кроме владельца или пользователя root, не мог удалять или переименовывать файлы или папки в каталоге.

Если Sticky Bit написан с заглавной буквы (T), то это означает, что все остальные пользователи не имеют разрешений на выполнение (x) и, следовательно, не могут видеть содержимое папки и запускать из нее какие-либо программы. Sticky Bit в нижнем регистре (t) — это Sticky Bit, в котором установлены разрешения на выполнение (x).

## Service and Process Management

Существует два типа служб: __внутренние__, которые требуются при запуске системы и которые, например, выполняют задачи, связанные с оборудованием, и __пользовательские__, которые обычно включают в себя все серверные службы. Такие службы работают в фоновом режиме без какого-либо взаимодействия с пользователем. Их также называют демонами и обозначают буквой «d» в конце имени программы, например, sshd или systemd.

Большинство дистрибутивов Linux перешли на systemd. Этот демон представляет собой инициализирующий процесс, запускаемый первым, и поэтому имеет PID 1. Этот демон контролирует и обеспечивает упорядоченный запуск и остановку других служб. Всем процессам присвоен PID, который можно просмотреть в /proc/ с соответствующим номером. Такой процесс может иметь идентификатор родительского процесса (PPID), и если имеет, то он называется дочерним процессом.

Процесс может находиться в следующих состояниях:
- Running;
- Waiting (ожидание события или системного ресурса);
- Stopped;
- Zombie (остановлен, но запись в таблице процессов все еще есть).

Чтобы взаимодействовать с процессом, мы должны послать ему сигнал. Мы можем просмотреть все сигналы с помощью `kill -l`. Из них часто используемые:
- __1 SIGHUP__: Отправляется процессу, когда терминал, который им управляет, закрывается;
- __2 SIGINT__: Отправляется, когда пользователь нажимает `Ctrl+C` в управляющем терминале, чтобы прервать процесс;
- __3 SIGQUIT__: Отправляется, когда пользователь нажимает `Ctrl+D` для выхода;
- __9 SIGKILL__: Немедленное завершение процесса без операций очистки;
- __15 SIGTERM__: Завершение программы;
- __19 SIGSTOP__: Остановить программу. С этим уже невозможно справиться;
- __20 SIGTSTP__: Отправляется, когда пользователь нажимает `Ctrl+Z`, чтобы запросить приостановку службы. Пользователь может справиться с этим позже.

### Background processes

Иногда необходимо перевести процесс в фоновый режим, чтобы продолжить использование текущего сеанса для взаимодействия с системой или запуска других процессов. Перевести процесс в фоновый режим можно с помощью `CTRL+Z`, указания `&` в конце командной строки. `bg` отображает все фоновые процессы. `fg <id>` позволяет вывести фоновый процесс в основной поток. Фоновые процессы позволяют использовать тот же сеанс оболочки, не дожидаясь, пока процесс сначала завершится. Как только сканирование или процесс завершат свою работу, терминал уведомит нас о завершении процесса.

### Executing multiple commands

Способы запуска нескольких команд разделителями:
- __;__: Игнорирует код возврата предыдущей команды;
- __&&__: Если код возврата предыдущей команды не 0, то выполнение команд прерывается;
- __|__: Зависит не только от корректной и безошибочной работы предыдущих процессов, но и от результатов предыдущих процессов.

## Task Scheduling

Планирование задач позволяет пользователям планировать и автоматизировать запуск задач в определенное время или с определенной частотой без необходимости запускать их вручную.

Примеры использования: автоматическое обновление программного обеспечения, запуск сценариев, очистка баз данных и автоматизация резервного копирования.

Пользователи могут планировать регулярные и повторяющиеся задачи, чтобы обеспечить их регулярное выполнение. Кроме того, можно настроить оповещения для отображения при возникновении определенных событий или для связи с администраторами или пользователями.

### systemd

Задачи можно планировать с помощью systemd. Чтобы создать таймер для systemd, нужно создать каталог, в котором будет храниться скрипт таймера.

```bash
sudo mkdir /etc/systemd/system/mytimer.timer.d
sudo vim /etc/systemd/system/mytimer.timer
```

Далее нужно создать скрипт, настраивающий таймер. Скрипт должен содержать следующие опции: «Unit, «Timer» и «Install». Опция «Unit» определяет описание таймера. Опция «Timer» определяет, когда запускать таймер и когда его активировать. Наконец, опция «Install» указывает, где установить таймер.

```bash
[Unit]
Description=My Timer

[Timer]
OnBootSec=3min
OnUnitActiveSec=1hour

[Install]
WantedBy=timers.target
```

Например, если мы хотим запустить скрипт только один раз после загрузки системы, следует использовать настройку OnBootSec в таймере. Однако если мы хотим, чтобы сценарий запускался регулярно, нам следует использовать OnUnitActiveSec, чтобы система запускала сценарий через регулярные промежутки времени. Далее нам нужно создать наш сервис.

```bash
sudo vim /etc/systemd/system/mytimer.service
```

Здесь задаем описание и указываем полный путь к скрипту, который хотим запустить. «multi-user.target» — это система единиц, которая активируется при запуске обычного многопользовательского режима. Он определяет службы, которые должны запускаться при обычном запуске системы.

```bash
[Unit]
Description=My Service

[Service]
ExecStart=/full/path/to/my/script.sh

[Install]
WantedBy=multi-user.target
```

После этого мы должны позволить systemd снова прочитать папки, чтобы включить изменения.

```bash
sudo systemctl daemon-reload
```

После этого мы можем использовать systemctl, чтобы запустить службу вручную и включить автозапуск.

```bash
sudo systemctl start mytimer.service
sudo systemctl enable mytimer.service
```

### CRON

CRON позволяет выполнять задачи в определенное время или через определенные промежутки времени. Нужно создать сценарий, а затем указать демону CRON, чтобы он вызывал его в определенное время.

Чтобы настроить демон CRON, нужно сохранить задачи в файле с именем crontab, а затем сообщить демону, когда запускать задачи.

```
[Minute] [Hour] [Day] [Month] [Weekday] [Command to be executed]
```

- __Minute__: (0-59) Определяет, в течение какой минуты задача должна быть выполнена.
- __Hour__: (0-23) Определяет, в какой час должна быть выполнена задача.
- __Day__: (1-31) Определяет, в какой день месяца должна выполняться задача.
- __Month__: (1-12) Определяет, в каком месяце задача должна быть выполнена.
- __Weekday__: (0-7) Определяет, в какой день недели должна выполняться задача.

#### Operators

- __`*`__: Все значения;
- __`,`__: Разделяет отдельные значения;
- __`-`__: Диапазон значений;
- __`/`__: Разделяет значения на шаги.

#### Special lines

- __`@reboot`__: every reboot.
- __`@hourly`__: once every hour - same as `0 * * * *`.
- __`@daily`__: once every day - same as `0 0 * * *`.
- __`@midnight`__: once every midnight - same as `@daily`.
- __`@weekly`__: once every week - same as `0 0 * * 0`.
- __`@monthly`__: once every month - same as `0 0 1 * *`.
- __`@yearly`__: once every year - same as `0 0 1 1 *`.

#### Usage

```bash
# Every 15 mins
*/15 * * * *

# Every 2 hours
0 */2 * * *

# Every week Mon-Sat at 6pm
0 18 * * 0-6

# Every Sat and Sun on 2:10am
10 2 * * 6,7

# Adding tasks easily
echo “@reboot echo hi” | crontab

# Open in editor - optional for another user
crontab -e [-u user]

# List tasks - optional for another user
crontab -l [-u user]

# Delete crontab file - optional for another user
crontab -r [-u user]

# «Обновление системы» должно выполняться каждые шесть часов. На это указывает запись */6 в столбце часов. Задачу выполняет скрипт update_software.sh, путь к которому указан в последнем столбце.
* */6 * * /update_software.sh

# Сценарии выполнения задач должны выполняться каждый первый день месяца в полночь. На это указывают записи 0 и 0 в столбцах минут и часов и 1 в столбце дней месяца. Задачу выполняет скрипт run_scripts.sh, путь к которому указан в последнем столбце.
0 0 1 * * /run_scripts.sh

# Третья задача, «Очистка базы данных», должна выполняться каждое воскресенье в полночь. Это определяется записями 0 и 0 в столбцах минут и часов и 0 в столбце дней недели. Задачу выполняет скрипт clean_database.sh, путь к которому указан в последнем столбце.
0 0 * * 0 /clean_database.sh

# Резервное копирование должно выполняться каждое воскресенье в полночь. На это указывают записи 0 и 0 в столбцах минут и часов и 7 в столбце дней недели. Задачу выполняет скрипт backup.sh, путь к которому указан в последнем столбце.
0 0 * * 7 /backup.sh
```

## PTY

- Псевдотерминалы (PTY) - это абстрактные устройства в операционной системе Linux, предназначенные для обеспечения взаимодействия между процессами и терминалами. PTY используются для обеспечения доступа к текстовому вводу/выводу, такому как командная оболочка, через различные уровни абстракции
- Виртуальные терминалы используют псевдотерминалы (PTY), чтобы обеспечить взаимодействие пользователя с текстовой оболочкой
- В Linux каждый псевдотерминал имеет пару: мастер и слейв. Мастер является "внешним" интерфейсом, через который пользователь взаимодействует с псевдотерминалом, а слейв - "внутренним" интерфейсом, используемым программами
- VT создаются при загрузке системы и могут быть управляемыми с помощью утилит, таких как chvt и openvt. Пользователь может переключаться между VT с помощью клавиш Ctrl+Alt+F1, Ctrl+Alt+F2 и так далее
- Пользователь может войти в VT, введя логин и пароль. Для выхода из VT можно использовать команду exit. VT можно завершить, нажав Ctrl+Alt+Del (важно отметить, что это не то же самое, что перезагрузка системы). Управление VT можно выполнять с помощью утилиты chvt для переключения между VT
- PTY может быть создан с помощью системных вызовов, таких как openpty(), forkpty(), posix_openpt(), и других
- Процесс, создающий PTY, становится мастером, а второй процесс (обычно оболочка) становится слейвом

Один из наиболее распространенных способов использования PTY - это выполнение удаленных команд через SSH. При подключении к удаленному хосту, SSH использует PTY для обеспечения интерактивного текстового ввода/вывода между клиентом и сервером

## Bonding

**Бондинг (объединение сетевых интерфейсов, агрегирование каналов)** - это технология, позволяющая объединять несколько сетевых интерфейсов в одну виртуальную сетевую карту для увеличения пропускной способности и/или обеспечения отказоустойчивости.

Поведение связанных интерфейсов зависит от режима; режимы предоставляют либо услуги горячего резерва, либо услуги балансировки нагрузки. Кроме того, может выполняться мониторинг целостности канала.

Крайне важно указать параметры miimon или arp_interval и arp_ip_target , в противном случае во время сбоев канала произойдет серьезная деградация сети. Очень немногие устройства не поддерживают хотя бы miimon, поэтому нет причин не использовать его.

```bash
/etc/netplan/_____.yaml
cat /proc/net/bonding/bond0
```
- Конфигурационные файлы, отвечающие за конфигурирование Bond
```bash
ip a
ethtool
bmon
```
- Утилиты для проверки работоспособности Bond
```jsx
network:
	bonds:
		bond0:
			dhcp4: true
			interfaces: [ens38, ens33]
			parameters:
				mode: balance-rr
				transmit-hash-policy: layer3+4
				mii-monitor-interval: 1
	ethernets:
		ens38:
				dhcp4: false
				dhvp6: false
		ens33:
				dhcp4: false
				dhcp6: false
	version: 2
```
- Пример конфигурирования файлов для корректной работы Bond

## CLI

- **CLI (Command Line Interface)** - текстовый интерфейс для работы с ОС
- **Терминал:** это окно или приложение, в котором пользователь взаимодействует с CLI. В Linux есть множество терминалов, включая виртуальные терминалы (VT) и терминалы в графической среде
- **Виртуальные терминалы (или VT)** - это механизм в операционной системе Linux, который предоставляет текстовые консоли, позволяющие пользователям взаимодействовать с системой в текстовом режиме. **Локальные VT** доступны напрямую с физической консоли, обычно через клавиши Ctrl+Alt+F1, Ctrl+Alt+F2 и так далее. **Удаленные VT** могут быть доступны посредством SSH или других удаленных протоколов
- **Оболочка (Shell):** оболочка - это программа, которая обрабатывает команды, введенные пользователем, и выполняет их. Примеры оболочек включают Bash, Zsh, Fish и другие
- **Команда:** это текст, введенный пользователем, который указывает системе, какое действие выполнить
- **Аргументы:** это дополнительные параметры, передаваемые команде, чтобы уточнить ее действие
- **Путь (Path):** это указание на файл или каталог в файловой системе
- **Псевдоним (Alias):** это короткое имя, которое может быть связано с длинной командой для удобства

### System Information

#### whoami

```bash
# Имя текущего пользователя
whoami
```

#### id

-

#### hostname

-

#### uname

```bash
# Архитектура процессора
uname -m
# Версия ядра ОС
uname -r
```

#### pwd

```bash
# Полный путь текущей директории
pwd
```

#### ifconfig

**ifconfig (настройка интерфейса)** - это инструмент управления сетью. Он используется для настройки и просмотра состояния сетевых интерфейсов в Linux. С помощью ifconfig вы можете назначать IP-адреса, включать или отключать интерфейсы, управлять кешем ARP, маршрутами и т. д.

- Конфигурации, установленные с помощью ifconfig, не являются постоянными. После перезапуска системы все изменения теряются. Чтобы сделать изменения постоянными, необходимо отредактировать файлы конфигурации конкретного дистрибутива или добавить команды в сценарий запуска.

> [!INFO] Кстати
> Только root или пользователи с привилегиями sudo могут настраивать сетевые интерфейсы

> [!ERROR] Внимание
> Команда ifconfig устарела, заменена ip на новых дистрибутивах Linux и может не входить в их состав

```bash
# Информация о всех сетевых устройствах
ifconfig -a

# Информация о конкретном сетевом устройстве
ifconfig eth0

# Отключить сетевой интерфейс
ifconfig eth0 down

# Включить сетевой интерфейс
ifconfig eth0 up

# Назначить интерфейсу eth0 IP-адрес и маску подсети
ifconfig eth0 192.168.1.1 netmask 255.255.255.0

# Назначить интерфейсу eth0 доп. IP-адрес и маску подсети
ifconfig eth0:0 192.168.1.1 netmask 255.255.255.0

# Включение/Отключение беспорядочного режима. Режим позволяет получать доступ ко всем пакетам сети
ifconfig eth0 promisc (OR -promisc)

# Изменение MTU сетевого устройства. Позволяет ограничить размер пакетов, передаваемых через интерфейс
ifconfig eth0 mtu 500

# Изменение MAC-адреса сетевого интерфейса
ifconfig eth0 hw ether 01:01:01:01:01:01
```

#### ip

**ip** - инструмент для настройки сетевых интерфейсов. Он используется для включения или выключения интерфейсов, назначения и удаления адресов и маршрутов, управления кешем ARP и многого другого. Утилита ip является частью пакета iproute2, который установлен во всех современных дистрибутивах Linux.

- Конфигурации, установленные с помощью ip, не являются постоянными. После перезапуска системы все изменения теряются. Чтобы сделать изменения постоянными, необходимо отредактировать файлы конфигурации конкретного дистрибутива или добавить команды в сценарий запуска.

> [!INFO] Кстати
> Только root или пользователи с привилегиями sudo могут настраивать сетевые интерфейсы

```bash
# Таблица маршрутизации
ip route

# Список всех сетевых интерфейсов
ip addr
# Или
ip a

# Отображение только IPv4-адресов
ip -4 addr

# Информация об интерфейсе
ip addr show dev eth0

# Добавление IP-адреса с маской сетевому устройству eth0. Таким образом можно назначать несколько IP-адресов одному интерфейсу
ip address add 0.0.0.0/24 dev eth0

# Удалить IP-адрес из интерфейса
ip address del 0.0.0.0/24 dev eth0

# Список всех сетевых интерфейсов. Не выводит информацию об IP-адресах
ip link show

# Информация о конкретном сетевом интерфейсе
ip link show dev eth0

# Включение интерфейса
ip link set dev eth0 up

# Выключение интерфейса
ip link set dev eth0 up

# Таблица маршрутизации
ip route
ip route list

# Маршрутизация для определенной сети
ip r list 127.0.0.0/24

# Добавление маршрута к 127.0.0.0/24 через шлюз 127.0.0.1
ip route add 127.0.0.0/24 via 127.0.0.1

# Добавление маршрута к 127.0.0.0/24, который может быть достигнут на устройстве eth0
ip route add 127.0.0.0/24 dev eth0

# Добавление маршрута по умолчанию через локальный шлюз 192.168.121.1, который может быть достигнут на устройстве eth0
ip route add default via 127.0.0.1 dev eth0

# Удаление маршрута по умолчанию
ip route del default

# Удаление маршрута для 127.0.0.0/24 через шлюз 127.0.0.1
ip route del 127.0.0.0/24 via 127.0.0.1
```

#### ethtool

- **ethtool** позволяет использовать утилиту с соответствующим именем для изменения низкоуровневых параметров сетевых карт. Данная утилита способна изменять огромное количество параметров сетевых карт, большая часть из которых не интересна обычным пользователям. Кроме того, драйверы сетевых карт домашних компьютеров и ноутбуков не позволяют изменять большую часть поддерживаемых утилитой параметров, поэтому в большинстве случаев она используется для проверки и установки скорости сетевого соединения, а также режима работы сетевой карты.

```bash
# Получение параметров сетевой карты
ethtool eth0

# Установка параметром сетевого соединения
ethtool -s eth0 speed 10 duplex full autoneg off

# Получение параметров драйвера сетевой карты
ethtool -i eth0

# Идентификация порта сетевой карты с помощью мигающего индикатора (7 сек)
ethtool -p eth0 7
```

#### netplan

- Начиная с релиза Ubuntu 17.10, для управления конфигурацией сети используется утилита netplan. Раньше для этих целей применялся скрипт ifupdown, конфигурационные файлы которого находились в папке /etc/network/interfaces. Недостатком такого подхода было то, что файлы настройки сети были разбросаны по всей системе, частью настроек мог управлять NetworkManager, частью systemd-networkd, а часть вообще делалась с помощью ifupdown
- Все конфигурационные файлы Netplan находятся в папке /etc/netplan/. Во время запуска службы, она преобразовывает свою конфигурацию в конфигурацию той службы, которая будет управлять сетью и помещает её в каталог /run/
- По умолчанию управление всей сетью передаётся утилите NetworkManager

> [!NOTE] Параметры netplan
> - **renderer** - программа для обработки конфигурации
> - **dhcp4** - получение IPv4 адреса по DHCP
> - **dhcp6** - получение IPv6 адреса по DHCP
> - **dhcp-identifier** - если передать значение "mac", то будет использоваться MAC-адрес в качестве идентификатора DHCP
> - **addresses** - добавляет статические адреса к интерфейсу, можно несколько
> - **gateway4** - указывает шлюз IPv4
> - **gateway6** - указывает шлюз IPv6
> - **nameservers** - указывает DNS-серверы
> - **macaddress** - устанавливает новый MAC-адрес
> - **routes** - позволяет настроить маршруты таблицы маршрутизации
> - **routing-policy** - дополнительная настройка маршрутов, для IP или подсети
> - **access-points** - список точек доступа для Wi-Fi
> - **password** - пароль для точки доступа Wi-Fi
> - **mode** - режим работы сетевой карты Wi-Fi

```yaml
ls /sys/class/net
```
- Названия сетевых интерфейсов в системе
```yaml
# /etc/netplan/02-networkd.yaml

network:
  version: 2
  renderer: networkd
   ethernets:
    ens33:
     dhcp4: yes
```
- Настройка динамического IP-адреса для интерфейса enp3s0
```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    ens33:
      dhcp4: yes
      nameservers:
        addresses:
          - 8.8.8.8
          - 8.8.4.4
```
- В качестве программы для обработки конфигурации используем Networkd, далее указываем сетевой интерфейс и включаем получение IPv4 адреса по DHCP. Все остальные параметры тоже подтянутся по DHCP. Или мы можем вручную настроить DNS для этого интерфейса
```bash
netplan generate
netplan apply
```
- Проверка и применение конфигурации. Для детального вывода добавить флаг debug
```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    ens33:
      dhcp4: no
      addresses: [ 192.168.1.10/24 ]
      gateway4: 192.168.1.1
      nameservers:
        addresses: [ 8.8.8.8, 8.8.4.4 ]
```
- Статический IP-адрес в netplan настроить немного сложнее. Нужно будет задать не только непосредственно сам адрес, но и другие параметры, которые система раньше получала по DHCP. Надо указать шлюз для доступа в интернет и DNS-серверы. Отключаем получение IP адреса по DHCP (dhcp4).  **addresses** параметр ожидает список IP-адресов, которые нужно присвоить сетевой карте. В конце адреса указывается префикс маски (/24). Маску можно указать только с помощью префикса. **gateway4** задаёт адрес роутера, через который компьютер сможет получить доступ в интернет. Списки можно оформлять не только с помощью черточек, для каждого пункта с новой строки, но и с помощью квадратных скобок, тогда элементы записываются в одну строку через запятую
```yaml
network:
  version: 2
  renderer: networkd
  wifis:
    wlp3s0b1:
      dhcp4: yes
      dhcp6: no
      nameservers:
        addresses: [ 8.8.8.8, 8.8.4.4 ]
      access-points:
        "AccessPoint":
          password: "12345678"
```
- Кроме проводного подключения, система конфигурации netplan умеет управлять подключением к Wi-Fi. Для работы Wi-Fi через Networkd необходим пакет wpasupplicant. На примере показано подключение к точке доступа AccessPoint с паролем 12345678


```
network:
    version: 2
    renderer: networkd
    ethernets:
        ens3:
            dhcp4: true
        ens7:
            dhcp4: no
            addresses: [192.168.122.195/24]
            routes:
              - to: default
                via: 192.168.122.1
            mtu: 1500
            nameservers:
                addresses: [8.8.8.8, 77.88.8.8]
                search: [ dmosk.local ]
        ens9:
            dhcp4: no
            addresses: [192.168.1.10/24, 192.168.1.20/24]
            nameservers:
                addresses:
                    - 8.8.8.8
                    - 77.88.8.8
                search: [ dmosk.local, dmosk.ru ]
```
- Пример настройки 3-х сетевых интерфейсов. Два из них будут с IP-адресами назначенными вручную (static IP), один по DHCP
- **version** - версия YAML. На момент обновления статьи, была 2
- **renderer** - менеджер сети (networkd или NetworkManager)
- **ethernets** - настройка сетевых адаптеров ethernet
- **ens3, ens7, ens9** - настройки для соответствующих сетевых адаптеров. В данном примере мы настраиваем 3 сетевых адаптера
- **dhcp4** - будет ли получать сетевой адаптер IP-адрес автоматически. Возможны варианты yes/true - получать адрес автоматически; no/false - адрес должен быть назначен вручную
- **addresses** - задает IP-адреса через запятую
- **routes** - настройка маршрутов. Для шлюза по умолчанию используем опцию и значение to: default. Ранее использовалась директива gateway4, но теперь она считается устаревшей (при применении настройки с ней система вернет предупреждение gateway4 has been deprecated, use default routes instead)
- **mtu** - при желании, можно задать значение MTU
- **nameservers** - настройка серверов имен (DNS)
- **nameservers addresses** - указываем серверы DNS. Обратите внимание на разный формат записи для ens7 и ens9. Приемлемы оба варианта
- **nameservers search** - дописывает окончание домена, если мы обращаемся к узлу сети только по его имени. Стоит обратить внимание, что мы можем указать несколько доменов через запятую
```
network:
    version: 2
    renderer: networkd
    ethernets:
        ens9:
            dhcp4: no
            addresses: 192.168.1.10/24
            nameservers:
                addresses:
                    - 8.8.8.8
                    - 77.88.8.8
            routes:
              - to: 192.168.0.0/24
                via: 192.168.1.1
                on-link: true
```
- Настройка маршрута для сетевого интерфейса ens9
- **to** - направление маршрута (в какую сеть мы должны попадать). В данном примере, 192.168.0.0/24
- **via** - через какой шлюз мы попадаем в сеть to
- **on-link** - активация маршрута при поднятии линка на сетевом интерфейсе


```
network:
    version: 2
    renderer: networkd
    ethernets:
        ens2f0: {}
        ens2f1: {}
    bonds:
        bond0:
            dhcp4: no
            interfaces:
            - ens2f0
            - ens2f1
            parameters:
                mode: active-backup
            addresses:
                - 192.168.122.195/24
            gateway4: 192.168.122.1
            mtu: 1500
            nameservers:
                addresses:
                    - 8.8.8.8
                    - 77.88.8.8
```
- Пример объединения интерфейсов (bonds). Объединяем физические интерфейсы ens2f0 и ens2f1; настройка parameters mode указываем на тип объединения:
- **balance-rr** (задействуются оба интерфейса по очереди, распределение пакетов по принципу Round Robin)
- **active-backup** (используется только один интерфейс, второй активируется в случае неработоспособности первого)
- **balance-xor** (задействуются оба интерфейса по очереди, распределение пакетов на основе политики хеширования xmit_hash_policy)
- **broadcast** (задействуются оба интерфейса одновременно, пакеты передаются все интерфейсы)
- **802.3ad** (задействуются оба интерфейса по очереди, распределение пакетов на основе политики хеширования xmit_hash_policy)
- **balance-tlb** (задействуются оба интерфейса по очереди, пакеты распределяются в соответствии с текущей нагрузкой)

```
network:
    version: 2
    renderer: networkd
    ethernets:
        ens2f0: {}
    bridges:
        br0:
            macaddress: ce:ce:ce:45:45:45
            interfaces:
                - ens2f0
            addresses:
                - 192.168.1.15/24
            gateway4:
            nameservers:
                addresses:
                    - 77.88.8.8
                    - 8.8.8.8
            mtu: 1500
            parameters:
                stp: true
                forward-delay: 4
            dhcp4: false
            dhcp6: false

```
- Пример настройки сетевого моста (bridge). Сетевой мост позволяет пропускать сетевой трафик через другой сетевой адаптер. Это можно применить, например, для организации хоста виртуальных машин (для трансфера трафика к виртуальным машинам KVM через единственный сетевой интерфейс сервера)
- **bridges** — настройки для интерфейсов bridge
- **bridges br0** — настройка интерфейса br0
- **macaddress** — физический адрес (MAC) интерфейса. Настройка важна для некоторых провайдеров VPS — без нее бридж может не заработать
- **interfaces** — перечисление интерфейсов, из которых собираем мост. В данном примере ens2f0
- **addresses, gateway4, nameservers** — сетевые настройки (IP-адрес, шлюз, сервер имен)
- **mtu** — одноименный параметр. Для сетей ethernet обычно равен 1500
- **parameters stp** — включает или отключает устранение петель в сети. В данном примере включено
- **parameters forward-delay** — время в секундах в течение которого мост будет оставаться в состояниях «Listening» и «Learning»
- **dhcp4, dhcp6** — включает или отключает автоматическое получение IP-адреса. В нашем случае, отключает

```
network:
    version: 2
    renderer: networkd
    ethernets:
        ens3: {}
    vlans: 
        vlan5:
            id: 5
            link: ens3
            dhcp4: no
            addresses: [10.0.0.15/24]
            gateway: 10.0.0.1
```
- Пример настройки тегированного интерфейса vlan с тегом 5 на физическом адаптере ens3

**Отключение netplan и возврат к interfaces**

```bash
vi /etc/default/grub
```
- Открываем настройку grub

`GRUB_CMDLINE_LINUX="netcfg/do_not_use_netplan=true"`
- Находим опцию GRUB_CMDLINE_LINUX и дописываем в нее параметр. Если GRUB_CMDLINE_LINUX содержит другие настройки, то наш параметр добавляем через пробел

```bash
apt install ifupdown
```
- Устанавливаем пакет ifupdown

```bash
nano /etc/network/interfaces
```
- Настраиваем сеть в файле

```
auto lo
iface lo inet loopback

auto ens5
iface ens5 inet dhcp
```
- Настраиваем сетевой интерфейс ens5 на автоматическое получение IP-адреса

```bash
update-grub
```
- Применяем настройки загрузчика

```bash
shutdown -r now
```
- Перезагружаем систему

#### netstat

```bash
# Отобразить все установленные сетевые соединения по TCP, UDP без разрешения имен в IP-адреса и PID и имена процессов, обеспечивающих соединения
netstat -tulnp

# Таблица маршрутизации
netstat -r

# Количество активных соединений на порту 80
netstat -an | grep :80 | sort
```

#### ss

-

#### ps

```bash
# Все процессы
ps aux

# Процессы включающие аргументы командной строки
ps -AFl

# Все процессы потока в древовидном режиме
ps -AlFH

# Процессы по иерархии
ps -e -o pid,args --forest

# Список процессов по владельцу
ps -U user -u user u

# Топ 5 процессов по использованию памяти
ps auxf | sort -nr -k 4 | head -5
```

#### who

-

#### env

```bash
# Текущие переменные окружения
env

# Установить переменную окружения
env VARIABLE=value

# Удалить переменную окружения
env -u VARIABLE
```

#### lsblk

-

#### lsusb

-

#### lsof

```bash
# Показать все открытые файлы и сокеты
lsof

# Показать открытые файлы для определенного процесса
lsof -p PID

# Найти процесс, который использует определенный порт
lsof -i :port_number
```

#### lspci

-

#### jobs

-

### User Management

#### sudo

Сокращенно от «SuperUser Do», эта команда позволяет выполнять задачи, требующие прав администратора или root. Однако не рекомендуется использовать эту команду для повседневных задач, так как неправильное её использование может легко стать причиной появления ошибок.

```bash
# Обновить список пакетов
sudo apt update

# Удалить все файлы журналов
sudo rm -rf /var/log

# Редактировать файл конфигурации nginx
sudo nano /etc/nginx/nginx.conf
```

#### passwd

```bash
# Сменить пароль текущего пользователя
passwd

# Сменить пароль пользователя
passwd username
```

#### useradd

```bash
# Создать пользователя user1, назначить домашний каталог /home/user1, назначить shell /bin/bash, включить в группу admin и добавить комментарий Comment
useradd -c "Comment" -g admin -d /home/user1 -s /bin/bash user1

# Создать пользователя user1
useradd user1

# Создать пользователя с домашним каталогом
useradd -m user1

# Создать пользователя и добавить в группу sudo
useradd -G sudo user1
```

#### userdel

```bash
# Удалить пользователя и его каталог
userdel -r user1
```

#### usermod

```bash
# Добавить пользователя в группу sudo
usermod -aG sudo user1

# Изменение атрибутов пользователя
usermod -c "User FTP" -g system -d /ftp/user1 -s /bin/nologin user1
```

#### groupadd

```bash
# Создать группу
groupadd name

# Создать системную группу
groupadd -r name
```

#### groupdel

```bash
# Удалить группу
groupdel name

# Удалить группу без предупреждения
groupdel -f name

# Удалить группу, включая связанные файлы и каталоги
groupdel --remove name

# Удалить группу и перенести файлы в другую группу
groupdel --move-to=backupgroup name
```

#### groupmod

```bash
# Изменить название группы
groupmod -n newname oldname

# Изменить GID группы
groupmod -g 1000 name

# Добавить пользователей в группу
groupmod -m -g name user1,user2

# Исключить пользователей из группы
groupmod -g name user1,user2
```

### Package Management

#### APT

**APT (Advanced Packaging Tool)** - консольная утилита, выполняющая роль «поисковика» и загрузчика пакетов из репозиториев. Установка скачанных пакетов производится утилитой DPKG. Благодаря эффективному разрешению зависимостей, пакетный менеджер APT используется по умолчанию в дистрибутивах с архитектурой Debian и поддерживает систему в актуальном состоянии.

У APT есть список репозиториев, из которых происходит установка пакетов. Список хранится в текстовом файле /etc/apt/sources.list, а также в директории /etc/apt/sources.list.d/. При выполнении команды apt update, APT проходит по списку репозиториев и из каждого репозитория в списке получает информацию о пакетах, находящихся в репозитории. Вся эта информация сохраняется в системе.

```bash
# Обновление пакетов до новых версий, не устанавливает другие пакеты
apt update

# Обновление пакетов, а также удаление или установка новых пакетов, если это потребуется для разрешения зависимостей
apt upgrade

# Очистка локального репозитория
apt clean

# Удаление неиспользуемых пакетов
apt autoremove

# Удаление пакета из системы, с сохранением конфигурационных файлов
apt remove packet

# Удаление пакета со всеми зависимостями
apt purge packet

# Установка пакета
apt install packet
apt install packet1 packet2
apt install packet=version

# Проверить целостность зависимостей
apt check

# Вывод списка установленных в системе пакетов
apt list --installed

# Поиск паттерна в названии и описании пакетов
apt search pattern

# Информация о пакете
apt show packet

# Редактирование списка репозиториев. Открывает файл /etc/apt/sources.list, после сохранения изменений и закрытия, выполняет проверку файла на предмет ошибок
apt edit-sources
```

#### pip

-

#### git

Git - это очень популярная система контроля версий и совместной разработки проектов с открытым исходным кодом. С помощью Git вы можете отслеживать изменения в исходном коде своих проектов, возвращать предыдущие версии в случае критических ошибок, а также делиться своим кодом со всеми желающими и принимать от них исправления.Это мощная система, которая позволяет оптимизировать работу над вашими проектами. Здесь нет каких-либо требований к языку или структуре файлов, поэтому у разработчиков полная свобода действий.

#### dpkg

**DPKG (Debian Package)** - система управления пакетами в Debian и дистрибутивах на его основе, например Ubuntu. Низкоуровневый пакетный менеджер создан только для работы с локальными DEB пакетами и не может самостоятельно разрешать зависимости, а также скачивать пакеты из репозиториев.

Удаление пакетов с использованием dpkg в большинстве случаев не рекомендуется. Лучше использовать менеджер пакетов, отслеживающий зависимости, чтобы гарантировать, что система находится в связанном состоянии. Например, использование dpkg -r zip удалит пакет zip, однако любые пакеты, зависящие от него, останутся установленными и более не смогут работать правильно.

```bash
# Установить пакет
dpkg -i package.deb

# Удалить пакет из системы
dpkg -r package

# Показать все пакеты, установленные в системе
dpkg -l

# Найти пакет, содержащий в имени httpd
dpkg -l | grep httpd

# Информация о конкретном пакете
dpkg -s package

# Вывести список файлов, входящих в пакет, установленный в систему
dpkg -L package

# Отобразить список файлов, входящих в пакет, который еще не установлен в систему
dpkg --contents package.deb

# Найти пакет, в который входит указанный файл
dpkg -S /bin/ping
```

### Basic

#### date

```bash
# Текущая дата
date

# Установить системные дату и время ММДДЧЧммГГГГюСС (МесяцДеньЧасМинутыГод.Секунды)
date 123123592024.00

# Форматированный вывод текущей даты
date "+%Y-%m-%d %H:%M:%S %A %B %Y"

# Установка даты и времени через форматированный ввод
date --set="2024-04-28 09:30:00"
```

#### df

Отчёт об использовании дискового пространства в системе в процентах и килобайтах.

```bash
# Информация о дисках системы
df

# Информация о текущем диске в удобном формате
df -h .
```

#### du

```bash
# Размер файлов и каталогов в текущем каталоге, отсортированных по размеру
du -ah | sort -rh

# Размер файла
du file

# Размеры всех файлов и каталогов в каталоге
du -sh *

# Размер каждого подкаталога в текущем каталоге
du -h --max-depth=1
```

#### export

```bash
# Экспортировать переменную окружения
export VARIABLE=value

# Проверить экспортированные перменные окружения
export

# Сбросить экспортированную переменную окружения
export -n VARIABLE
```

#### find

```bash
# Найти файлы и каталоги с именем file1 в каталоге /
find / -name file1

# Найти файлы и каталоги с владельцем user1 в каталоге /
find / -user user1

# Найти файлы и каталоги, имена которых оканчиваются на .bin в каталоге /
find / -name "*.bin"

# Найти файлы в каталоге /, время последнего обращения к которым более 100 дней
find / -type f -atime +100

# Найти файлы в каталоге /, созданные или измененные в течение последних 10 дней
find / -type f -mtime -10

# Найти файлы и каталоги в каталоге /, размер которых больше 1 мбайта
find / -size +1M
```

#### free

```bash
# Информация об оперативной памяти
free

# Информация об оперативной памяти каждую секунду
free -s 1
```

#### gunzip

```bash
# Распаковать файл
gunzip file.gz

# Распаковать файл и вывести в файл uncompressed_file
gunzip -c file.gz > uncompressed_file
```

#### gzip

```bash
# Сжать файл и создать file.gz
gzip file
```

#### history

```bash
# Последние 20 выполненных команд
history 20

# Очистить историю команд
history -c
```

#### locate

```bash
# Найти файл по названию без учета регистра
locate -i file.txt

# Обновление БД для поиска файлов
updatedb
```

#### man

```bash
# Руководство по команде ls
man ls

# Описание системного вызова fork
man 2 fork
```

#### mount

```bash
# Монтировать раздел hda2 в точку монтирования /mnt/hda2
mount /dev/hda2 /mnt/hda2

# Монтировать ISO-образ в каталог /mnt/cdrom
mount -o loop file.iso /mnt/cdrom

# Все примонтированные файловые системы, включая имя устройства, тип файловой системы, точка монтирования, параметры.
mount

# Отключение файловой системы, а именно смонтированного ISO-образа.
unmount /mnt/cdrom
```

#### reboot

```bash
# Перезагрузка системы
reboot
```

#### service

```bash
# Запуск сервиса nginx
service nginx start

# Статус сервиса ssh
service ssh status

# Остановить сервис Apache2
service apache2 stop
```

#### shutdown

```bash
# Остановка системы
shutdown -h now

# Запланированная остановка системы
shutdown -h hours:minutes &

# Отмена запланированной остановки системы
shutdown -c

# Перезагрузка системы через 5 минут
shutdown -r +5
```

#### tar

Команда **tar** является наиболее часто используемой командой для архивирования нескольких файлов в **tarball** — общий формат файлов Linux, аналогичный формату zip, при этом сжатие является опциональным.

Это довольно сложная команда с длинным списком функций, таких как добавление новых файлов в существующий архив, перечисление содержимого архива, извлечение содержимого из архива и многое другое.

```bash
# Создать сжатый архив из каталога folder
tar -czvf archive.tar.gz folder/

# Распаковать архив
tar -xvf archive.tar

# Показать содержимое архива без распаковки
tar -tf archive.tar
```

#### uptime

```bash
# Текущее время, время работы системы, количество пользователей, средняя нагрузка
uptime
```

#### w

```bash
# Отображение пользователей в системе и их действия
w
```

#### wget

Альтернативой Curl является инструмент wget. С помощью этого инструмента можно загружать файлы с FTP или HTTP-серверов прямо из терминала, и он служит хорошим менеджером загрузок.

```bash
# Загрузка файла file.tar.gz с сайта
wget http://example.com/file.tar.gz

# Рекурсивная загрузка всего сайта
wget -r http://example.com

# Загрузка файла и сохранение с указанным именем
wget -0 newfile.html http://example.com
```

#### whatis

```bash
# Краткое описание команды python
whatis python
```

#### which

```bash
# Полный путь к исполняемому файлу python
which python
```

#### zip

```bash
# Создание архива из содержимого каталога folder
zip -r archive.zip folder/

# Создание зашифрованного архива с файлом file.txt
zip -e secure.zip file.txt

# Распаковка архива в текущий каталог
unzip archive.zip
```

### Filter Contents

#### head

```bash
# Вывести первые 10 строк файла
head file

# Вывести первые 20 строк файла
head -n 20 file
```

#### less

```bash
# Содержимое файла с пролистыванием
less file

# Поиск слова в файле
less file
/pattern
```

#### more

-

#### tail

```bash
# Последние строки системного журнала
tail /var/log/syslog

# Последние 20 строк журнала доступа Nginx
tail -n 20 /var/log/nginx/access.log
```

#### sort

```bash
# Сортировка по алфавиту
sort file

# Сортировка двух файлов
sort file1 file2

# Сортировка файлов, отображая только повторяющиеся строки
sort file1 file2 | uniq -d

# Сортировка файлов, отображая только уникальные строки
sort file1 file2 | uniq -u

# Сортировка в обраном порядке
sort -nr file
```

#### grep

```bash
# Поиск строк, начинающихся на pattern в файле file
grep ^pattern file

# Поиск строк, содержащих pattern во всех файлах каталога dir
grep pattern -R /dir

# Поиск строк, содержащих pattern
grep "pattern" file

# Поиск строк, содержащих password без учета регистра
grep -i “password” /var/log/syslog

# Поиск IP-адресов в журнале доступа к веб-серверу
grep -E -o “([0-9]{1,3}\.){3}[0-9]{1,3}” /var/log/apache2/access.log

# Поиск строк, содержащих слово my или false. Флаг -E позволяет использовать регулярные выражения
grep -E "(my|false)" /etc/passwd

# Поиск строки, содержащей слова my и false
grep -E "(my.*false)" /etc/passwd
```

#### cut

```bash
# Вырезать первое поле из файла, разделенного запятыми
cut -d',' -f1 file.csv

# Вырезать символы 1-5 с каждой строки
cut -c1-5 file
```

#### tr

```bash
# Преобразовать все символы в файле в верхний регистр
tr '[:lower:]' '[:upper:]' < file

# Преобразововать символы строки hello в верхний регистр
echo "hello" | tr '[:lower:]' '[:upper:]'
```

#### column

-

#### awk

Чаще всего используется для выборки из колонок.

```bash
# Вывести первый столбец из файла
awk '{print $1}' file

# Разделить строки с помощью разделителя : и вывести первый и третий столбцы
awk -F: '{print $1, $3}' /etc/passwd

# Вывод нечетных строк файла
cat file | awk 'NR%2==1'
```

#### sed

```bash
# Заменить первое вхождение old на new в каждой строке файла
sed 's/old/new/' file

# Вывод 5-10 строк из файла
sed -n '5,10p' file

# Удалить пустые строки файла
sed '/^$/d' file

# Удалить первую строку файла
sed -r '1d' file

# Удалить str из текста файла
sed -e 's/str//g' file

# Заменить последовательность нулей одним нулем
sed -e 's/0*/0/g' file
```

#### uniq

```bash
# Удалить дублирующиеся последовательные строки
uniq file

# Подсчитать количество каждой уникальной строки
uniq -c file
```

#### cat

```bash
# Вывод содрежимого файла на экран
cat file

# Объединение двух файлов в один
cat file1 file2 > file3
```

#### echo

```bash
# Вывод строки на экран
echo "Hello"

# Очистка файла, запись строки в файл
echo "Hello" > file

# Запись строки в конец файла
echo "Hello" >> file

# Вывод значение переменной окружения
echo $PATH
```

#### fmt

```bash
# Форматирование файла для вывода с максимальной шириной строки 80 символов
fmt -w 80 file
```

#### wc

```bash
# Посчитать количество строк в файле
wc -l file

# Посчитать количество слов в строке
echo "Hello, world!" | wc -w
```

### Working with files

#### cd

```bash
# Переход в предыдущую директорию
cd -

# Переход в домашнюю директорию текущего пользователя
cd ~

# Переход в указанную директорию
cd /path/to/file

# Переход в на уровень выше
cd ../
```

#### chmod

```bash
# Аналогично chmod 777 dir1. Выдать права ugo(User Group Other)+rwx(Read Write eXecute) на директорию dir1
chmod ugo+rwx dir1

# Забрать права у группы и всех остальных все права для директории dir1
chmod go-rmw dir1

# Назначить SUID-бит файлу file1. Дает возможность любому пользователю запускать на выполнение файл с полномочиями владельца файла
chmod u+s file1

# Назначить SGID-бит для файла file1
chmod g+s file1

# Снять SGID-бит для файла file1
chmod g-s file1

# Назначить STIKY-бит для файла file1. Позволяет удалять только владельцам
chmod o+t file1

# Снять STIKY-бит для файла file1
chmod o-t file1

# Рекурсивная установка прав для всех каталогов и файлов в каталоге dir
chmod -R 755 dir
```

#### chown

```bash
# Изменить владельца и группу файла file.txt
chown user:group file.txt

# Рекурсивное изменение владельца файлов и каталогов в каталоге dir
chown -R user:group dir/

# Изменить владельца файла file.txt на user
chown user file.txt
```

#### cp

```bash
# Скопировать файл file1 в файл file2
cp file1 file2

# Скопировать каталог dir в каталог dir2 рекурсивно
cp -r dir dir2
```

#### ls

- **-h**: Вывод размера файлов
- **-t**: Вывод списка файлов по дате создания

```bash
# Файлы и директории содержащие в имени цифры
ls *[0-9]*

# Детальная информация о файлах, каталогах и скрытых файлах в текущем каталоге
ls -la
```

#### mv

```bash
# Переименовать файл
mv file1 file2

# Переместить файл в каталог
mv file1 dir

# Переименовать каталог dir1
mv dir1 dir2
```

#### mkdir

```bash
# Создать две директории
mkdir dir1 dir2

# Создать каталог и все промежуточные каталоги
mkdir -p /tmp/dir1/dir2
```

#### rm

- **-v**: Вывод информаци об удаляемых файлах
- **-r**: Удалить каталог и его содержимое рекурсивно
- **-f**: Удалить каталог и его содержимое рекурсивно принудительно

```bash
# Удалить файл
rm file
```

#### touch

```bash
# Создать файл
touch file

# Изменить дату и время создания файла, при отсутствии создать файл с такой датой и временем
touch -t 2412315900 file
```

### Process Management

#### top

Являясь эквивалентом диспетчера задач в Windows, команда top выводит список запущенных процессов, а также информацию о том, сколько ЦП использует каждый процесс. Отслеживать использование системных ресурсов очень полезно. Таким образом, вы сможете определить какой процесс необходимо прекратить, поскольку он потребляет слишком много ресурсов.

```bash
# Вывод список процессов в реальном времени
top
```

#### htop

```bash
# Интерактивный мониторинг процессов
htop

# Интерактивный мониторинг процесс отсортированных по CPU
htop --sort-key=PERCENT_CPU

# Процессы конкретного пользователя
htop -u username
```

#### kill

```bash
# Завершить процесс по идентификатору процесса
kill PID

# Завершить процесс сигналом TERM
kill -TERM PID

# Завершить процесс сигналом KILL
kill -KILL PID
```

#### killall

```bash
# Завершить все процессы с определенным именем
killall process_name

# Завершить все процессы, принадлежащие определенному пользователю
killall -u username

# Завершить все процессы сигналом TERM
killall -TERM process_name
```

#### journalctl

-

#### systemctl

-

### Performance monitoring

#### nmon

```bash
# Мониторинг ресурсов
nmon

# Сохранить данные в файл
nmon -f -s 10 -c 144

# Мониторинг дисков
nmon -d
```

#### iostat

Контролирует ввод/вывод системы, наблюдая за временем активности устройств в зависимости от их средней скорости передачи. Отчеты iostat используются для изменения конфигов системы, чтобы повысить баланс ввода/вывода между физическими дисками.

```bash
# Статистика по использованию дисков
iostat

# Статистика по использованию процессора
iostat -c

# Статистика по сетевым интерфейсам
iostat -n
```

#### sar

```bash
# Статистика по использованию CPU
sar -u

# Статистика по использованию дисков
sar -d

# Статистика по использованию памяти
sar -r
```

#### vmstat

```bash
# Статистика использования памяти и процессора
vmstat

# Статистика по вводу/выводу
vmstat -d

# Статистика по памяти каждую секунду 5 раз
vmstat 1 5
```

### Network

#### traceroute

Используется для выявления проблем маршрутизации, задержки сети и потери пакетов.

```bash
# Маршрут сетевых пакетов до example.com
traceroute example.com

# Указание использовать IPv6
traceroute -6 example.com

# Предотвращение фрагментации пакетов
traceroute -F example.com

# Маршрут без изменения IP в имена
traceroute -n example.com

# Использовать указанный порт при трассировке маршрута
traceroute -p 80 example.com
```

#### ping

**Ping** - утилита командной строки, которая нужна для проверки подключения к другому компьютеру на уровне IP. Принцип работы очень простой: команда отправляет серию небольших ICMP пакетов данных на указанное устройство, а затем показывает время ответа.

```bash
# Пинговать сайт
ping example.com

# Выполнить пинг 5 раз
ping -c 5 example.com

# Пинговать с интервалом 2 секунды
ping -i 2 example.com
```

#### mtr

```bash
# Комбинация traceroute и ping для поиска более узких мест в маршрутах
mtr example.com

# Результаты без изменения IP в имена
mtr -n example.com

# Использовать реверсивный DNS при отображении результатов
mtr -r example.com
```

#### ufw

```bash
# Статус брандмауэра
ufw status

# Включить брандмауэр
ufw enable

# Запретить доступ к 22 порту
ufw deny 22
```

#### iptables

Осуществляется на основе набора правил, которые определяются в таблицах. `nftables` имеет схожий функционал. Цепочки – последовательности правил, которые применяются к пакетам. Действия – решения, которые принимает брандмауэр на основе правил для пакета. Команды – инструкции к действию, которые позволяют добавлять, удалять, сбрасывать все правила, задавать действия по умолчанию.

```bash
# Показать текущие правила
iptables -L

# Вывод таблиц с нумерацией правил
iptables -L -v -n --line-numbers

# Удаление правила из таблицы filter под номером 3
iptables -t filter -D INPUT 3

# Блокировать исходящие HTTP-соединения
iptables -t filter -A OUTPUT -p tcp --dport http -j DROP

# Включить логирование ядром пакетов, проходящих через цепочку INPUT, и добавлением к сообщению префикса DROP INPUT
iptables -t filters -A INPUT -j LOG --log-prefix "DROP INPUT"

# Разрешить входящие соединения на порт 80
iptables -A INPUT -p tcp --dport 80 -j ACCEPT

# Запретить доступ к определенной подсети
iptables -A INPUT -s 0.0.0.0/24 -j DROP

# Ограничение скорости трафика к новым SSH-соединениям
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m limit --limit 3/min -j ACCEPT

# Логирование всех отброшенных пакетов
iptables -A INPUT -j LOG --log-prefix “Dropped Packet: “ iptables -A INPUT -j DROP
```

#### tcpdump

```bash
# Перехват пакетов, проходящих через интерфейс eth0
tcpdump -i eth0

# Перехват пакетов, проходящих через порт 80 без изменения IP в имена
tcpdump -n port 80

# Перехвать 10 пакетов и запись их в файл
tcpdump -c 10 -w capture.pcap
```

#### ssh

-

#### dig

```bash
# Получить информацию о домене
dig example.com

# Получить только IP-адрес домена
dig +short example.com

# Использовать конкретный DNS-сервер для запроса
dig @0.0.0.0 example.com
```

#### scp

Использует шифрование через ssh соединение.

```bash
# Копирование файла на удаленный сервер
scp file user@example.com:/path

# Рекурсивное копирование каталога на удаленный сервер
scp -r folder/ user@example.com:/path

# Копирование файла с сервера на локалку
scp user@example.com:/path/file
```

#### nmap

```bash
# Основное сканирование IP-адреса
nmap 0.0.0.0

# Сканирование конкретного диапазона портов
nmap -p 1-1000 0.0.0.0

# Сканирование с указанием версии служб
nmap -sV 0.0.0.0

# Сканирование устройств в сети + пинг найденных устройств (-P)
nmap -sP 192.168.0.1/24

# Сканирование устройств в сети и их портов
nmap -Pn 192.168.0.1/24

# Брутфорс ssh с помощью скрипта
nmap --script ssh-brute -p 22 0.0.0.0

# Брутфорс http auth с помощью скрипта и вордлистов
nmap -p 80 --script http-brute --script-args "http-brute.hostname=0.0.0.0,http-brute.method=POST,http-brute.path=PATH,passdb=pwd.txt,userdb=usr.txt" -v 0.0.0.0

# Поиск скрытых файлов и каталогов
nmap --script http-enum 0.0.0.0

# 
nmap -A --top-ports 10000 0.0.0.0 -vv
```

### Troubleshooting

#### hping

```bash
# Традиционный пинг
hping3 -1 127.0.0.1

# SYN-флуд-атака
hping3 --flood -S -p 80 127.0.0.1

# UDP сканирование первых 100 портов
hping3 --udp -p 1-100 127.0.0.1
```

#### memdump

-

#### nslookup

-

#### masscan

-

#### arp

-

#### curl

cURL — это инструмент, который позволяет передавать файлы из оболочки по таким протоколам, как HTTP, HTTPS, FTP, SFTP, FTPS или SCP. Этот инструмент дает нам возможность удаленно контролировать и тестировать веб-сайты. Помимо содержимого удаленных серверов, мы также можем просматривать отдельные запросы, чтобы следить за взаимодействием клиента и сервера. Обычно cURL уже установлен в большинстве систем Linux.

```
curl -X POST -d “data=sample” https://example.com (Пример POST запроса)

curl -Iv https://example.com (Проверка конфига SSL/TLS)

curl -H “Cookie: session=12345” https://example.com (Отправка cookie)
```

#### dd

```bash
# Создание точного образа USB-накопителя и запись его в новый файл
dd if=/dev/sdb1 of=~/usb_drive_image.img bs=4096
```

### Backup and Restore

#### rsync

Быстрое и безопасное создание резервных копий файлов и папок в удаленном месте. Это особенно полезно для передачи больших объемов данных по сети, поскольку передаются только измененные части файла. Его также можно использовать для создания резервных копий локально или на удаленных серверах. Если нужно выполнить резервное копирование больших объемов данных по сети, Rsync может оказаться лучшим вариантом.

Чтобы включить автоматическую синхронизацию с помощью rsync, можно использовать комбинацию cron и rsync для автоматизации процесса синхронизации. Планирование запуска задания cron через регулярные промежутки времени гарантирует синхронизацию содержимого двух систем. Это может быть особенно полезно для организаций, которым необходимо синхронизировать данные на нескольких машинах.

Создание резервной копии локального каталога в резервной копии. Эта команда скопирует весь каталог (/path/to/mydirectory) на удаленный хост (backup_server) в каталог /path/to/backup/directory. Параметр archive (-a) используется для сохранения исходных атрибутов файла, таких как разрешения, временные метки и т. д., а использование подробного параметра (-v) обеспечивает подробный вывод хода операции rsync.

```bash
rsync -av /path/to/mydirectory user@backup_server:/path/to/backup/directory
```

В этом примере мы создаем резервную копию mydirectory на удаленном сервере backup_server, сохраняя исходные атрибуты файла, временные метки и разрешения, а также включаем сжатие (-z) для более быстрой передачи. Параметр --backup создает инкрементальные резервные копии в каталоге /path/to/backup/folder, а параметр --delete удаляет файлы с удаленного хоста, которых больше нет в исходном каталоге.

```bash
rsync -avz --backup --backup-dir=/path/to/backup/folder --delete /path/to/mydirectory user@backup_server:/path/to/backup/directory
```

Восстановление каталога с сервера резервного копирования в локальный каталог. Передача данных между локальным хостом и резервным сервером происходит через зашифрованное соединение SSH, что обеспечивает конфиденциальность и защиту целостности передаваемых данных. Этот процесс шифрования гарантирует, что данные защищены от любых потенциальных злоумышленников, которые в противном случае могли бы получить доступ к данным и изменить их без разрешения. Сам ключ шифрования также защищен комплексным набором протоколов безопасности, что еще больше затрудняет доступ к данным неавторизованному лицу.

```bash
rsync -av user@remote_host:/path/to/backup/directory /path/to/mydirectory
```

Безопасная передача резервной копии

```bash
rsync -avz -e ssh /path/to/mydirectory user@backup_server:/path/to/backup/directory
```

#### Deja Dup

Графический инструмент резервного копирования, который упрощает процесс резервного копирования, позволяя быстро и легко создавать резервные копии данных. Он предоставляет удобный интерфейс для создания резервных копий данных на локальном или удаленном носителе. Он использует Rsync в качестве бэкэнда, а также поддерживает шифрование данных.

#### duplicity

Графический инструмент резервного копирования, который обеспечивает пользователям комплексную защиту данных и безопасное резервное копирование. Он также использует Rsync в качестве бэкэнда и дополнительно предлагает возможность шифровать резервные копии и хранить их на удаленных носителях, таких как FTP-серверы, или в облачных службах хранения, таких как Amazon S3.

## Practice

### Practice_1

Практика утилит фильтрации текста. Практика выполняется с файлом `/etc/passwd`. Вывести содержимое файла и фильтровать:
	- Строки с именем пользователя root;
	- Столбец с именами пользователей;
	- Имя пользователя root и его UID;
	- Имя пользователя root и его UID, разделенные запятыми;
	- Имя пользователя root, установленная CLI и его UID, разделенные запятыми;
	- Все имена пользователей, их UID и CLi, разделенные запятыми;
	- Все имена пользователей, их UID и CLi, разделенные запятыми, кроме тех, что содержат nologin или false;
	- Все имена пользователей, их UID и CLi, разделенные запятыми, кроме тех, что содержат nologin, и подсчитать количество строк.

### Practice_2

```bash
vimtutor
```
- Запустить в терминале
