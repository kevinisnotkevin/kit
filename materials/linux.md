# Linux

## Contents

- [Linux](#linux)
    - [Contents](#contents)
    - [Introduction](#introduction)
    - [Components](#components)
    - [Architecture](#architecture)
    - [File System](#file-system)
        - [File System Management](#file-system-management)
        - [Linux file system](#linux-file-system)
        - [Disk Management](#disk-management)
        - [SWAP](#swap)
    - [Terminal Hotkeys](#terminal-hotkeys)
    - [File descriptor and redirections](#file-descriptor-and-redirections)
    - [Permission Management](#permission-management)
        - [SUID & SGID](#suid--sgid)
        - [Sticky Bit](#sticky-bit)
    - [Service and Process Management](#service-and-process-management)
        - [Background processes](#background-processes)
        - [Executing multiple commands](#executing-multiple-commands)
    - [Task Scheduling](#task-scheduling)
        - [systemd](#systemd)
        - [CRON](#cron)
            - [Operators](#operators)
            - [Special lines](#special-lines)
            - [Usage](#usage)
    - [Tools](#tools)
        - [System Information](#system-information)
            - [__whoami__](#whoami): Имя текущего пользователя
            - [__id__](#id): Членство пользователя в группах
            - [__hostname__](#hostname): Устанавливает или печатает имя текущего хоста
            - [__uname__](#uname): Основная информация об ОС и системном оборудовании
            - [__pwd__](#pwd): Рабочая директория
            - [__ifconfig__](#ifconfig): Устанавливает или печатает адреса сетевых интерфейсов, настройка параметров сетевых интерфейсов
            - [__ip__](#ip): Отображение и управление маршрутизацией, сетевыми устройствами, интерфейсами, туннелями
            - [__netstat__](#netstat): Сетевые подключения, таблицы маршрутизации, статистика сетевого интерфейса
            - [__ss__](#ss): Исследование сокетов
	        - [__ps__](#ps): Активные процессы
            - [__who__](#who): Кто вошел в систему
            - [__env__](#env): Устанавливает или печатает переменные среды
            - [__lsblk__](#lsblk): Список блочных устройств
            - [__lsusb__](#lsusb): Список USB устройств
	        - [__lsof__](#lsof): Список открытых файлов
            - [__lspci__](#lspci): Список PCI устройств
        - [User Management](#user-management)
            - [__sudo__](#sudo): Выполнение команды от имени другого пользователя
            - [__passwd__](#passwd): Смена пароля пользователя
            - [__useradd__](#useradd): Создание пользователя
            - [__userdel__](#userdel): Удаление пользователя
            - [__usermod__](#usermod): Изменение пользователя
            - [__groupadd__](#groupadd): Создание группы
            - [__groupdel__](#groupdel): Удаление группы
            - [__groupmod__](#groupmod): Изменение настроек группы
        - [Package Management](#package-management)
            - [__apt__](#apt): Высокоуровневый интерфейс командной строки для системы управления пакетами
            - [__aptitude__](#aptitude): Альтернатива apt
            - [__snap__](#snap): Управление snap-пакетами
            - [__gem__](#gem): Интерфейс RubyGems, менеджер пакетов Ruby
            - [__pip__](#pip): Управление Python-пакетами
            - [__git__](#git): Система контроля версий
            - [__dpkg__](#dpkg): Работа с DEB-пакетами
        - [Basic](#basic)
            - [__date__](#date): Системная дата
            - [__df__](#df): Информация об использовании дискового пространства
            - [__du__](#du): Определение объема файлов в директории
            - [__export__](#export): Экспорт переменных среды
            - [__find__](#find): Поиск файлов и директорий по фильтрам
            - [__free__](#free): Информация об оперативной памяти
            - [__gunzip__](#gunzip): Распаковка gzip архивов
            - [__gzip__](#gzip): Сжатие файлов алгоритмом LZ77
            - [__history__](#history): История введенных команд
            - [__locate__](#locate): Поиск файлов и папок
            - [__man__](#man): Справочная информация нужной команды
            - [__mount__](#mount): Монтирование файловой системы
            - [__reboot__](#reboot): Перезагрузка системы
            - [__service__](#service): Управление работой сервисов
            - [__shutdown__](#shutdown): Остановка системы
            - [__tar__](#tar): Сжатие и распаковка файлов
            - [__uptime__](#uptime): Время работы в системы
            - [__w__](#w): Список активных пользователей с момента запуска ОС
            - [__wget__](#wget): Прямая загрузка файлов через Интернет
            - [__whatis__](#whatis): Краткое описание искомой команды
            - [__which__](#which): Поиск расположения исполняемого файла
            - [__zip__](#zip): zip упаковка файлов
        - [Filter Contents](#filter-contents)
            - [__head__](#head): Первые строки файла
            - [__less__](#less): Постраничный просмотр файлов
            - [__more__](#more): Постраничный просмотр файлов
            - [__tail__](#tail): Последние строки файла
            - [__sort__](#sort): Сортировка строк файлов
            - [__grep__](#grep): Поиск и фильтрация текста
            - [__cut__](#cut): Вырезание разделов из каждой строки файлов
            - [__tr__](#tr): Перевод или удаление символов
            - [__column__](#column): Отображение в табличной форме
            - [__awk__](#awk): Поиск, обработка и фильтрация текста в файлах
            - [__sed__](#sed): Фильтрация и преобразование текста
            - [__uniq__](#uniq): Исключение повторяющихся строк
            - [__cat__](#cat): Объединение файлов, отображение содержимого файла
            - [__echo__](#echo): Отображение строки текста
            - [__fmt__](#fmt): Простое оптимальное форматирование текста
            - [__wc__](#wc): Подсчет количества символов новой строки, слов и байт
        - [Working with files](#working-with-files)
            - [__cd__](#cd): Изменение рабочей директории
            - [__chmod__](#chmod): Управление правами доступа
            - [__chown__](#chown): Управление владением
            - [__cp__](#cp): Копирование файлов и каталогов
            - [__ls__](#ls): Вывод содержимого директории
            - [__mv__](#mv): Перемещение или переименование файлов
            - [__mkdir__](#mkdir): Создание директории
            - [__rm__](#rm): Удаление файлов или директорий
            - [__touch__](#touch): Создание файлов
        - [Process Management](#process-management)
            - [__top__](#top): Отсортированный список текущих системных процессов
            - [__htop__](#htop): Интерактивный просмотр процессов
            - [__kill__](#kill): Уничтожение активного процесса
            - [__killall__](#killall): Уничтожение всех процессов, соответствующих заданным параметрам
            - [__journalctl__](#journalctl): Журнал сообщений
            - [__systemctl__](#systemctl): Управление службами
        - [Performance monitoring](#performance-monitoring)
            - [__nmon__](#nmon): Мониторинг производительности процессора, памяти, сети, дисков, файловой системы, ресурсов, микро раздела питания
            - [__iostat__](#iostat): Мониторинг статистики ввода-вывода системы для устройств и разделов
            - [__sar__](#sar): Генератор отчета с различной информацией об использовании и активности ресурсов в ОС
            - [__vmstat__](#vmstat): Статистика виртуальной памяти
		- [Network](#network)
            - [__traceroute__](#traceroute): Отображает пути, пройденные пакетами по IP-сети
            - [__ping__](#ping): Проверка доступности сетевого хоста
            - [__mtr__](#mtr): Инструмент, который объединяет возможности `traceroute` и `ping`
            - [__ufw__](#ufw): Управление брандмауэром
            - [__iptables__](#iptables): Управление входящими и исходящими пакетами данных
            - [__tcpdump__](#tcpdump): Перехвата трафика, мониторинг сетевой активности
            - [__ssh__](#ssh): SSH консоль
            - [__dig__](#dig): Получение ценной информации о доменах, IP-адресах, DNS-записях
            - [__scp__](#scp): Безопасное копирование файлов и каталогов между двумя системами
            - [__nmap__](#nmap): Сканирует открытые порты, запущенные службы и выявляет уязвимости
        - [Troubleshooting](#troubleshooting)
            - [__hping__](#hping): Инструмент для создания пакетов, который позволяет манипулировать и анализировать сетевые пакеты на детальном уровне. Используется для стресс-тестирования, тестирования брандмауэра, сканирования и генерации пакетов
            - [**memdump**](#memdump): Инструмент для криминалистического анализа системной памяти. Извлекает ценную информацию из оперативной памяти компьютера во время инцидента или расследования
            - [**nslookup**](#nslookup): Инструмент для запроса серверов системы доменных имен (DNS) для получения информации о хосте или разрешения IP-адреса
            - [**masscan**](#masscan): Инструмент для сканирования портов. Способен сканировать весь Интернет за несколько минут
            - [**arp**](#arp): Инструмент для отображения ARP таблицы
            - [__curl__](#curl): Инструмент, который передает данные с использованием различных сетевых протоколов. Используется для тестирования и взаимодействия с веб-сервисами, API-интерфейсами
            - [__dd__](#dd): Инструмент для дублирования данных и криминалистической визуализации, который используется для обнаружения доказательств и сохранения цифровых данных для восстановления временных рамок событий. Используется для создания точной копии диска или файла, получения удаленных файлов из образа диска
        - [Backup and Restore](#backup-and-restore)
            - [__rsync__](#rsync): Быстрое и безопасное создавание резервных копий файлов и папок в удаленном месте
            - [__Deja Dup__](#deja-dup): Графический инструмент резервного копирования на основе rsync
            - [__Duplicity__](#duplicity): Графический инструмент резервного копирования на основе rsync
    - [Practice](#practice)
        - [Task 1](#task\-1)
        - [Task 2](#task-2)

## Introduction

- __Дистрибутивы Линукс__: (distros) ОС, основанные на ядре Линукс (Например, Ubuntu, Fedora, CentOS, Red Hat, Debian). Используются в серверах, встроенных устройствах, настольных ПК, мобильных устройствах, облачных вычислениях;
- Распространенные дистрибутивы в кибербезопасности: ParrotOS, Raspberry Pi OS, BlackArch, Ubuntu, CentOS, Pentoo, Debian, Backbox;
- Основные различия дистрибутивов: включенные пакеты, пользовательский интерфейс, доступные инструменты;

- __Все есть файл__
- __Содержит множество небольших программ__
- __Возможность объединения программ для выполнения сложных задач__
- __Не привязан к GUI__
- __Данные конфигураций хранятся в текстовых файлах__

## Components

- __Bootloader__: Загрузчик управляет процессом загрузки ОС (Например, GRUB);
- __OS Kernel__: Код ядра управляет ресурсами системных устройств ввода-вывода на аппаратном уровне;
- __Daemons__: Фоновые службы обеспечивают правильную работу функций (Например, печать, планирование, мультимедиа);
- __OS Shell__: Интерфейс между пользователем и ОС (Например, Bash, Tcsh/Csh, Ksh, Zsh, Fish);
- __Graphics server__: Обеспечивает графическую подсистему X-server, которая позволяет графическим программам запускаться локально или удаленно в системе X-windowing;
- __Window manager__: GUI позволяет пользователю получать доступ к основным функциям и службам ОС (Например, GNOME, KDE, Mate, Unity, Cinnamon);
- __Utilities__: Программы выполняют определенные функции для пользователей или других программ.

## Architecture

- __Hardware__: Аппаратное обеспечение, периферийные устройства (Например, CPU, RAM, жесткий диск);
- __Kernel__: Ядро предоставляет каждому процессу собственные виртуальные ресурсы и предотвращает конфликты между различными процессами;
- __Shell__: Интерфейс командной строки (Command-line interface, CLI) позволяет пользователю вводить команды для выполнения функций ядра;
- __System utility__: Предоставляет пользователю все функциональные возможности ОС.

## File System

### File System Management

- Управление файловой системой - процесс создания и поддержки хранилищ данных на диске или других устройствах хранения данных. Линукс поддерживает различные файловые системы (ext2, ext3, ext4, XFS, Btrfs, NTFS), которые используются в различных ситуациях в зависимости от требований приложения или пользователя.
- Файловая система Линукс основана на файловой системе Unix, которая представляет собой иерархическую структуру, состоящую из различных компонентов. Наверху этой структуры находится таблица inode, основа всей файловой системы. Таблица inode — это таблица информации, связанной с каждым файлом и каталогом в системе Линукс. inodes содержат метаданные о файле или каталоге, такие как его разрешения, размер, тип, владелец и т. д. Таблица inode похожа на БД с информацией о каждом файле и каталоге в системе Линукс, что позволяет ОС быстро получать доступ к файлам и управлять ими. Файлы могут храниться в файловой системе Линукс одним из двух способов: файлы, каталоги и ссылки на другие файлы/каталоги. Каталоги используются для хранения набора файлов. Символические ссылки используются для быстрого доступа к файлам, расположенным в разных частях файловой системы. 

### Linux file system

- __/__: Директория верхнего уровня является корневой файловой системой и содержит все файлы, необходимые для загрузки ОС до монтирования других файловых систем, а также файлы, необходимые для загрузки других файловых систем. После загрузки все остальные файловые системы монтируются в стандартные точки монтирования как подкатологи корня;
- __bin__: Двоичные файлы многих основных программ, которые должны присутствовать при монтировании системы;
- __sbin__: Исполняемые файлы, используемые для системного администрирования;
- __boot__: Файлы для загрузки системы (Статический загрузчик, исполняемый файл ядра и файлы, необходимые для загрузки ОС);
- __dev__: Файлы устройств для облегчения доступа к каждому аппаратному устройству, подключенному к системе;
- __etc__: Файлы конфигурации локальной системы и установленных приложений (Например, файл паролей или файлы настроек сетей);
- __home__: Домашний каталог пользователей;
- __lib__: Файлы библиотек, необходимые двоичным файлам в каталогах bin, sbin для загрузки системы;
- __media__: Место монитрования внешних съемных носителей (Например, USB drives);
- __mnt__: Временная точка монтирования для обычных файловых систем. Используется администратором системы для ручного монтирования файловых систем;
- __opt__: Используется проприентарным ПО для хранения дополнительных пакетов ПО;
- __proc__: Автоматически сгенерированные файлы системы, которые содержат информацию о запущенных процессах и состоянии ядра;
	- __proc/cpuinfo__: Информация о процессоре;
	- __proc/interrupts__: Информация о прерываниях;
	- __proc/swaps__: Информация о файлах подкачки;
	- __proc/version__: Информация о версии ядра;
	- __proc/meminfo__: Информация об использовании памяти;
	- __proc/netdev__: Информация о сетевых интерфейсах и их статистики;
	- __proc/mounts__: Информация о смонтированных файловых системах;
- __root__: Домашняя директория для пользователя root;
- __run__: Данные программ во время выполнения (Например, сокеты, ID процессов);
- __srv__: Специфичные данные, обслуживаемые этой системой (Например, файлы Apache);
- __sys__: Виртуальный диалог, представляющий информацию о системе;
- __tmp__: Временные файлы, которые удаляются при перезагрузке системы;
- __usr__: Исполняемые файлы пользовательских программ;
- __var__: Файлы переменных данных (Например, файлы журналов, кэш программ, cron).

### Disk Management

- Управление дисками включает управление физическими устройствами хранения данных (SSD, HDD, сьемные устройства хранения данных).
- __fdisk__ - основная утилита для управления дисками, которая позволяет создавать, удалять и управлять разделами диска. Также отображает информацию о таблице разделов, их размеры и типы. Разделение диска позволяет разделить физическое пространство на отдельные разделы для форматирования в различные файловые системы.
- Монтирование (mounting) - подключение диска к определенному каталогу, что делает его доступным для иерархии файловой системы. После монтирования диска, к нему можно получить доступ и управлять также, как и любым другим каталогом в системе. 
- Нельзя отключить монтированную файловую систему, если она имеет запущенный процесс. Посмотреть список открытых файлов [__lsof__](#lsof).
- Файл __/etc/fstab__ содержит информацию обо всех файловых системах, смонтированных в системе, включая параметры автоматического монтирования во время загрузки и другие параметры монтирования. Чтобы автоматически размонтировать файловую систему при завершении работы, необходимо добавить запись с параметром __noauto__ в файл __/etc/fstab__.

### SWAP

- __Swapping__ - ​процесс ​переноса ядром неактивных страниц памяти в _swap space_, освобождая физическую память для использования активными процессами, когда в системе заканчивается физическая память.
- __Swap space__ можно создать либо во время установки ОС, либо в любое время после нее с помощью команд __mkswap__ и __swapon__.
- Команда __mkswap__ используется для настройки _swap space_ Линукс на устройстве или в файле, а команда __swapon__ используется для активации _swap space_. Размер _swap space_ зависит от личных предпочтений и зависит от объема физической памяти, установленной в системе, и типа использования, которому будет подвергаться система. При создании _swap space_ важно убедиться, что оно размещено в выделенном разделе или файле, отдельном от остальной файловой системы. Это помогает предотвратить фрагментацию _swap space_ и гарантирует, что в системе будет достаточно _swap space_, когда это необходимо. Также важно убедиться, что _swap space_ зашифровано, поскольку конфиденциальные данные могут временно храниться в _swap space_.
- Помимо использования в качестве расширения физической памяти, _swap space_ также можно использовать для спящего режима, который представляет собой функцию управления питанием, которая позволяет системе сохранять свое состояние на диск, а затем выключаться вместо полного выключения. При последующем включении системы она может восстановить свое состояние из _swap space_, вернувшись в состояние, в котором она находилась до выключения.

## Terminal Hotkeys

- __CTRL+C__: Прерывает выполнение текущей команды;
- __CTRL+D__: Завершает текущий процесс;
- __CTRL+Z__: Приостанавливает выполнение процесса (Продолжить - `fg`);
- __CTRL+A__: Перемещает курсор в начало строки;
- __CTRL+E__: Перемещает курсор в конец строки;
- __CTRL+U__: Удаляет текст от курсора до начала строки;
- __CTRL+K__: Удаляет текст от курсора до конца строки;
- __CTRL+L__: Очищает экран;
- __CTRL+R__: Ищет вводимую строку в истории команд;
- __CTRL+W__: Удаляет слово перед курсором;
- __CTRL+Y__: Вставляет удаленный текст;
- __CTRL+P__: Перемещает курсор на одну строку вверх в истории команд;
- __CTRL+N__: Перемещает курсор на одну строку вниз в истории команд;
- __CTRL+T__: Меняет местами символы до и после курсора;
- __CTRL+F__: Перемещает курсор на одно слово вперед;
- __CTRL+B__: Перемещает курсор на одно слово назад;
- __CTRL+D__: Удаляет слово после курсора;
- __Alt+.__: Вставляет поледний аргумент предыдущей команды;
- __Tab__: Автодополнение имен файлов и команд;
- __CTRL+Alt+Del__: Перезагрузка системы.

## File descriptor and redirections

Файловый дескриптор — натуральное число (идентификатор), закреплённое за определённым потоком ввода-вывода. В Linux библиотека libc открывает для каждого запущенного приложения (процесса) 3 файл дескриптора, с номерами 0, 1, 2:
- Файл дескриптор 0 называется STDIN и ассоциируется с вводом данных у приложения;
- Файл дескриптор 1 называется STDOUT и используется приложениями для вывода данных, например командами print;
- Файл дескриптор 2 называется STDERR и используется приложениями для вывода данных, сообщающих об ошибке.

```bash
find /etc/ -name shadow 2>/dev/null > results.txt
# Явное перенаправление стандартного вывода:
find /etc/ -name shadow 2> stderr.txt 1> stdout.txt
```
- Перенаправление файлового дескриптора ошибок на нулевое устройство, которое отбрасывает все данные и перенаправление файлового дескриптора вывода в файл results.txt. `>` создает или перезаписывает файл, `>>` добавляет в файл.

```bash
cat < stdout.txt
```
- Перенаправление стандартного ввода.

```bash
find /etc/ -name *.conf 2>/dev/null | grep systemd | wc -l
```
- Перенаправление результата работы функции find в функцию grep, а затем перенаправление в функцию wc.

## Permission Management

![](materials/images/permissions.png)

- Разрешения назначаются пользователям и группам. Каждый пользователь может быть членом различных групп, и членство в этих группах дает пользователю особые дополнительные разрешения. 
- Каждый файл и каталог принадлежит определенному пользователю и определенной группе. 
- При создании новых файлов или каталогов, они принадлежат группе, к которой принадлежит пользователь, и пользователю.
- Для перемещения по каталогу необходимы разрешения на выполнение, независимо от уровня доступа пользователя. Разрешения на выполнение каталога не позволяют пользователю выполнять или изменять какие-либо файлы или содержимое в каталоге, а только просматривать и получать доступ к содержимому каталога.
- Чтобы изменить содержимое каталога (создать, удалить или переименовать файлы и подкаталоги), пользователю необходимы права на запись в каталоге.
- Вся система разрешений основана на восьмеричной системе счисления, и файлу или каталогу можно назначить три различных типа разрешений (`r` - Read, `w` - Write, `x` - Execute).
- Команда [chmod](#chmod) позволяет изменить разрешения (u — владелец, g — группа, o — другие, a — все пользователи), `+` или `-` для добавления и удаления назначенных разрешений.

### SUID & SGID

Помимо назначения прямых разрешений для пользователей и групп, также можно настроить специальные разрешения для файлов, установив биты Set User ID (SUID) и Set Group ID (SGID). Эти биты SUID/SGID позволяют, например, пользователям запускать программы с правами другого пользователя. Администраторы часто используют это, чтобы предоставить своим пользователям особые права для определенных приложений или файлов. Вместо буквы «x» используется буква «s». При выполнении такой программы используется SUID/SGID владельца файла.

Если администратор установит бит SUID для «journalctl», любой пользователь сможет запустить оболочку от имени пользователя root.

### Sticky Bit

Sticky Bit — это тип прав доступа к файлам, которые можно установить для каталогов. Этот тип разрешений обеспечивает дополнительный уровень безопасности при контроле удаления и переименования файлов в каталоге. Обычно он используется в каталогах, которые используются несколькими пользователями, чтобы предотвратить случайное удаление или переименование одним пользователем файлов, которые важны для других.

Например, в общем домашнем каталоге, где несколько пользователей имеют доступ к одному и тому же каталогу, системный администратор может установить Sticky Bit для каталога, чтобы гарантировать, что только владелец файла, владелец каталога или пользователь root может удалять или переименовывать файлы в каталоге. Это означает, что другие пользователи не могут удалять или переименовывать файлы в каталоге, поскольку у них нет необходимых разрешений. Это обеспечивает дополнительный уровень безопасности для защиты важных файлов, поскольку только те, у кого есть необходимый доступ, могут удалять или переименовывать файлы. Установка Sticky Bit для каталога гарантирует, что только владелец, владелец каталога или пользователь root смогут изменять файлы в каталоге.

Когда для каталога установлен Sticky Bit, он обозначается буквой «t» в разрешении на выполнение разрешений каталога. Например, если каталог имеет разрешения «rwxrwxrwt», это означает, что установлен Sticky Bit, что дает дополнительный уровень безопасности, чтобы никто, кроме владельца или пользователя root, не мог удалять или переименовывать файлы или папки в каталоге.

Если Sticky Bit написан с заглавной буквы (T), то это означает, что все остальные пользователи не имеют разрешений на выполнение (x) и, следовательно, не могут видеть содержимое папки и запускать из нее какие-либо программы. Sticky Bit в нижнем регистре (t) — это Sticky Bit, в котором установлены разрешения на выполнение (x).

## Service and Process Management

Существует два типа служб: __внутренние__, которые требуются при запуске системы и которые, например, выполняют задачи, связанные с оборудованием, и __пользовательские__, которые обычно включают в себя все серверные службы. Такие службы работают в фоновом режиме без какого-либо взаимодействия с пользователем. Их также называют демонами и обозначают буквой «d» в конце имени программы, например, sshd или systemd.

Большинство дистрибутивов Linux перешли на systemd. Этот демон представляет собой инициализирующий процесс, запускаемый первым, и поэтому имеет PID 1. Этот демон контролирует и обеспечивает упорядоченный запуск и остановку других служб. Всем процессам присвоен PID, который можно просмотреть в /proc/ с соответствующим номером. Такой процесс может иметь идентификатор родительского процесса (PPID), и если имеет, то он называется дочерним процессом.

Процесс может находиться в следующих состояниях:
- Running;
- Waiting (ожидание события или системного ресурса);
- Stopped;
- Zombie (остановлен, но запись в таблице процессов все еще есть).

Чтобы взаимодействовать с процессом, мы должны послать ему сигнал. Мы можем просмотреть все сигналы с помощью `kill -l`. Из них часто используемые:
- __1 SIGHUP__: Отправляется процессу, когда терминал, который им управляет, закрывается;
- __2 SIGINT__: Отправляется, когда пользователь нажимает `Ctrl+C` в управляющем терминале, чтобы прервать процесс;
- __3 SIGQUIT__: Отправляется, когда пользователь нажимает `Ctrl+D` для выхода;
- __9 SIGKILL__: Немедленное завершение процесса без операций очистки;
- __15 SIGTERM__: Завершение программы;
- __19 SIGSTOP__: Остановить программу. С этим уже невозможно справиться;
- __20 SIGTSTP__: Отправляется, когда пользователь нажимает `Ctrl+Z`, чтобы запросить приостановку службы. Пользователь может справиться с этим позже.

### Background processes

Иногда необходимо перевести процесс в фоновый режим, чтобы продолжить использование текущего сеанса для взаимодействия с системой или запуска других процессов. Перевести процесс в фоновый режим можно с помощью `CTRL+Z`, указания `&` в конце командной строки. `bg` отображает все фоновые процессы. `fg <id>` позволяет вывести фоновый процесс в основной поток. Фоновые процессы позволяют использовать тот же сеанс оболочки, не дожидаясь, пока процесс сначала завершится. Как только сканирование или процесс завершат свою работу, терминал уведомит нас о завершении процесса.

### Executing multiple commands

Способы запуска нескольких команд разделителями:
- __;__: Игнорирует код возврата предыдущей команды;
- __&&__: Если код возврата предыдущей команды не 0, то выполнение команд прерывается;
- __|__: Зависит не только от корректной и безошибочной работы предыдущих процессов, но и от результатов предыдущих процессов.

## Task Scheduling

Планирование задач позволяет пользователям планировать и автоматизировать запуск задач в определенное время или с определенной частотой без необходимости запускать их вручную.

Примеры использования: автоматическое обновление программного обеспечения, запуск сценариев, очистка баз данных и автоматизация резервного копирования.

Пользователи могут планировать регулярные и повторяющиеся задачи, чтобы обеспечить их регулярное выполнение. Кроме того, можно настроить оповещения для отображения при возникновении определенных событий или для связи с администраторами или пользователями.

### systemd

Задачи можно планировать с помощью systemd. Чтобы создать таймер для systemd, нужно создать каталог, в котором будет храниться скрипт таймера.

```bash
sudo mkdir /etc/systemd/system/mytimer.timer.d
sudo vim /etc/systemd/system/mytimer.timer
```

Далее нужно создать скрипт, настраивающий таймер. Скрипт должен содержать следующие опции: «Unit, «Timer» и «Install». Опция «Unit» определяет описание таймера. Опция «Timer» определяет, когда запускать таймер и когда его активировать. Наконец, опция «Install» указывает, где установить таймер.

```bash
[Unit]
Description=My Timer

[Timer]
OnBootSec=3min
OnUnitActiveSec=1hour

[Install]
WantedBy=timers.target
```

Например, если мы хотим запустить скрипт только один раз после загрузки системы, следует использовать настройку OnBootSec в таймере. Однако если мы хотим, чтобы сценарий запускался регулярно, нам следует использовать OnUnitActiveSec, чтобы система запускала сценарий через регулярные промежутки времени. Далее нам нужно создать наш сервис.

```bash
sudo vim /etc/systemd/system/mytimer.service
```

Здесь задаем описание и указываем полный путь к скрипту, который хотим запустить. «multi-user.target» — это система единиц, которая активируется при запуске обычного многопользовательского режима. Он определяет службы, которые должны запускаться при обычном запуске системы.

```bash
[Unit]
Description=My Service

[Service]
ExecStart=/full/path/to/my/script.sh

[Install]
WantedBy=multi-user.target
```

После этого мы должны позволить systemd снова прочитать папки, чтобы включить изменения.

```bash
sudo systemctl daemon-reload
```

После этого мы можем использовать systemctl, чтобы запустить службу вручную и включить автозапуск.

```bash
sudo systemctl start mytimer.service
sudo systemctl enable mytimer.service
```

### CRON

CRON позволяет выполнять задачи в определенное время или через определенные промежутки времени. Нужно создать сценарий, а затем указать демону CRON, чтобы он вызывал его в определенное время.

Чтобы настроить демон CRON, нужно сохранить задачи в файле с именем crontab, а затем сообщить демону, когда запускать задачи.

```
[Minute] [Hour] [Day] [Month] [Weekday] [Command to be executed]
```

- __Minute__: (0-59) Определяет, в течение какой минуты задача должна быть выполнена.
- __Hour__: (0-23) Определяет, в какой час должна быть выполнена задача.
- __Day__: (1-31) Определяет, в какой день месяца должна выполняться задача.
- __Month__: (1-12) Определяет, в каком месяце задача должна быть выполнена.
- __Weekday__: (0-7) Определяет, в какой день недели должна выполняться задача.

#### Operators

- __`*`__: Все значения;
- __`,`__: Разделяет отдельные значения;
- __`-`__: Диапазон значений;
- __`/`__: Разделяет значения на шаги.

#### Special lines

- __`@reboot`__: every reboot.
- __`@hourly`__: once every hour - same as `0 * * * *`.
- __`@daily`__: once every day - same as `0 0 * * *`.
- __`@midnight`__: once every midnight - same as `@daily`.
- __`@weekly`__: once every week - same as `0 0 * * 0`.
- __`@monthly`__: once every month - same as `0 0 1 * *`.
- __`@yearly`__: once every year - same as `0 0 1 1 *`.

#### Usage

```bash
# Every 15 mins
*/15 * * * *

# Every 2 hours
0 */2 * * *

# Every week Mon-Sat at 6pm
0 18 * * 0-6

# Every Sat and Sun on 2:10am
10 2 * * 6,7

# Adding tasks easily
echo “@reboot echo hi” | crontab

# Open in editor - optional for another user
crontab -e [-u user]

# List tasks - optional for another user
crontab -l [-u user]

# Delete crontab file - optional for another user
crontab -r [-u user]

# «Обновление системы» должно выполняться каждые шесть часов. На это указывает запись */6 в столбце часов. Задачу выполняет скрипт update_software.sh, путь к которому указан в последнем столбце.
* */6 * * /update_software.sh

# Сценарии выполнения задач должны выполняться каждый первый день месяца в полночь. На это указывают записи 0 и 0 в столбцах минут и часов и 1 в столбце дней месяца. Задачу выполняет скрипт run_scripts.sh, путь к которому указан в последнем столбце.
0 0 1 * * /run_scripts.sh

# Третья задача, «Очистка базы данных», должна выполняться каждое воскресенье в полночь. Это определяется записями 0 и 0 в столбцах минут и часов и 0 в столбце дней недели. Задачу выполняет скрипт clean_database.sh, путь к которому указан в последнем столбце.
0 0 * * 0 /clean_database.sh

# Резервное копирование должно выполняться каждое воскресенье в полночь. На это указывают записи 0 и 0 в столбцах минут и часов и 7 в столбце дней недели. Задачу выполняет скрипт backup.sh, путь к которому указан в последнем столбце.
0 0 * * 7 /backup.sh
```

## Tools

### System Information

#### whoami

```bash
# Имя текущего пользователя
whoami
```

#### id

-

#### hostname

-

#### uname

```bash
# Архитектура процессора
uname -m
# Версия ядра ОС
uname -r
```

#### pwd

```bash
# Полный путь текущей директории
pwd
```

#### ifconfig

```bash
# Информация о всех сетевых устройствах
ifconfig

# Информация о конкретном сетевом устройстве
ifconfig eth0

# Отключить сетевой интерфейс
ifconfig eth0 down

# Включить сетевой интерфейс
ifconfig eth0 up

# Выставить интерфейсу eth0 IP-адрес и маску подсети
ifconfig eth0 192.168.1.1 netmask 255.255.255.0
```

#### ip

```bash
# Информация о сетевых интерфейсах
ip a

# Таблица маршрутизации
ip route
```

#### netstat

```bash
# Отобразить все установленные сетевые соединения по TCP, UDP без разрешения имен в IP-адреса и PID и имена процессов, обеспечивающих соединения
netstat -tulnp

# Таблица маршрутизации
netstat -r

# Количество активных соединений на порту 80
netstat -an | grep :80 | sort
```

#### ss

-

#### ps

```bash
# Все процессы
ps aux

# Процессы включающие аргументы командной строки
ps -AFl

# Все процессы потока в древовидном режиме
ps -AlFH

# Процессы по иерархии
ps -e -o pid,args --forest

# Список процессов по владельцу
ps -U user -u user u

# Топ 5 процессов по использованию памяти
ps auxf | sort -nr -k 4 | head -5
```

#### who

-

#### env

```bash
# Текущие переменные окружения
env

# Установить переменную окружения
env VARIABLE=value

# Удалить переменную окружения
env -u VARIABLE
```

#### lsblk

-

#### lsusb

-

#### lsof

```bash
# Показать все открытые файлы и сокеты
lsof

# Показать открытые файлы для определенного процесса
lsof -p PID

# Найти процесс, который использует определенный порт
lsof -i :port_number
```

#### lspci

-

### User Management

#### sudo

```bash
# Обновить список пакетов
sudo apt update

# Удалить все файлы журналов
sudo rm -rf /var/log

# Редактировать файл конфигурации nginx
sudo nano /etc/nginx/nginx.conf
```

#### passwd

```bash
# Сменить пароль текущего пользователя
passwd

# Сменить пароль пользователя
passwd username
```

#### useradd

```bash
# Создать пользователя user1, назначить домашний каталог /home/user1, назначить shell /bin/bash, включить в группу admin и добавить комментарий Comment
useradd -c "Comment" -g admin -d /home/user1 -s /bin/bash user1

# Создать пользователя user1
useradd user1

# Создать пользователя с домашним каталогом
useradd -m user1

# Создать пользователя и добавить в группу sudo
useradd -G sudo user1
```

#### userdel

```bash
# Удалить пользователя и его каталог
userdel -r user1
```

#### usermod

```bash
# Добавить пользователя в группу sudo
usermod -aG sudo user1

# Изменение атрибутов пользователя
usermod -c "User FTP" -g system -d /ftp/user1 -s /bin/nologin user1
```

#### groupadd

```bash
# Создать группу
groupadd name

# Создать системную группу
groupadd -r name
```

#### groupdel

```bash
# Удалить группу
groupdel name

# Удалить группу без предупреждения
groupdel -f name

# Удалить группу, включая связанные файлы и каталоги
groupdel --remove name

# Удалить группу и перенести файлы в другую группу
groupdel --move-to=backupgroup name
```

#### groupmod

```bash
# Изменить название группы
groupmod -n newname oldname

# Изменить GID группы
groupmod -g 1000 name

# Добавить пользователей в группу
groupmod -m -g name user1,user2

# Исключить пользователей из группы
groupmod -g name user1,user2
```

### Package Management

#### apt

```bash
# Обновление информации о пакетах из репозиториев
apt update

# Обновление всех пакетов
apt upgrade

# Очистка локального репозитория
apt clean

# Удаление ранее скачанных, но более ненужных пакетов
apt autoremove

# Удаление пакета из системы, с сохранением конфигурационных файлов
apt remove

# Удаление пакета со всеми зависимостями
apt purge

# Установка пакета
apt install

# Проверить целостность зависимостей
apt check
```

#### aptitude

-

#### snap

-

#### gem

-

#### pip

-

#### git

-

#### dpkg

```bash
# Установить пакет
dpkg -i package.deb

# Удалить пакет из системы
dpkg -r package_name

# Показать все пакеты, установленные в систему
dpkg -l

# Найти пакет, содержащий в имени httpd
dpkg -l | grep httpd

# Информация о конкретном пакете
dpkg -s package_name

# Вывести список файлов, входящих в пакет, установленный в систему
dpkg -L package_name

# Отобразить список файлов, входящих в пакет, который еще не установлен в систему
dpkg --contents package.deb

# Найти пакет, в который входит указанный файл
dpkg -S /bin/ping
```

### Basic

#### date

```bash
# Текущая дата
date

# Установить системные дату и время ММДДЧЧммГГГГюСС (МесяцДеньЧасМинутыГод.Секунды)
date 123123592024.00

# Форматированный вывод текущей даты
date "+%Y-%m-%d %H:%M:%S %A %B %Y"

# Установка даты и времени через форматированный ввод
date --set="2024-04-28 09:30:00"
```

#### df

```bash
# Информация о дисках системы
df

# Информация о текущем диске в удобном формате
df -h .
```

#### du

```bash
# Размер файлов и каталогов в текущем каталоге, отсортированных по размеру
du -ah | sort -rh

# Размер файла
du file

# Размеры всех файлов и каталогов в каталоге
du -sh *

# Размер каждого подкаталога в текущем каталоге
du -h --max-depth=1
```

#### export

```bash
# Экспортировать переменную окружения
export VARIABLE=value

# Проверить экспортированные перменные окружения
export

# Сбросить экспортированную переменную окружения
export -n VARIABLE
```

#### find

```bash
# Найти файлы и каталоги с именем file1 в каталоге /
find / -name file1

# Найти файлы и каталоги с владельцем user1 в каталоге /
find / -user user1

# Найти файлы и каталоги, имена которых оканчиваются на .bin в каталоге /
find / -name "*.bin"

# Найти файлы в каталоге /, время последнего обращения к которым более 100 дней
find / -type f -atime +100

# Найти файлы в каталоге /, созданные или измененные в течение последних 10 дней
find / -type f -mtime -10

# Найти файлы и каталоги в каталоге /, размер которых больше 1 мбайта
find / -size +1M
```

#### free

```bash
# Информация об оперативной памяти
free

# Информация об оперативной памяти каждую секунду
free -s 1
```

#### gunzip

```bash
# Распаковать файл
gunzip file.gz

# Распаковать файл и вывести в файл uncompressed_file
gunzip -c file.gz > uncompressed_file
```

#### gzip

```bash
# Сжать файл и создать file.gz
gzip file
```

#### history

```bash
# Последние 20 выполненных команд
history 20

# Очистить историю команд
history -c
```

#### locate

```bash
# Найти файл по названию без учета регистра
locate -i file.txt

# Обновление БД для поиска файлов
updatedb
```

#### man

```bash
# Руководство по команде ls
man ls

# Описание системного вызова fork
man 2 fork
```

#### mount

```bash
# Монтировать раздел hda2 в точку монтирования /mnt/hda2
mount /dev/hda2 /mnt/hda2

# Монтировать ISO-образ в каталог /mnt/cdrom
mount -o loop file.iso /mnt/cdrom

# Все примонтированные файловые системы, включая имя устройства, тип файловой системы, точка монтирования, параметры.
mount

# Отключение файловой системы, а именно смонтированного ISO-образа.
unmount /mnt/cdrom
```

#### reboot

```bash
# Перезагрузка системы
reboot
```

#### service

```bash
# Запуск сервиса nginx
service nginx start

# Статус сервиса ssh
service ssh status

# Остановить сервис Apache2
service apache2 stop
```

#### shutdown

```bash
# Остановка системы
shutdown -h now

# Запланированная остановка системы
shutdown -h hours:minutes &

# Отмена запланированной остановки системы
shutdown -c

# Перезагрузка системы через 5 минут
shutdown -r +5
```

#### tar

```bash
# Создать сжатый архив из каталога folder
tar -czvf archive.tar.gz folder/

# Распаковать архив
tar -xvf archive.tar

# Показать содержимое архива без распаковки
tar -tf archive.tar
```

#### uptime

```bash
# Текущее время, время работы системы, количество пользователей, средняя нагрузка
uptime
```

#### w

```bash
# Отображение пользователей в системе и их действия
w
```

#### wget

Альтернативой Curl является инструмент wget. С помощью этого инструмента можно загружать файлы с FTP или HTTP-серверов прямо из терминала, и он служит хорошим менеджером загрузок.

```bash
# Загрузка файла file.tar.gz с сайта
wget http://example.com/file.tar.gz

# Рекурсивная загрузка всего сайта
wget -r http://example.com

# Загрузка файла и сохранение с указанным именем
wget -0 newfile.html http://example.com
```

#### whatis

```bash
# Краткое описание команды python
whatis python
```

#### which

```bash
# Полный путь к исполняемому файлу python
which python
```

#### zip

```bash
# Создание архива из содержимого каталога folder
zip -r archive.zip folder/

# Создание зашифрованного архива с файлом file.txt
zip -e secure.zip file.txt

# Распаковка архива в текущий каталог
unzip archive.zip
```

### Filter Contents

#### head

```bash
# Вывести первые 10 строк файла
head file

# Вывести первые 20 строк файла
head -n 20 file
```

#### less

```bash
# Содержимое файла с пролистыванием
less file

# Поиск слова в файле
less file
/pattern
```

#### more

-

#### tail

```bash
# Последние строки системного журнала
tail /var/log/syslog

# Последние 20 строк журнала доступа Nginx
tail -n 20 /var/log/nginx/access.log
```

#### sort

```bash
# Сортировка по алфавиту
sort file

# Сортировка двух файлов
sort file1 file2

# Сортировка файлов, отображая только повторяющиеся строки
sort file1 file2 | uniq -d

# Сортировка файлов, отображая только уникальные строки
sort file1 file2 | uniq -u

# Сортировка в обраном порядке
sort -nr file
```

#### grep

```bash
# Поиск строк, начинающихся на pattern в файле file
grep ^pattern file

# Поиск строк, содержащих pattern во всех файлах каталога dir
grep pattern -R /dir

# Поиск строк, содержащих pattern
grep "pattern" file

# Поиск строк, содержащих password без учета регистра
grep -i “password” /var/log/syslog

# Поиск IP-адресов в журнале доступа к веб-серверу
grep -E -o “([0-9]{1,3}\.){3}[0-9]{1,3}” /var/log/apache2/access.log

# Поиск строк, содержащих слово my или false. Флаг -E позволяет использовать регулярные выражения
grep -E "(my|false)" /etc/passwd

# Поиск строки, содержащей слова my и false
grep -E "(my.*false)" /etc/passwd
```

#### cut

```bash
# Вырезать первое поле из файла, разделенного запятыми
cut -d',' -f1 file.csv

# Вырезать символы 1-5 с каждой строки
cut -c1-5 file
```

#### tr

```bash
# Преобразовать все символы в файле в верхний регистр
tr '[:lower:]' '[:upper:]' < file

# Преобразововать символы строки hello в верхний регистр
echo "hello" | tr '[:lower:]' '[:upper:]'
```

#### column

-

#### awk

Чаще всего используется для выборки из колонок.

```bash
# Вывести первый столбец из файла
awk '{print $1}' file

# Разделить строки с помощью разделителя : и вывести первый и третий столбцы
awk -F: '{print $1, $3}' /etc/passwd

# Вывод нечетных строк файла
cat file | awk 'NR%2==1'
```

#### sed

```bash
# Заменить первое вхождение old на new в каждой строке файла
sed 's/old/new/' file

# Вывод 5-10 строк из файла
sed -n '5,10p' file

# Удалить пустые строки файла
sed '/^$/d' file

# Удалить первую строку файла
sed -r '1d' file

# Удалить str из текста файла
sed -e 's/str//g' file

# Заменить последовательность нулей одним нулем
sed -e 's/0*/0/g' file
```

#### uniq

```bash
# Удалить дублирующиеся последовательные строки
uniq file

# Подсчитать количество каждой уникальной строки
uniq -c file
```

#### cat

```bash
# Вывод содрежимого файла на экран
cat file

# Объединение двух файлов в один
cat file1 file2 > file3
```

#### echo

```bash
# Вывод строки на экран
echo "Hello"

# Очистка файла, запись строки в файл
echo "Hello" > file

# Запись строки в конец файла
echo "Hello" >> file

# Вывод значение переменной окружения
echo $PATH
```

#### fmt

```bash
# Форматирование файла для вывода с максимальной шириной строки 80 символов
fmt -w 80 file
```

#### wc

```bash
# Посчитать количество строк в файле
wc -l file

# Посчитать количество слов в строке
echo "Hello, world!" | wc -w
```

### Working with files

#### cd

```bash
# Переход в предыдущую директорию
cd -

# Переход в домашнюю директорию текущего пользователя
cd ~

# Переход в указанную директорию
cd /path/to/file

# Переход в на уровень выше
cd ../
```

#### chmod

```bash
# Аналогично chmod 777 dir1. Выдать права ugo(User Group Other)+rwx(Read Write eXecute) на директорию dir1
chmod ugo+rwx dir1

# Забрать права у группы и всех остальных все права для директории dir1
chmod go-rmw dir1

# Назначить SUID-бит файлу file1. Дает возможность любому пользователю запускать на выполнение файл с полномочиями владельца файла
chmod u+s file1

# Назначить SGID-бит для файла file1
chmod g+s file1

# Снять SGID-бит для файла file1
chmod g-s file1

# Назначить STIKY-бит для файла file1. Позволяет удалять только владельцам
chmod o+t file1

# Снять STIKY-бит для файла file1
chmod o-t file1

# Рекурсивная установка прав для всех каталогов и файлов в каталоге dir
chmod -R 755 dir
```

#### chown

```bash
# Изменить владельца и группу файла file.txt
chown user:group file.txt

# Рекурсивное изменение владельца файлов и каталогов в каталоге dir
chown -R user:group dir/

# Изменить владельца файла file.txt на user
chown user file.txt
```

#### cp

```bash
# Скопировать файл file1 в файл file2
cp file1 file2

# Скопировать каталог dir в каталог dir2 рекурсивно
cp -r dir dir2
```

#### ls

```bash
# Файлы и директории содержащие в имени цифры
ls *[0-9]*

# Детальная информация о файлах, каталогах и скрытых файлах в текущем каталоге
ls -la
```

#### mv

```bash
# Переименовать файл
mv file1 file2

# Переместить файл в каталог
mv file1 dir

# Переименовать каталог dir1
mv dir1 dir2
```

#### mkdir

```bash
# Создать две директории
mkdir dir1 dir2

# Создать каталог и все промежуточные каталоги
mkdir -p /tmp/dir1/dir2
```

#### rm

```bash
# Удалить файл
rm file1

# Удалить каталог и его содержимое рекурсивно
rm -r dir

# Удалить каталог и его содержимое рекурсивно принудительно
rm -rf dir

# Выводить информацию об удаляемых файлах
m -v file
```

#### touch

```bash
# Создать файл
touch file

# Изменить дату и время создания файла, при отсутствии создать файл с такой датой и временем
touch -t 2412315900 file
```

### Process Management

#### top

```bash
# Вывод список процессов в реальном времени
top
```

#### htop

```bash
# Интерактивный мониторинг процессов
htop

# Интерактивный мониторинг процесс отсортированных по CPU
htop --sort-key=PERCENT_CPU

# Процессы конкретного пользователя
htop -u username
```

#### kill

```bash
# Завершить процесс по идентификатору процесса
kill PID

# Завершить процесс сигналом TERM
kill -TERM PID

# Завершить процесс сигналом KILL
kill -KILL PID
```

#### killall

```bash
# Завершить все процессы с определенным именем
killall process_name

# Завершить все процессы, принадлежащие определенному пользователю
killall -u username

# Завершить все процессы сигналом TERM
killall -TERM process_name
```

#### journalctl

-

#### systemctl

-

### Performance monitoring

#### nmon

```bash
# Мониторинг ресурсов
nmon

# Сохранить данные в файл
nmon -f -s 10 -c 144

# Мониторинг дисков
nmon -d
```

#### iostat

Контролирует ввод/вывод системы, наблюдая за временем активности устройств в зависимости от их средней скорости передачи. Отчеты iostat используются для изменения конфигов системы, чтобы повысить баланс ввода/вывода между физическими дисками.

```bash
# Статистика по использованию дисков
iostat

# Статистика по использованию процессора
iostat -c

# Статистика по сетевым интерфейсам
iostat -n
```

#### sar

```bash
# Статистика по использованию CPU
sar -u

# Статистика по использованию дисков
sar -d

# Статистика по использованию памяти
sar -r
```

#### vmstat

```bash
# Статистика использования памяти и процессора
vmstat

# Статистика по вводу/выводу
vmstat -d

# Статистика по памяти каждую секунду 5 раз
vmstat 1 5
```

### Network

#### traceroute

Используется для выявления проблем маршрутизации, задержки сети и потери пакетов.

```bash
# Маршрут сетевых пакетов до example.com
traceroute example.com

# Указание использовать IPv6
traceroute -6 example.com

# Предотвращение фрагментации пакетов
traceroute -F example.com

# Маршрут без изменения IP в имена
traceroute -n example.com

# Использовать указанный порт при трассировке маршрута
traceroute -p 80 example.com
```

#### ping

Отправляет ICMP пакеты на хост и ожидает ICMP ответ.

```bash
# Пинговать сайт
ping example.com

# Выполнить пинг 5 раз
ping -c 5 example.com

# Пинговать с интервалом 2 секунды
ping -i 2 example.com
```

#### mtr

```bash
# Комбинация traceroute и ping для поиска более узких мест в маршрутах
mtr example.com

# Результаты без изменения IP в имена
mtr -n example.com

# Использовать реверсивный DNS при отображении результатов
mtr -r example.com
```

#### ufw

```bash
# Статус брандмауэра
ufw status

# Включить брандмауэр
ufw enable

# Запретить доступ к 22 порту
ufw deny 22
```

#### iptables

Осуществляется на основе набора правил, которые определяются в таблицах. `nftables` имеет схожий функционал. Цепочки – последовательности правил, которые применяются к пакетам. Действия – решения, которые принимает брандмауэр на основе правил для пакета. Команды – инструкции к действию, которые позволяют добавлять, удалять, сбрасывать все правила, задавать действия по умолчанию.

```bash
# Показать текущие правила
iptables -L

# Вывод таблиц с нумерацией правил
iptables -L -v -n --line-numbers

# Удаление правила из таблицы filter под номером 3
iptables -t filter -D INPUT 3

# Блокировать исходящие HTTP-соединения
iptables -t filter -A OUTPUT -p tcp --dport http -j DROP

# Включить логирование ядром пакетов, проходящих через цепочку INPUT, и добавлением к сообщению префикса DROP INPUT
iptables -t filters -A INPUT -j LOG --log-prefix "DROP INPUT"

# Разрешить входящие соединения на порт 80
iptables -A INPUT -p tcp --dport 80 -j ACCEPT

# Запретить доступ к определенной подсети
iptables -A INPUT -s 0.0.0.0/24 -j DROP

# Ограничение скорости трафика к новым SSH-соединениям
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m limit --limit 3/min -j ACCEPT

# Логирование всех отброшенных пакетов
iptables -A INPUT -j LOG --log-prefix “Dropped Packet: “ iptables -A INPUT -j DROP
```

#### tcpdump

```bash
# Перехват пакетов, проходящих через интерфейс eth0
tcpdump -i eth0

# Перехват пакетов, проходящих через порт 80 без изменения IP в имена
tcpdump -n port 80

# Перехвать 10 пакетов и запись их в файл
tcpdump -c 10 -w capture.pcap
```

#### ssh

-

#### dig

```bash
# Получить информацию о домене
dig example.com

# Получить только IP-адрес домена
dig +short example.com

# Использовать конкретный DNS-сервер для запроса
dig @0.0.0.0 example.com
```

#### scp

Использует шифрование через ssh соединение.

```bash
# Копирование файла на удаленный сервер
scp file user@example.com:/path

# Рекурсивное копирование каталога на удаленный сервер
scp -r folder/ user@example.com:/path

# Копирование файла с сервера на локалку
scp user@example.com:/path/file
```

#### nmap

```bash
# Основное сканирование IP-адреса
nmap 0.0.0.0

# Сканирование конкретного диапазона портов
nmap -p 1-1000 0.0.0.0

# Сканирование с указанием версии служб
nmap -sV 0.0.0.0

# Сканирование устройств в сети + пинг найденных устройств (-P)
nmap -sP 192.168.0.1/24

# Сканирование устройств в сети и их портов
nmap -Pn 192.168.0.1/24

# Брутфорс ssh с помощью скрипта
nmap --script ssh-brute -p 22 0.0.0.0

# Брутфорс http auth с помощью скрипта и вордлистов
nmap -p 80 --script http-brute --script-args "http-brute.hostname=0.0.0.0,http-brute.method=POST,http-brute.path=PATH,passdb=pwd.txt,userdb=usr.txt" -v 0.0.0.0

# Поиск скрытых файлов и каталогов
nmap --script http-enum 0.0.0.0

# 
nmap -A --top-ports 10000 0.0.0.0 -vv
```

### Troubleshooting

#### hping

```bash
# Традиционный пинг
hping3 -1 127.0.0.1

# SYN-флуд-атака
hping3 --flood -S -p 80 127.0.0.1

# UDP сканирование первых 100 портов
hping3 --udp -p 1-100 127.0.0.1
```

#### memdump

-

#### nslookup

-

#### masscan

-

#### arp

-

#### curl

cURL — это инструмент, который позволяет передавать файлы из оболочки по таким протоколам, как HTTP, HTTPS, FTP, SFTP, FTPS или SCP. Этот инструмент дает нам возможность удаленно контролировать и тестировать веб-сайты. Помимо содержимого удаленных серверов, мы также можем просматривать отдельные запросы, чтобы следить за взаимодействием клиента и сервера. Обычно cURL уже установлен в большинстве систем Linux.

```
curl -X POST -d “data=sample” https://example.com (Пример POST запроса)

curl -Iv https://example.com (Проверка конфига SSL/TLS)

curl -H “Cookie: session=12345” https://example.com (Отправка cookie)
```

#### dd

```bash
# Создание точного образа USB-накопителя и запись его в новый файл
dd if=/dev/sdb1 of=~/usb_drive_image.img bs=4096
```

### Backup and Restore

#### rsync

Быстрое и безопасное создание резервных копий файлов и папок в удаленном месте. Это особенно полезно для передачи больших объемов данных по сети, поскольку передаются только измененные части файла. Его также можно использовать для создания резервных копий локально или на удаленных серверах. Если нужно выполнить резервное копирование больших объемов данных по сети, Rsync может оказаться лучшим вариантом.

Чтобы включить автоматическую синхронизацию с помощью rsync, можно использовать комбинацию cron и rsync для автоматизации процесса синхронизации. Планирование запуска задания cron через регулярные промежутки времени гарантирует синхронизацию содержимого двух систем. Это может быть особенно полезно для организаций, которым необходимо синхронизировать данные на нескольких машинах.

Создание резервной копии локального каталога в резервной копии. Эта команда скопирует весь каталог (/path/to/mydirectory) на удаленный хост (backup_server) в каталог /path/to/backup/directory. Параметр archive (-a) используется для сохранения исходных атрибутов файла, таких как разрешения, временные метки и т. д., а использование подробного параметра (-v) обеспечивает подробный вывод хода операции rsync.

```bash
rsync -av /path/to/mydirectory user@backup_server:/path/to/backup/directory
```

В этом примере мы создаем резервную копию mydirectory на удаленном сервере backup_server, сохраняя исходные атрибуты файла, временные метки и разрешения, а также включаем сжатие (-z) для более быстрой передачи. Параметр --backup создает инкрементальные резервные копии в каталоге /path/to/backup/folder, а параметр --delete удаляет файлы с удаленного хоста, которых больше нет в исходном каталоге.

```bash
rsync -avz --backup --backup-dir=/path/to/backup/folder --delete /path/to/mydirectory user@backup_server:/path/to/backup/directory
```

Восстановление каталога с сервера резервного копирования в локальный каталог. Передача данных между локальным хостом и резервным сервером происходит через зашифрованное соединение SSH, что обеспечивает конфиденциальность и защиту целостности передаваемых данных. Этот процесс шифрования гарантирует, что данные защищены от любых потенциальных злоумышленников, которые в противном случае могли бы получить доступ к данным и изменить их без разрешения. Сам ключ шифрования также защищен комплексным набором протоколов безопасности, что еще больше затрудняет доступ к данным неавторизованному лицу.

```bash
rsync -av user@remote_host:/path/to/backup/directory /path/to/mydirectory
```

Безопасная передача резервной копии

```bash
rsync -avz -e ssh /path/to/mydirectory user@backup_server:/path/to/backup/directory
```

#### Deja Dup

Графический инструмент резервного копирования, который упрощает процесс резервного копирования, позволяя быстро и легко создавать резервные копии данных. Он предоставляет удобный интерфейс для создания резервных копий данных на локальном или удаленном носителе. Он использует Rsync в качестве бэкэнда, а также поддерживает шифрование данных.

#### duplicity

Графический инструмент резервного копирования, который обеспечивает пользователям комплексную защиту данных и безопасное резервное копирование. Он также использует Rsync в качестве бэкэнда и дополнительно предлагает возможность шифровать резервные копии и хранить их на удаленных носителях, таких как FTP-серверы, или в облачных службах хранения, таких как Amazon S3.

## Practice

### Task 1

Практика утилит фильтрации текста. Практика выполняется с файлом `/etc/passwd`. Вывести содержимое файла и фильтровать:
	- Строки с именем пользователя root;
	- Столбец с именами пользователей;
	- Имя пользователя root и его UID;
	- Имя пользователя root и его UID, разделенные запятыми;
	- Имя пользователя root, установленная CLI и его UID, разделенные запятыми;
	- Все имена пользователей, их UID и CLi, разделенные запятыми;
	- Все имена пользователей, их UID и CLi, разделенные запятыми, кроме тех, что содержат nologin или false;
	- Все имена пользователей, их UID и CLi, разделенные запятыми, кроме тех, что содержат nologin, и подсчитать количество строк.


### Task 2 

Пройти vimtutor. Для запуска:
```bash
vimtutor
```
