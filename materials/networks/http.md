# HTTP

HTTP (Hypertext Transfer Protocol) - протокол прикладного уровня для передачи гипертекста, например, HTML. Использует клиент-серверную модель. HTTP не сохраняет состояние (каждая пара запроса и ответа независима от других). 

HTTPS - безопасная версия HTTP, которая шифрует данные между клиентом и сервером с использованием SSL или TLS. У ресурса, поддерживающего HTTPS есть SSL/TLS сертификат, который выдается центром сертификации. Перед запуском HTTP-соединения браузер проверяет сертификат на валидность.

Кэширование сокращает время загрузки страницы. Для этого требуется место на локальном диске компьютера. Можно кэшировать  страницы, CSS, изображения, JS. Для определения можно ли брать страницу из кэша, используется заголовок Expires, который указывает до какого времени можно хранить ресурс в кэше. Чтобы определить, изменились ли кэшированные данные, используется заголовок Last-Modified и GET запрос и в ответ получается пакет с заголовком If-Modified-Since.

Разделяют протокол на 2 части: HTTP запрос (request), и HTTP ответ (response). Запрос отправляет клиент, он генерируется веб браузером. Ответ возвращает web приложение, на определенный запрос.

## Структура сообщения

Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:

**Стартовая строка** (англ. Starting line) — определяет тип сообщения;

**Заголовки** (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;

**Тело сообщения** (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

Тело сообщения может отсутствовать, но стартовая строка и заголовок являются обязательными элементами. Исключением является версия 0.9 протокола, у которой сообщение запроса содержит только стартовую строку, а сообщения ответа — только тело сообщения.

Для версии протокола 1.1 сообщение запроса обязательно должно содержать заголовок Host.

**Стартовая строка**

Стартовые строки различаются для запроса и ответа. Строка запроса выглядит так: Метод URI HTTP/Версия — для остальных версий. Здесь:

- Метод (англ. Method) — тип запроса, одно слово заглавными буквами. В версии HTTP 0.9 использовался только метод GET, список методов для версии 1.1 представлен ниже.
- URI определяет путь к запрашиваемому документу.
- Версия (англ. Version) — пара разделённых точкой цифр. Например: 1.0.

Стартовая строка ответа сервера имеет следующий формат: HTTP/Версия КодСостояния Пояснение, где:

- Версия — пара разделённых точкой цифр, как в запросе;
- Код состояния (англ. Status Code) — три цифры. По коду состояния определяется дальнейшее содержимое сообщения и поведение клиента;
- Пояснение (англ. Reason Phrase) — текстовое короткое пояснение к коду ответа для пользователя. Никак не влияет на сообщение и является необязательным.

Из перечисленного следует подробнее рассмотреть типы запросов и коды состояния

## Методы

Метод HTTP (англ. HTTP Method) - последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. Обратите внимание, что название метода чувствительно к регистру.

Обозначим следующие методы:

- __GET__: Получение данных
- __HEAD__: Получение данных без тела ответа
- __POST__: Отправление данных на сервер. Тип данных в Content-Type
- __PUT__: Полное изменение ресурса
- __DELETE__: Удаление ресурса
- __CONNECT__: Установление туннеля к серверу
- __OPTIONS__: Получение разрешенных параметров связи 
- __TRACE__: Проверка обратной связи сообщения на пути к ресурсу
- __PATCH__: Частичное изменение ресурса

## Коды состояния


- __100__: Continue – Промежуточный ответ для продолжения запроса
- __101__: Switching Protocols – Переключаемый протокол
- __102__: Processing – Сервер получил ответ и обрабатывает запрос
- __103__: Early Hints – Загрузка ресурсов до отправки ответа от сервера
- __200__: OK – Запрос выполнен
- __201__: Created – Запрос выполнен и создан ресурс
- __202__: Accepted – Запрос получен, но не обработан
- __203__: Non-Authoritative Information – Метаданные не совпадают
- __204__: No Content – Нет контента, но есть заголовки 
- __205__: Reset Content – Сброс документа пользователя
- __206__: Partial Content – Запрос на часть ресурса
- __207__: Multi-Status – Несколько кодов состояний
- __208__: Already Reported
- __226__: Im Used – Манипуляции с GET ресурсом
- __300__: Multiple Choices – Несколько ответов на запрос
- __301__: Moved Permanently – Нужный URL навсегда изменен
- __302__: Found – Нужный URL временно изменен
- __303__: See Other – Получить ресурс по другому URL
- __304__: Not Modified – Неизменность кэшированного ресурса
- __305__: Use Proxy
- __306__: Unused
- __307__: Temporary Redirect – Нужный URL временно изменен
- __308__: Permanent Redirect – Нужный URL навсегда изменен
- __400__: Bad Request – Неверный запрос
- __401__: Unauthorized – Не аутентифицированный
- __403__: Forbidden – Не авторизован (нет доступа)
- __404__: Not Found – Не найдено
- __405__: Method Not Allowed – Метод не поддерживается
- __406__: Not Acceptable – Нет контента после согласования
- __407__: Proxy Authentication Required
- __408__: Request Timeout – Закрытие соединения из-за простоя
- __409__: Conflict – Конфликт запроса и состояния
- __410__: Gone – Контент удален без пересылки
- __411__: Length Required – Не указан Content-Length
- __412__: Precondition Failed – Несоответствие условиям заголовков
- __413__: Payload Too Large – Запрос превышает ограничения сервера
- __414__: URI Too Long – URL слишком длинный
- __415__: Unsupported Media Type – Неподдерживаемый формат медиа
- __416__: Range Not Satisfiable – Неподдерживаемый Range
- __417__: Expectation Failed – Невозможность выполнения Expect
- __418__: I'm a teapot
- __421__: Misdirected Request – Ответ не может быть выдан
- __422__: Unprocessable Content – Семантические ошибки запроса
- __423__: Locked – Ресурс заблокирован
- __424__: Failed Dependency – Сбой предыдущего запроса
- __425__: Too Early
- __426__: Upgrade Required – Отказ ответа по выбранному протоколу
- __428__: Precondition Required – Требование условности запроса
- __429__: Too Many Requests – Ограничение скорости запросов
- __431__: Request Header Fields Too Large
- __451__: Unavailable For Legal Reasons – Отказ запрос на основе закона
- __500__: Internal Server Error – Неизвестная ситуация
- __501__: Not Implemented – Неподдерживаемый метод
- __502__: Bad Gateway – Недопустимый ответ
- __503__: Service Unavailable – Сервер недоступен
- __504__: Gateway Timeout – Ответ не получен вовремя
- __505__: HTTP Version Not Supported – Неподдерживаемая версия HTTP
- __506__: Variant Also Negotiates – Внутренняя ошибка конфигурации
- __507__: Insufficient Storage – Ошибка сборки ответа на запрос
- __508__: Loop Detected – Бесконечный цикл
- __510__: Not Extended – Необходимы расширения запроса
- __511__: Network Authentication Required

**1xx**

Информационный(англ. informational)

Информирование о процессе передачи. В HTTP/1.0 — сообщения с такими кодами должны игнорироваться.

В HTTP/1.1 — клиент должен быть готов принять этот класс сообщений как обычный ответ, но ничего отправлять серверу не нужно.

Сами сообщения от сервера содержат только стартовую строку ответа и, если требуется, несколько специфичных для ответа полей заголовка. Прокси-серверы подобные сообщения должны отправлять дальше от сервера к клиенту

**2xx**

Успех(англ. Success)

Информирование о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения.

**3xx**

Перенаправление(англ. Redirection)

Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location. При этом допускается использование фрагментов в целевом URI.

**4xx**

Ошибка клиента(англ. Client Error)

Указание ошибок со стороны клиента. При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.

**5xx**

Ошибка сервера(англ. Server Error)

Информирование о случаях неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.

## Заголовки

Заголовки HTTP (англ. HTTP Headers) - это строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение. Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений ARPA (см. RFC 822). Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.

Все заголовки разделяются на четыре основных группы:

- General Headers («Основные заголовки») — могут включаться в любое сообщение клиента и сервера;
- Request Headers («Заголовки запроса») — используются только в запросах клиента;
- Response Headers («Заголовки ответа») — только для ответов от сервера;
- Entity Headers («Заголовки сущности») — сопровождают каждую сущность сообщения.

Именно в таком порядке рекомендуется посылать заголовки получателю.

Все необходимые для функционирования HTTP заголовки описаны в основных RFC. Если не хватает существующих, то можно вводить свои. Традиционно к именам таких дополнительных заголовков добавляют префикс «X-» для избегания конфликта имён с возможно существующими.


- WWW–Authenticate: Отправляется сервером в ответ на запрос, который требует аутентификации. Сообщает о поддерживаемых методах аутентификации.Пример: WWW-Authenticate: Basic realm=”Secure Area”.
- Authorization: Отправляется клиентом после получения заголовка WWW-Authenticate. Содержит учетные данные для аутентификации. Пример: Authorization: Basic AJlkjFtgLaSdsdhShU.
- Proxy-Authenticate: Аналогичен WWW-Authenticate, но для прокси-сервера. Пример: Proxy-Authenticate: Basic realm=”Proxy Server”.
- Proxy-Authorization: Аналогичен Authorization, но для прокси-сервера. Пример: Proxy-Authorization: Basic AJlkjFtgLaSdsdhShU.
- Age: Время нахождения в кэше в секундах для определения свежести данных. Пример: Age: 3600. (Ресурс был кэширован на сервере в течение 3600 секунд).
- Cache-Control: Директивы для кэширования ресурсов в браузерах. Пример: Cache-Control: max-age=12345, no-cache.
- Clear-Site-Data: Указывает браузеру очистить определенные данные сайта у клиента (cookie, cache, storage). Пример: Clear-Site-Data: “cache”, “cookies”. (Очистить кэш и куки).
- Expires: Указывает дату истечения срока действия ресурса. Пример: Expires: Thu, 01 Dec 2022 16:00:00 GMT. 
- Last-Modified: Отправляется серверов и указывает дату последнего изменения ресурса. Пример: Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT.
- ETag: Отправляется сервером и указывает уникальный идентификатор версии ресурса. Используется для определения измененности ресурса. Пример: ETag: “33a64df551425fcc55e4d42a148795d9f25f89d4”.
- If-Match: Отправляется клиентом для выполнения запроса только если текущая версия ресурса соответствует одному из ETag. Пример: If-Match: "67ab43", "54ed21", "7892dd".
- If-None-Match: Противоположно If-Match
- If-Modified-Since: Отправляется клиентом для выполнения запроса только если ресурс был изменен после указанной даты. Пример: If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT.
- If-Unmodified-Since: Противоположно If-Modified-Since
- Vary: Отправляется сервером для указания алгоритма выбора кэша, в случае, когда есть несколько вариантов ответа на один и тот же запрос. Например, если сервер возвращает разные версии ресурса в зависимости от User-Agent. Пример: Vary: User-Agent.
- Connection: Отправляется клиентом для указания параметра соединения. Например, можно сообщить серверу не закрывать соединение. Пример: Connection: keep-alive.
- Keep-Alive: Отправляется клиентом для указания параметров постоянного соединения. Используется вместе с Connection. Пример: Keep-Alive: timeout=5, max=1000.
- Accept: Используется клиентом для указания разрешенных типов контента. Пример: Accept: text/html, application/xhtml+xml.
- Accept-Encoding: Используется клиентом для указания разрешенных алгоритмов кодирования. Пример: Accept-Encoding: gzip.
- Accept-Language: Используется клиентом для указания разрешенных языков. Пример: Accept-Language: en-US,en;q=0.5.
- Expect: Используется клиентом для указания условий, которые должны быть выполнены сервером перед отправкой запроса. Пример: Expect: 100-continue.
- Max-Forwards: Максимальное количество пересылок запроса. Используется для предотвращения бесконечных циклов перенаправления в сети. Пример: Max-Forwards: 1000.
- Cookie: Используется клиентом и содержит cookie, которые ранее были установлены сервером и должны быть переданы обратно вместе с запросом.
- Set-Cookie: Используется сервером для установки Cookie в браузере клиента.
- Access-Control-Allow-Credentials: Используется сервером для указания разрешается ли передавать учетные данные клиента в CORS запросах. Пример: Access-Control-Allow-Credentials: true.
- Access-Control-Allow-Headers: Используется сервером для указания допустимых заголовков в CORS запросах. Пример: Access-Control-Allow-Header: Content-Type.
- Access-Control-Allow-Methods: Используется сервером для указания допустимых методов в CORS запросах. Пример: Access-Control-Allow-Method: GET, POST.
- Access-Control-Allow-Origin: Используется сервером для указания доменов с которых разрешены CORS запросы. Пример: Access-Control-Allow-Origin: *.
- Access-Control-Expose-Headers: Используется сервером для указания допустимых заголовков ответа в JS на стороне клиента в CORS запросах. Пример: Access-Control-Expose-Headers: Content-Encoding.
- Access-Control-Max-Age: Используется сервером для указания времени в секундах, в течение которого CORS запросы могут кэшироваться. Пример: Access-Control-Max-Age: 600.
- Access-Control-Request-Headers: Используется клиентом при отправке предварительного запроса для указания допустимых заголовков для фактического запроса. Пример: Access-Control-Request-Headers: Content-Type.
- Access-Control-Request-Method: Используется клиентом при отправке предварительного запроса для указания метода для фактического запроса. Пример: Access-Control-Request-Method: POST.
- Origin: Используется клиентом для указания источника CORS запроса. Пример: Origin: 127.0.0.1.
- Timing-Allow-Origin: Используется сервером для указания доменов, которым разрешен доступ к информации о времени выполнения запроса. Пример: Timing-Allow-Origin: 127.0.0.1.
- Content-Disposition: Указывает как браузер должен отобразить содержимое ответа. Например, отобразить в браузере или скачать как файл. Пример: Content-Disposition: inline.
- Content-Length: Указывает размер ресурса в байтах, чтобы браузер знал какой объем данных ожидать и когда получение данных завершится. Пример: Content-Length: 1024.
- Content-Type: Указывает тип содержимого ресурса. Пример: Content-Type: text/html.
- Content-Encoding: Указывает метод сжатия ресурса. Пример: Content-Encoding: gzip.
- Content-Language: Указывает язык ресурса. Пример: Content-Language: en-US.
- Content-Location: Указывает URL или абсолютный путь к ресурсу. Используется когда ресурс был изменен, а URL остается тем же. Пример: Content-Location: /path
- Forwarded: Используется прокси-серверами для передачи информации об IP-адресе клиента. Пример: Forwarded: for=192.0.0.1.
- Via: Используется прокси-серверами для указания промежуточных узлов, через которые прошел запрос. Каждый узел добавляет свой IP-адрес. Пример: Via: 1.0 fred, 1.1 example.com.
- Location: Используется сервером для перенаправления клиента на другой ресурс. Используется в ответе на запрос с кодом 3хх. Пример: Location: /index.html.
- From: Содержит электронный адрес клиента. Пример: From: example@example.com.
- Host: Содержит хост и порт сервера. Пример: Host: 127.0.0.1:8000.
- Referer: Содержит URL ресурса, с которого был сделан запрос. Используется для отслеживания источников трафика. Пример: Referer: https://example.com
- Referer-Policy: Используется сервером для указания политики защиты приватности Referer. Пример: Referer-Policy: origin.
- User-Agent: Содержит информацию о браузере и ОС клиента. Пример: User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36.
- Allow: Используется сервером в ответе на OPTIONS запрос для указания разрешенных методов. Пример: Allow: GET, POST.
- Server: Содержит информацию о сервере. Пример: Server: Apache/2.4.1.
- Accept-Ranges: Содержит информацию о том, поддерживает ли сервер возможность использования Range в запросах для конкретного ресурса. Пример: Accept-Ranges: bytes.
- Range: Используется клиентом для запроса дополнительного диапазона ресурса. Пример: Range: 0-499.
- If-Range: Используется клиентом вместе с Range для создания условного запроса на диапазон ресурса, который будет выполнен, если ресурс не изменился с указанного времени или ETag. Пример: If-Range: Wed, 21 Oct 2015 07:28:00 GMT.
- Content-Range: Используется сервером в ответе на запрос с Range для указания передаваемого диапазона байт и общего количества байт. Пример: Content-Range: bytes 0-499/1000.
- Cross-Origin-Embedder-Policy (COEP): Используется сервером для настройки встраивания ресурсов (скрипты, стили) из разных источников в документ. Предотвращает утечки информации, атаки типа Spectre. Пример: Cross-Origin-EMbedder-Policy: require-corp.
- Cross-Origin-Opener-Policy (COOP): Используется сервером для настройки загрузки страниц во фрейме другого происхождения и с другими документами в окне. Предотвращает атаки Shared Context, XSS. Пример: Cross-Origin-Opener-Policy: same-origin.
- Cross-Origin-Resource-Policy (CORP): Используется сервером для контроля доступа к ресурсам (скрипты, стили) между разными источниками. Предотвращает XSS. Пример: Cross-Origin-Resource-Policy: same-site.
- Content-Security-Policy (CSP): Используется сервером для указания разрешенных и запрещенных источников ресурсов для предотвращения XSS, Clickjacking, инъекции кода. Пример: Content-Security-Policy: default-src ‘self’; img-src: ‘self’ example.com; script-src ‘self’ apis.example.com. (Все ресурсы должны быть загружены с того же домена, с которого загружена страница, изображения можно загружать с того же домена и с example.com, а также разрешено выполнение скриптов с домена-источника и с apis.example.com).
- Content-Security-Policy-Report-Only: Аналогичен CSP, но не препятствует выполнению небезопасного кода, а только сообщает о нарушениях. Пример: Content-Security-Policy-Report-Only: default-src https:; report-to /csp/.
- Permissions-Policy: Используется сервером для указания разрешений для функций браузера (Использование камеры, микрофона, …). Пример: Permissions-Policy: geolocation=*. (Разрешить всем источникам доступ к геолокации).
- Strict-Transport-Security (HSTS): Используется сервером для указания использовать только HTTPS. Более безопасно, чем перенаправление на сервере (301). Предотвращает атаки MITM. Пример: Strict-Transport-Security: max-age=31536000; includeSubdomains; preload. (Все поддомены будут работать по HTTPS в течение года).
- Upgrade-Insecure-Requests: Используется клиентом для указания об автоматическом обновлении HTTP на HTTPS. Пример: Upgrade-Insecure-Requests: 1.
- X-Content-Type-Options: Используется сервером для указания реакции на несоответствие содержимого контента и типа MIME. Позволяет избежать перехвата типов MIME, сообщая, что типы MIME настроены намеренно. Пример: X-Content-Type-Options: nosniff.
- X-Frame-Options: Используется сервером для указания разрешено ли отображение  ресурса во фреймах. Предотвращает Clickjacking. Вместо него используется CSP frame-ancestors. Пример: X-Frame-Options: DENY.
- X-Permitted-Cross-Domain-Policies: Используется сервером для указания политики взаимодействия с другими доменами.
- X-Powered-By: Используется сервером для указания информации об используемых технологиях. Рекомендуется отключать.
- X-XSS-Protection: Используется сервером для указания встроенного механизма защиты от XSS атак. Вместо него используется CSP.
- Sec-Fetch-Site: Используется клиентом для указания связи между исходным ресурсом и запрашиваемым ресурсом. Например, запрос с того же домена, запрос в браузере, запрос на другой домен. Пример: Sec-Fetch-Site: cross-site.
- Sec-Fetch-Mode: Используется клиентом для указания режима загрузки ресурса. Пример: Sec-Fetch-Mode: cors.
- Sec-Fetch-User: Используется клиентом для указания включения. Пример: Sec-Fetch-User: ?1.
- Sec-Fetch-Dest: Используется клиентом для указания цели загрузки документа. Пример: Sec-Fetch-Dest: document.
- Sec-Purpose: Используется клиентом для указания намерения запроса. Пример: Sec-Purpose: prefetch.
- Service-Worker-Navigation-Preload: Используется сервером для указания должен ли воркер предварительно загружать навигационные запросы. Пример: Service-Worker-Navigation-Preload: true.
- Transfer-Encoding: Используется клиентом для указания способа кодирования тела сообщения. Пример: Transfer-Encoding: chunked.
- TE: Используется сервером для указания возможных методах передачи.
- Trailer: Используется сервером для указания передачи метаданных в конце тела сообщения.
- Alt-Svc: Используется для указания альтернативных способах выполнения запроса.
- Alt-Used: Используется клиентом после получения заголовка Alt-Used.
- Date: Содержит дату и время генерации ресурса.
- Link: Используется сервером для указания связанных ресурсов (стили, скрипты).
- Retry-After: Используется сервером для указания времени ожидания прежде чем сделать следующий запрос.
- Server-Timing: Используется сервером для указания времени выполнения запроса. Используется для измерения производительности.
- Service-Worker-Allowed: Используется для указания разрешено ли использовать воркеры.
- SourceMap: Используется для указания расположения файла карты исходных кодов. Используется для отладки.
- Upgrade: Используется клиентом для указания желания о переключении на другой протокол.

## Тело сообщения

Часть сообщения, которое называется телом, является необязательной для HTTP-сообщения, но если она доступна, она используется для переноса тела объекта, связанного с запросом или ответом. Если тело объекта присутствует, то обычно строки заголовков Content Type и Content-Length указывают природу тела сообщения.

Тело сообщения — это та часть, которая содержит фактические данные HTTP-запроса (сюда же относятся данные, передаваемые через веб-формы и выгружаемые файлы) и данные HTTP-ответа от сервера (включая HTML код, файлы, изображения и т. д.).

## HTTPS

HTTPS не является отдельным протоколом. Это расширение протокола HTTP для поддержки шифрования в целях повышения безопасности.

Данные в протоколе HTTPS передаются поверх криптографических протоколов TLS или SSL.

В отличие от HTTP с TCP-портом 80, для HTTPS по умолчанию используется TCP-порт 443.

### Функции

Функции протокола HTTPS:

**Шифрование**. Информация передаётся в зашифрованном виде. Благодаря этому злоумышленники не могут украсть информацию, которой обмениваются посетители сайта, а также отследить их действия на других страницах.

**Аутентификация**. Посетители уверены, что переходят на официальный сайт компании, а не на дубликат, сделанный злоумышленником.

**Сохранение данных**. Протокол фиксирует все изменения данных. Если злоумышленник всё-таки пытался взломать защиту, об этом можно узнать из сохранённых данных.

### Механизм работы

- Браузер пользователя просит предоставить SSL-сертификат
- Сайт на HTTPS отправляет сертификат
- Браузер проверяет подлинность сертификата в центре сертификации
- Браузер и сайт договариваются о симметричном ключе при помощи асимметричного шифрования
- Браузер и сайт передают зашифрованную информацию

## Версии протокола

### HTTP /0.9

Поддерживаемые методы: GET. Нет заголовков, и не нужно писать версию HTTP. Для каждого запроса создается новое TCP соединение. В ответе поддерживается только HTML тип.

### HTTP/1.0

Поддерживаемые методы: GET, HEAD, POST. Поддерживает заголовки. Нужно указывать версию HTTP протокола. Также для каждого запроса создается новое TCP соединение.

```
(Request)
GET / HTTP/1.0
User-Agent: Web-Browser

(Response)
HTTP/1.0 200 OK
Content-Type: text/html
Content-Length: 1337
Server: Apache

<html>
Answer
</html>
```

### HTTP/1.1

Поддерживаемые методы: GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS

Появилась оптимизация: Заголовок Host (виртуальные адреса), алгоритмы сжатия (gzip, deflate, br), передача по частям (chunk), поддержка кеша, постоянные и конвейерные соединения.

Постоянные соединения, позволяют использовать одно TCP соединение, для создания нескольких запросов, что существенно ускоряло работу веб приложения.

### HTTP/2

Двоичный протокол. (Предыдущие текстовые). Мультиплексный протокол. (Параллельные запросы могут выполняться по одному и тому же соединению). Сжимает заголовки. Позволяет серверу заполнять данные в клиентском кеше с помощью механизма server push.

### HTTP/3

Основан на концепции HTTP/2. Использует протокол QUIC (Работает поверх UDP) вместо TCP/TLS на транспортном уровне. (что делает передачу данных еще быстрее HTTP/2).
