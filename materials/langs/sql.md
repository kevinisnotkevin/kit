# SQL

- https://sql-academy.org/ru/guide/intro-intro
- https://www.sql-ex.ru/learn_exercises.php
- https://learndb.ru/
- https://stepik.org/lesson/297508/step/1?unit=279268

## 1 Что такое SQL?

```sql
 SELECT список_полей
   FROM список_таблиц
  WHERE ограничения_на_список_строк
  GROUP BY условия_группировки
 HAVING ограничения_на_строки_после_группировки
  ORDER BY порядок_сортировки
  LIMIT ограничение_количества_записей
```
- Базовый синтаксис SQL запроса.

**SQL (Structured Query Language)** - это язык программирования, используемый в большинстве реляционных баз данных для запросов, обработки и определения данных, а также контроля доступа. SQL был разработан в IBM в 1970-х годах. Со временем у стандарта SQL ANSI появились многочисленные расширения, разработанные такими компаниями как IBM, Oracle и Microsoft. Хотя в настоящее время SQL все еще широко используется, начали появляться новые языки программирования запросов.

Является, прежде всего, информационно-логическим языком, предназначенным для описания, изменения и извлечения данных, хранимых в реляционных базах данных. В общем случае SQL (без ряда современных расширений) считается языком программирования неполным по Тьюрингу, но вместе с тем стандарт языка спецификацией SQL/PSM предусматривает возможность его процедурных расширений.

Язык SQL - универсальный язык для всех реляционных систем управления базами данных, но многие СУБД вносят свои изменения в язык, применяемый в них, тем самым отступая от стандарта. Такие языки называют диалектами или расширениями языка.

Диалекты SQL:

- T-SQL - диалект Microsoft SQL Server.
- PL/SQL - диалект Oracle Database.
- PL/pgSQL - диалект PostgreSQL.

**MySQL**

- **Особенности:** MySQL - это одна из самых популярных реляционных баз данных, широко используемая в веб-разработке и других областях. Его диалект SQL характеризуется простым и интуитивно понятным синтаксисом.
- **Основные различия:** Одним из отличительных особенностей MySQL является использование двойных кавычек для обозначения строковых значений, в то время как в других диалектах SQL используются одинарные кавычки. Кроме того, MySQL имеет свои собственные функции и операторы, такие как LIMIT для ограничения количества возвращаемых записей в запросе.

**PostgreSQL**

- **Особенности:** PostgreSQL - это мощная и расширяемая реляционная база данных с открытым исходным кодом. Ее диалект SQL предоставляет богатый набор функций и возможностей.
- **Основные различия:** PostgreSQL часто использует двойные кавычки для обозначения идентификаторов, таких как имена таблиц и столбцов, что отличается от стандартного использования одинарных кавычек в других диалектах. Кроме того, PostgreSQL предоставляет множество расширений и возможностей, таких как оконные функции и генерируемые столбцы.

**Microsoft SQL Server**

- **Особенности:** Microsoft SQL Server - это коммерческая реляционная база данных, разработанная корпорацией Microsoft. Ее диалект SQL широко используется в корпоративной среде и имеет свои собственные особенности.
- **Основные различия:** В SQL Server, например, используется функция TOP вместо LIMIT для ограничения количества возвращаемых записей. Также в SQL Server могут присутствовать различия в типах данных и синтаксисе для некоторых операторов и функций.

SQL позволяет:

- получать доступ к данным в системах управления РБД
- описывать данные (их структуру)
- определять данные в БД и управлять ими
- взаимодействовать с другими языками через модули SQL, библиотеки и предварительные компиляторы
- создавать и удалять БД и таблицы
- создавать представления, хранимые процедуры (stored procedures) и функции в БД
- устанавливать разрешения на доступ к таблицам, процедурам и представлениям

**Строковые литералы**

**Литерал** - это указанное явным образом фиксированное значение, например, число 12 или строка "SQL".

**Строка** - это последовательность символов, заключённых в одинарные (') или двойные (") кавычки. Например, 'это строка' и "это строка".

```sql
SELECT "Строка \n Другая строка" as String
```

**Числовые литералы**

- `1`
- `2.1`
- `0.01`
- `.2`
- `+1`
- `-1`
- `1e3`, `1000`
- `%`, `MOD`
- `*`
- `+`
- `-`
- `/`
- `DIV`

```sql
SELECT (5 * 2 - 6) AS Result;
```
- Используя эти операторы можно построить любое арифметическое выражение, применяя стандартные правила арифметики.

**Литералы даты и времени**

- `YYYY-MM-DD`, `YYYYMMDD` (дата со временем, равным нулю)
- `hh:mm:ss`, `hh:mm`, `hh`, `ss` (время без конкретной даты)
- `YYYY-MM-DD hh:mm:ss`, `YYYYMMDDhhmmss` (дата и время)

Значения даты и времени могут быть представлены в формате строки или числа.

Например, если мы хотим указать какую-то дату в запросе, то мы можем это сделать с помощью строки "2000-12-30", "20001230" или же числа 20001230. В обоих случаях эти значения будут интерпретироваться как дата «30 декабря 2000 года».

```sql
SELECT * FROM user WHERE birthday > '2000-12-30'
```

**Логические литералы**

Логический литерал - это значения TRUE и FALSE, означающие истинность и ошибочность какого-либо утверждения. При интерпретации запроса TRUE и FALSE становятся 1 и 0 соответственно.

**NULL**

Значение NULL означает "нет данных", "нет значения". Оно нужно, чтобы отличать визуально пустые значения, такие как строка нулевой длины или "пробел", от того, когда значения вообще нет, даже пустого.

**Конкатенация строк**

Часто в запросах приходится объединять несколько значений в одно текстовое значение (конкатенация). Например, может потребоваться получить строку следующего формата: 'текущее время: 2020-02-19 15:28:44.049702+07'. Для выполнения конкатенации строк необходимо воспользоваться оператором `||`:

```sql
SELECT 'текущее время: ' || now() as time

SELECT concat('текущее время: ', now()) as time
```
- Аналогичные записи

**Логические операторы**

В предложении WHERE могут присутствовать логические операторы (список в порядке выполнения условий):

- `NOT`: отрицание.
- `AND`: логическое И.
- `OR`: логическое ИЛИ.

В предложении WHERE помимо проверки на равенство можно использовать и другие операции сравнения. Доступны следующие операторы:

- `<` - меньше;
- `>` - больше;
- `<=` - меньше или равно;
- `>=` - больше или равно;
- `=` - равно;
- `!=` или `<>` - не равно.

## 2 Элементы SQL

### 2.1 SELECT

```sql
SELECT * FROM employees;
```
- Одна из основных функций SQL - это получение выборок данных из СУБД. Для этого в SQL используется оператор SELECT. Оператор SELECT можно выводить данные не только из таблиц базы данных, но и произвольные строки, числа, даты и т.д.

```sql
SELECT id AS alias_id FROM users;

SELECT id alias_id FROM users;
```
- В случае, если мы хотим вывести какие-то столбцы таблицы, но чтобы в итоговой выборке они были названы иначе, мы можем использовать псевдонимы (их также называют алиасами). Их синтаксис достаточно простой, мы должны использовать оператор AS. Или же можно обойтись и без него, просто написав желаемое наименование поля через пробел. Псевдонимы могут содержать до 255 знаков (включая пробелы, цифры и специальные символы).

```sql
SELECT 'Hello world'

SELECT 'Hello', 'world'
```
- Если предложение FROM опущено, то оператор SELECT вернет ровно одну строку со значениями, состоящими из констант, строковых литералов, результатов вызовов функций и операций над всем вышеперечисленным.

### 2.2 WHERE

Для ограничения количества возвращаемых строк в SQL существует предложение WHERE. В WHERE указывается логическое выражение, которое служит фильтром строк: в результате остаются только те строки, для которых это выражение истинно.

```sql
SELECT * FROM orders WHERE total_amount > 100;
```
- Условный оператор WHERE используется для фильтрации результатов запроса в соответствии с определенным условием.

### 2.4 HAVING

HAVING - необязательный элемент запроса, который отвечает за фильтрацию на уровне сгруппированных данных (по сути, WHERE, но только на уровень выше). 

```sql
SELECT City, COUNT(CustomerID) 
FROM Customers 
GROUP BY City 
HAVING COUNT(CustomerID) >= 5;
```
- Фильтрация агрегированной таблицы с количеством клиентов по городам, в данном случае оставляем в выгрузке только те города, в которых не менее 5 клиентов.

```sql
SELECT City, COUNT(CustomerID) as number_of_clients 
FROM Customers 
WHERE CustomerName not in ('Around the Horn', 'Drachenblut Delikatessend') 
GROUP BY City 
HAVING COUNT(CustomerID) >= 1;
```
- Пример запроса, содержащего WHERE и HAVING. В данном запросе сначала фильтруется исходная таблица по пользователям, рассчитывается количество клиентов по городам и остаются только те города, где количество клиентов не менее 1.

### 2.5 CREATE TABLE

Для создания таблицы используется оператор CREATE TABLE.

```sql
CREATE TABLE [IF NOT EXIST] имя_таблицы (
     столбец_1 тип_данных,
    [столбец_2 тип_данных,]
    ...
    [столбец_n тип_данных,]
);
```
- Структура запроса.

```sql
CREATE TABLE products (
    id INT PRIMARY KEY,
    price DECIMAL(10, 2),
    category VARCHAR(255),
    size_id INT
    FOREIGN KEY (size_id) REFERENCES sizes(id)
);
```
- Пример создания таблицы с внешним ключом.

```sql
CREATE TABLE Goods (
	good_id INT NOT NULL AUTO_INCREMENT  -- MySQL
	good_id SERIAL  -- PostgreSQL
);
```
- Механизм автоматической генерации уникального идентификатора в MySQL и PostgreSQL.

```sql
CREATE TABLE ordering AS
SELECT author, title, 5 AS amount
FROM book
WHERE amount < 4;
```
- Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос `SELECT`, результирующая таблица которого и будет новой таблицей базы данных. При этом имена столбцов запроса становятся именами столбцов новой таблицы.

**CHECK constraint**

**CHECK constraint** - это ограничение, которое позволяет задавать условия для значений столбца. Оно гарантирует, что данные, вводимые в таблицу, соответствуют определённым критериям, тем самым поддерживая целостность данных.

```sql
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    age INT CHECK (age >= 18)
);
```
- Ограничение, которое гарантирует, что значение столбца `age` в таблице `employees` будет больше или равно 18.

### 2.6 ALTER TABLE

Оператор `ALTER TABLE` используется для изменения структуры таблиц БД.

```sql
ALTER TABLE таблица ADD имя_столбца тип;
```
- Вставить столбец после последнего.

```sql
ALTER TABLE таблица ADD имя_столбца тип FIRST;
```
- Вставить столбец перед первым.

```sql
ALTER TABLE таблица ADD имя_столбца тип AFTER имя_столбца_1;
```
- Вставить столбец после укзанного столбца.

```sql
ALTER TABLE таблица DROP COLUMN имя_столбца;
-- Или
ALTER TABLE таблица DROP имя_столбца;

ALTER TABLE таблица DROP имя_столбца, DROP имя_столбца_1;
```
- Удалить столбец с заданным именем. Ключевое слово COLUMN не обязательно указывать. Также можно удалить два столбца.

```sql
ALTER TABLE таблица CHANGE имя_столбца новое_имя_столбца ТИП ДАННЫХ;

ALTER TABLE таблица CHANGE имя_столбца имя_столбца НОВЫЙ_ТИП_ДАННЫХ;
```
- Запрос для переименования столбца. Для изменения типа столбца используется запрос (два раза указывать имя столбца обязательно).

### 2.7 CONSTRAINT

```sql
CREATE INDEX idx_customer_name ON customers (customername);

ALTER TABLE orders 
ADD CONSTRAINT fk_customerid 
FOREIGN KEY (customerid) 
REFERENCES customers(customerid);
```
- CONSTRAINT используется для ограничения целостности данных в базе данных.
### 2.8 GROUP BY

**Группировка данных** - это процедура объединения в логическом порядке строк с определенными значениями.

GROUP BY - необязательный элемент запроса, с помощью которого можно задать агрегацию по нужному столбцу (например, если нужно узнать какое количество клиентов живет в каждом из городов).

При использовании GROUP BY мы можем выводить только:

- литералы, т.е. указанное явным образом фиксированные значения.
- результаты агрегатных функций, т.е. вычисленные значения на основании набора значений.
- поля группировки.

При использовании GROUP BY обязательно:

1. перечень столбцов, по которым делается разрез, был одинаковым внутри SELECT и внутри GROUP BY,
2. агрегатные функции (SUM, AVG, COUNT, SELECT family_member, member_name FROM Payments
INNER JOIN FamilyMembers
    ON Payments.family_member = FamilyMembers.member_idMAX, MIN) должны быть также указаны внутри SELECT с указанием столбца, к которому такая функция применяется.

```sql
SELECT City, COUNT(CustomerID) 
FROM Customers 
GROUP BY City;
```
- Группировка количества клиентов по городу.

```sql
SELECT Country, City, COUNT(CustomerID) 
FROM Customers 
GROUP BY Country, City;
```
- Группировка количества клиентов по стране и городу.

```sql
SELECT ProductID, COUNT(OrderID), SUM(Quantity) 
FROM OrderDetails 
GROUP BY ProductID;
```
- Группировка продаж по ID товара с разными агрегатными функциями: количество заказов с данным товаром и количество проданных штук товара.

```sql
SELECT City, COUNT(CustomerID) 
FROM Customers 
WHERE Country = 'Germany' 
GROUP BY City;
```
- Группировка продаж с фильтрацией исходной таблицы. В данном случае на выходе будет таблица с количеством клиентов по городам Германии.

```sql
SELECT City, COUNT(CustomerID) AS Number_of_clients 
FROM Customers 
GROUP BY City;
```
- Переименование столбца с агрегацией с помощью оператора AS. По умолчанию название столбца с агрегацией равно примененной агрегатной функции, что далее может быть не очень удобно для восприятия.

### 2.9 JOIN

Оператор JOIN используется для объединения таблиц по ключу, который присутствует в обеих таблицах.

В большинстве случаев условием соединения является равенство столбцов таблиц (таблица_1.поле = таблица_2.поле), однако точно так же можно использовать и другие операторы сравнения.

```sql
SELECT поля_таблиц
FROM таблица_1
[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_2
ON условие_соединения
[[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_n
ON условие_соединения]
```
- Общая структура многотабличного запроса.

```sql
SELECT family_member, member_name
FROM Payments
INNER JOIN FamilyMembers
ON Payments.family_member = FamilyMembers.member_id
-- OR
SELECT family_member, member_name
FROM Payments, FamilyMembers
WHERE Payments.family_member = FamilyMembers.member_id
```
- Аналогичные запросы. Внутреннее соединение можно выполнить не используя ключевое слово `JOIN`. Для этого достаточно сделать декартово произведение строк таблиц, а условия соединения прописать в предложении `WHERE`.

**ТИПЫ JOIN**

- **INNER JOIN** (**JOIN**): внутреннее соединение. Каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы. Для полученной строки проверяется условие соединения. Если условие истинно, в таблицу результата добавляется соответствующая строка. В результате остаются только те строки, для которых нашлось соответствие.
- **LEFT JOIN**: левое внешнее соединение. Работает как **JOIN**, но если для строки таблицы, находящейся по левую сторону ключевого слова LEFT JOIN, не нашлось ни одной строки в таблице, находящейся по правую сторону LEFT JOIN, то строка все равно добавляется в результат, а значения столбцов правой таблицы равны `null`.
- **RIGHT JOIN**: правое внешнее соединение. Как LEFT JOIN, но наоборот.
- **FULL JOIN**: полное внешнее соединение. Если для какой-либо из таблиц не нашлось строки в другой таблице, то строка все равно попадает в результат, а значения столбцов другой таблицы равны `null`.
- **CROSS JOIN**: перекрестное (декартово) произведение. Каждая строка одной таблицы соединяется с каждой строкой другой таблицы, формируя в результате все возможные сочетания строк двух таблиц. Аналогичного результата можно достичь просто перечислив таблицы в FROM через запятую.

Соединение FULL JOIN реализовано не во всех СУБД. Например, в MySQL оно отсутствует, однако его можно очень просто эмулировать.

```sql
SELECT Timepair.id 'timepair.id', start_pair, end_pair,
Schedule.id 'schedule.id', date, class, number_pair, teacher, subject, classroom
FROM Timepair
LEFT JOIN Schedule ON Schedule.number_pair = Timepair.id;
```
- Для примера получим из базы данных расписание звонков, объединённых с соответствующими занятиями в расписании занятий. В выборку попали все строки из левой таблицы, дополненные данными о занятиях. В конце таблицы есть строки с полями, заполненными NULL. Это те строки, для которых не нашлось соответствующих занятий, однако они присутствуют в левой таблице, поэтому тоже были выведены.

```sql
SELECT e.first_name, e.last_name, r.rank_id, r.store_id, r.name as rank_name
FROM employee e
JOIN rank r
ON r.rank_id = e.rank_id
AND r.store_id = e.store_id
LIMIT 5
```
- В условии соединения таблиц можно использовать произвольное количество логических выражений (как в предложении WHERE).
- Получим информацию о должностях произвольных 5-ти сотрудников. Чтобы найти информацию о должности сотрудника, нужно из таблицы rank взять строку с таким же идентификатором магазина и идентификатором должности в магазине.

**Использование таблицы несколько раз**

```sql
SELECT pp.product_id, pp.store_id, pp.price, ppl.store_id AS store_id_less, ppl.price AS price_less
FROM product_price pp
JOIN product_price ppl
ON ppl.product_id = pp.product_id
AND ppl.store_id != pp.store_id
AND ppl.price < pp.price
ORDER BY pp.product_id, pp.store_id, ppl.store_id, ppl.price
```
- Одну и ту же таблицу необходимо использовать в запросе несколько раз, то необходимо воспользоваться псевдонимами для таблиц. Например, для каждой стоимости товара в магазине найдем предложение на такой же товар в другом магазине по меньшей цене.
- Берутся все строки из таблицы product_price. Дальнейшее обращение к этому набору строк происходит через pp.
- Для каждой строки из пункта 1 просматривается еще раз все строки таблицы product_price. Обращение к строкам последней происходит через ppl.
- Если цена price у строки из второй копии product_price меньше, чем у строки из первой копии product_price, то связка этих строк добавляется в результат выполнения запроса.
- В конце результат сортируется согласно ORDER BY.

```sql
SELECT  name_author, name_genre
FROM 
    author 
    INNER JOIN book ON author.author_id = book.author_id
    INNER JOIN genre ON  book.genre_id = genre.genre_id
GROUP BY name_author,name_genre, genre.genre_id
HAVING genre.genre_id IN
         (
          SELECT query_in_1.genre_id
          FROM 
              (
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
               ) query_in_1
          INNER JOIN 
              (
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
                ORDER BY sum_amount DESC
                LIMIT 1
               ) query_in_2
          ON query_in_1.sum_amount= query_in_2.sum_amount
         );   
```
- Вложенные запросы могут использоваться в операторах соединения `JOIN`.  При этом им необходимо присваивать имя, которое записывается сразу после закрывающей скобки вложенного запроса.
- Вложенный запрос может стоять как справа, так и слева от оператора `JOIN`. Допускается использование двух запросов в операторах соединения.

**USING**

При описании соединения таблиц с помощью **JOIN** в некоторых случаях вместо **`ON`** и следующего за ним условия можно использовать оператор **USING**.

**USING** позволяет указать набор столбцов, которые есть в обеих объединяемых таблицах. Если база данных хорошо спроектирована, а каждый внешний ключ имеет такое же имя, как и соответствующий первичный ключ (например, `genre.genre_id = book.genre_id`), тогда можно использовать предложение **USING** для реализации операции **JOIN**.

```sql
SELECT title, name_author, author_id
FROM 
    author INNER JOIN book
    USING(author_id);
```

### 2.10 DISTINCT

Иногда в таблицах встречаются дубликаты, как например имена сотрудников. Для исключения повторяющихся строк, нужно после ключевого слова SELECT написать DISTINCT. DISTINCT может применяться для нескольких колонок.

```sql
SELECT DISTINCT id FROM users;

SELECT DISTINCT id, name FROM users;
```

### 2.11 DELETE, TRUNCATE

Для удаления записей в таблицах существует DELETE и TRUNCATE. Если условие отбора записей WHERE отсутствует, то будут удалены все записи указанной таблицы.

```sql
DELETE FROM имя_таблицы
[WHERE условие_отбора_записей];
```
- Общая структура запроса DELETE.

TRUNCATE выполняет удаление таблицы и пересоздает её заново - этот вариант работает гораздо быстрее, чем удаление всех записей одна за другой (как в случае с DELETE) особенно для больших таблиц.

```sql
TRUNCATE TABLE имя_таблицы;
```
- Общая структура запроса TRUNCATE.

> Оптимизатор запросов СУБД MySQL автоматически использует оператор TRUNCATE, если оператор DELETE не содержит условия WHERE или конструкции LIMIT.

Однако у оператора TRUNCATE есть ряд отличий:

- Не срабатывают триггеры, в частности, триггер удаления
- Удаляет все строки в таблице, не записывая при этом удаление отдельных строк данных в журнал транзакций
- Сбрасывает счётчик идентификаторов до начального значения
- Чтобы использовать, необходимы права на изменение таблицы

```sql
DELETE имя_таблицы_1 [, имя_таблицы_2] FROM
имя_таблицы_1 JOIN имя_таблицы_2
ON имя_таблицы_1.поле = имя_таблицы_2.поле
[WHERE условие_отбора_записей];
```
- Удаление записей при многотабличных запросах.

Если в DELETE запросе используется JOIN, то необходимо указать из каких(ой) именно таблиц(ы) требуется удалять записи.

```sql
DELETE Reservations FROM
Reservations JOIN Rooms ON
Reservations.room_id = Rooms.id
WHERE Rooms.has_kitchen = false;
```
- Удаление всех броней жилья, в котором отсутствует кухня.

```sql
DELETE Reservations, Rooms FROM
Reservations JOIN Rooms ON
Reservations.room_id = Rooms.id
WHERE Rooms.has_kitchen = false;
```
- Помимо удаления бронирования, удаление и жилья.

### 2.12 IS NULL, BETWEEN, IN

Оператор IS NULL позволяет узнать равно ли проверяемое значение NULL, т.е. пустое ли значение.

```sql
SELECT * FROM Teacher
WHERE middle_name IS NOT NULL;
```

Оператор BETWEEN min AND max позволяет узнать расположено ли проверяемое значение столбца в интервале между min и max, включая сами значения min и max.

```sql
SELECT * FROM Payments
WHERE unit_price BETWEEN 100 AND 500;
```

Оператор IN позволяет узнать входит ли проверяемое значение столбца в список определённых значений.

```sql
SELECT * FROM FamilyMembers
WHERE status IN ('father', 'mother');
```

### 2.13 LIKE

Оператор LIKE используется при условных запросах, когда мы хотим узнать соответствует ли строка определённому шаблону.

В шаблоне LIKE можно использовать два спецсимвола:

- `_` - заменяет один любой символ;
- `%` - заменяет любую последовательность символов (в том числе пустую)

```sql
'abc' LIKE 'abc'    true
'abc' LIKE 'a%'     true
'abc' LIKE '_b_'    true
'abc' LIKE 'c'      false
```
- Примеры

```sql
SELECT name, email FROM users
WHERE email LIKE '%@hotmail.%'
```
- Пример использования оператора LIKE

При проверке по шаблону `LIKE` всегда рассматривается вся строка. Поэтому, если нужно найти последовательность символов где-то в середине строки, шаблон должен начинаться и заканчиваться знаком `%`.

Чтобы найти в строке буквальное вхождение знака процента или подчёркивания, перед соответствующим символом в шаблоне нужно добавить спецсимвол. По умолчанию в качестве спецсимвола выбрана обратная косая черта `\`, но с помощью предложения `ESCAPE` можно выбрать и другой. Чтобы включить спецсимвол в шаблон поиска, продублируйте его. Синтаксис `LIKE` с указанием спецсимвола:

```sql
'_asdfa' LIKE '$_asd%' ESCAPE '$'
```

Вместо `LIKE` можно использовать ключевое слово `ILIKE`, чтобы поиск был регистр-независимым с учётом текущей языковой среды.

### 2.14 REGEXP

Оператор REGEXP (или его синоним RLIKE) в SQL используется для поиска и обработки строковых данных с помощью регулярных выражений. Регулярные выражения предоставляют мощные возможности для сложных шаблонов поиска, которые трудно реализовать с помощью оператора LIKE.

```sql
SELECT * FROM Users WHERE name REGEXP '^John'
```
- Это выражение ищет строки, начинающиеся с «John». Символ ^ указывает на начало строки.

```sql
SELECT * FROM  Subject WHERE name REGEXP '[ey]$'
```
- В этом примере, `[ey]` определяет список возможных значений для паттерна $, определяющего на что должна заканчиваться строка.

```sql
SELECT * FROM Users WHERE phone_number REGEXP '^[^28]*$'
```
- В этом примере символ `[^28]` обозначает любой символ, кроме «2» и «8», а * означает любое количество таких символов. Символы ^ и $ указывают на начало и конец строки соответственно, гарантируя, что вся строка соответствует шаблону.

### 2.15 ORDER BY

При выполнении SELECT запроса, строки по умолчанию возвращаются в неопределённом порядке. Фактический порядок строк в этом случае зависит от плана соединения и сканирования, а также от порядка расположения данных на диске, поэтому полагаться на него нельзя. Для упорядочивания записей используется конструкция ORDER BY.

ASC и DESC - направление сортировки:

- ASC - сортировка по возрастанию (по умолчанию)
- DESC - сортировка по убыванию

```sql
SELECT store_id, name
FROM store
ORDER BY name
```
- Сортировка по возрастанию

```sql
SELECT store_id, name
FROM store
ORDER BY name DESC
```
- Сортировка по убыванию

```sql
SELECT employee_id, rank_id, last_name
FROM employee
ORDER BY rank_id ASC, last_name DESC
```
- Сортировка по нескольким столбцам. Данные будут сортироваться по первому столбцу, но в случае если попадаются несколько записей с совпадающими значениями в первом столбце, то они сортируются по второму столбцу

### 2.16 LIMIT, OFFSET

Конструкция LIMIT позволяет получить только часть строк от результата запроса.

Применяя LIMIT, важно использовать также предложение ORDER BY, чтобы строки результата выдавались в определённом порядке. Иначе будут возвращаться непредсказуемые подмножества строк. Вы можете запросить строки с десятой по двадцатую, но какой порядок вы имеете в виду? Порядок будет неизвестен, если не добавить ORDER BY.

> Оператор LIMIT реализован не во всех СУБД, например, в MSSQL для вывода записей с начала таблицы используется оператор TOP, а для тех случаев, когда необходимо сделать отступ от начала таблицы, предназначена конструкция OFFSET FETCH.

В дополнение к LIMIT можно пропустить определенное количество строк из результата запроса. Для этого после предложения LIMIT нужно написать OFFSET и сколько строк пропустить.

```sql
SELECT store_id, name
FROM store
ORDER BY name
LIMIT 3
OFFSET 3
```

### 2.17 WITH

**Обобщённое табличное выражение или CTE (Common Table Expressions)** - это временный результирующий набор данных, к которому можно обращаться в последующих запросах. Для написания обобщённого табличного выражения используется оператор WITH.

Обобщённые табличные выражения были добавлены в SQL для упрощения сложных длинных запросов, особенно с множественными подзапросами. Их главная задача – улучшение читабельности, простоты написания запросов и их дальнейшей поддержки. Это происходит за счёт сокрытия больших и сложных запросов в созданные именованные выражения, которые потом используются в основном запросе.

Выражение с WITH считается временным, потому что результат не сохраняется где-либо на постоянной основе в схеме БД, а действует как временное представление, которое существует только на время выполнения запроса, то есть оно доступно только во время выполнения операторов SELECT, INSERT, UPDATE, DELETE или MERGE. Оно действительно только в том запросе, которому он принадлежит, что позволяет улучшить структуру запроса, не загрязняя глобальное пространство имён.

```sql
WITH Aeroflot_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot"),
    Don_avia_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Don_avia")

SELECT plane, COUNT(plane) AS amount
FROM Aeroflot_trips
GROUP BY plane;
```
- Создаём табличное выражение Aeroflot_trips, содержащие все полёты, совершенные авиакомпанией Aeroflot. Аналогично, создаём табличное выражение Aeroflot_trips, но с переименованными колонками. С помощью оператора WITH определяем несколько табличных выражений.

### 2.18 UNION

`UNION` используется для объединения двух SQL запросов. `UNION` по умолчанию убирает повторения в результирующей таблице. Для отображения с повторением есть необязательный параметр `ALL`. 

`UNION ALL` работает быстрее, чем `UNION`, но может показаться медленным, поскольку возвращает больше данных, которые требуют больше времени для перемещения по сети.

Для корректной работы `UNION` нужно, чтобы результирующие таблицы каждого из SQL запросов имели одинаковое число столбцов, с одним и тем же типом данных и в той же самой последовательности.

```sql
SELECT поля_таблиц FROM список_таблиц ...
UNION [ALL]
SELECT поля_таблиц FROM список_таблиц ... ;
```
- Общая структура запроса с оператором UNION.

### 2.19 CASE

**CASE** - это конструкция в SQL, позволяющая выполнять условные операции в запросах. Она используется для создания выражений, которые могут принимать различные значения в зависимости от условий.

```sql
CASE column_name
    WHEN value1 THEN result1
    WHEN value2 THEN result2
    ...
    ELSE default_result
END
```
- Простая конструкция (Simple CASE) `CASE` используется, когда нужно проверить одно выражение на равенство нескольким возможным значениям.
- Если value1 возвращает истинное значение, то выражение CASE вернёт result1, иначе будет сделана проверка на value2 и т.д. Если ни одно из предложенных условий не будет выполнено, то вернётся NULL или default_result, если была использована конструкция ELSE.

```sql
SELECT employee_id, name, salary,
    CASE salary
        WHEN salary < 30000 THEN 'Low'
        WHEN salary BETWEEN 30000 AND 60000 THEN 'Medium'
        WHEN salary > 60000 THEN 'High'
        ELSE 'Not Specified'
    END AS salary_category
FROM employees;
```
- Преобразование уровней заработной платы в категории.

```sql
CASE 
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
    ...
    ELSE default_result
END
```
- Конструкция поиска (Searched CASE) `CASE` позволяет использовать более сложные условия, например, с операторами `AND` и `OR`.

```sql
SELECT employee_id, name, age,
    CASE 
        WHEN age < 18 THEN 'Minor'
        WHEN age BETWEEN 18 AND 65 THEN 'Adult'
        WHEN age > 65 THEN 'Senior'
        ELSE 'Not Specified'
    END AS age_category
FROM employees;
```
- Присвоение категории работникам на основе их возраста.


**IF, IFNULL, NULLIF**

```sql
IF(условное_выражение, значение_1, значение_2);
```
- Если условное выражение, передаваемое в качестве первого аргумента в функцию IF, истинно, функция вернёт значение второго аргумента значение_1, иначе возвращается значение третьего аргумента значение_2. Функции IF можно также вкладывать друг в друга, эмулируя оператор CASE.

```sql
IFNULL(значение, альтернативное_значение);
```
- Функция IFNULL возвращает значение, переданное первым аргументом, если оно не равно NULL, иначе возвращает альтернативное_значение.

```sql
NULLIF(значение_1, значение_2);
```
- Функция NULLIF возвращает NULL, если значение_1 равно значению_2, в противном случае возвращает значение_1.

### 2.20 INSERT

Для добавления новых записей в таблицу предназначен оператор INSERT. 

Следует помнить, что первичный ключ таблицы является уникальным значением и добавление уже существующего значения приведёт к ошибке.

```sql
INSERT INTO имя_таблицы [(поле_таблицы, ...)]
VALUES (значение_поля_таблицы, ...)
| SELECT поле_таблицы, ... FROM имя_таблицы ...
```
- Значения можно вставлять перечислением с помощью слова VALUES, перечислив их в круглых скобках через запятую или c помощью оператора SELECT.

```sql
INSERT INTO products (id, price, category) VALUES
(1, 100, 'Category A'),
(2, 200, 'Category B'),
(3, 300, 'Category C');
```
- Пример добавления записей в таблицы, используя VALUES.

```sql
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply;
```
- С помощью запроса на добавление можно не только добавить в таблицу конкретные значения (список `VALUES`), но и записи из другой таблицы, отобранные с помощью запроса на выборку.  В этом случае вместо раздела `VALUES` записывается запрос на выборку, начинающийся с `SELECT`.  В нем можно использовать `WHERE, GROUP BY, ORDER BY`.

Правила соответствия между полями таблицы и вставляемыми значениями из запроса:

- Количество полей в таблице и количество полей в запросе должны совпадать.
- Должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках (первый столбец запроса должен относиться к первому столбцу в списке столбцов таблицы, второй - ко второму столбцу и т.д.).
- При добавлении значений SQL пытается преобразовать их к типу данных поля, например, при занесении строки '1' в числовое поле, вставляемое значение преобразуется к целому числу 1, если же попытаться занести строку 'ab' в числовое поле - возникнет ошибка и строка не будет добавлена.
- Но желательно, во избежание ошибок, следовать правилу "типы данных элементов в списке значений должны быть совместимы с типами данных соответствующих столбцов таблицы" (целое число можно занести в поле типа DECIMAL, обратная операция приведет к округлению вещественного значения, что может повлиять на корректность данных).
- Новые значения не рекомендуется добавлять в поля, описанные как `PRIMARY KEY AUTO_INCREMENT;`
- Рекомендуется заполнять все поля записи, если же поле пропущено, значение этого поля зависит от установленных по умолчанию значений, если значения не установлены в поле вставляется пустое значение (`NULL`).

**ИСПОЛЬЗОВАНИЕ ВЛОЖЕННЫХ ЗАПРОСОВ ПРИ ДОБАВЛЕНИИ**

```sql
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply
WHERE title NOT IN (
        SELECT title 
        FROM book
      );

SELECT * FROM book;
```
- Занести из таблицы `supply` в таблицу `book` только те книги, названия которых отсутствуют в таблице `book`.

**СВЯЗАННЫЕ ТАБЛИЦЫ В ЗАПРОСАХ НА ДОБАВЛЕНИЕ**

Запросом на добавление можно добавить записи, отобранные с помощью запроса на выборку, который включает несколько таблиц.

```sql
INSERT INTO author (name_author)
SELECT supply.author
FROM author
RIGHT JOIN supply
ON author.name_author = supply.author
WHERE author.name_author IS NULL;
```
- В таблице `supply`  есть новые книги, которых на складе еще не было. Прежде чем добавлять их в таблицу `book`,  необходимо из таблицы `supply` отобрать новых авторов, если таковые имеются.
- Выполнив правое внутреннее соединение таблиц, получили значение `Null (None)` в поле `name_author` в строке того автора, которого нет в таблице `author`, в нашем случае это Стивенсон.

### 2.21 UPDATE

Для редактирования существующих записей в таблицах существует SQL оператор UPDATE.

```sql
UPDATE имя_таблицы
SET поле_таблицы1 = значение_поля_таблицы1,
    поле_таблицыN = значение_поля_таблицыN
[WHERE условие_выборки]
```
- Общая структура запроса.

```sql
UPDATE FamilyMembers
SET member_name = "Andie Anthony"
WHERE member_name = "Andie Quincey";
```
- Изменение имени у определенных записей. Если не указать where, то будут обновлены все записи.

```sql
UPDATE Payments
SET unit_price = unit_price * 2;
```
- В запросах на обновление данных можно менять значения, опираясь на предыдущее значение. Разрешается также значения одних столбцов присваивать другим столбцам. Но типы столбцов должны быть совместимыми.

**ОБНОВЛЕНИЕ НЕСКОЛЬКИХ ТАБЛИЦ**

```sql
UPDATE book, supply 
SET book.amount = book.amount + supply.amount
WHERE book.title = supply.title AND book.author = supply.author;
```
- Если в таблице `supply`  есть те же книги, что и в таблице `book`, добавлять эти книги в таблицу `book` не имеет смысла. Необходимо увеличить их количество на значение столбца `amount`таблицы `supply`.

**СВЯЗАННЫЕ ТАБЛИЦЫ В ЗАПРОСАХ НА ОБНОВЛЕНИЕ**

В запросах на обновление можно использовать связанные таблицы. Исправлять данные можно во всех используемых в запросе таблицах.

```sql
UPDATE 
	book 
	JOIN author 
	ON author.author_id = book.author_id
    JOIN supply 
    ON book.title = supply.title and supply.author = author.name_author
SET 
	book.amount = book.amount + supply.amount,
	supply.amount = 0   
WHERE
	book.price = supply.price;
```
- Для книг, которые уже есть на складе (в таблице `book`) по той же цене, что и в поставке (`supply`), увеличить количество на значение, указанное в поставке, а также обнулить количество этих книг в поставке.

## 3 Группы SQL операторов

### 3.1 DDL

DDL (Data Definition Language) - операторы определения данных. Они работают с объектами, то есть с целыми таблицами. Если базу нужно дополнить таблицей с новыми данными или, наоборот, убрать одну из таблиц с ошибочными данными - используется этот набор операторов.

- `CREATE` - создание объекта в базе данных
- `ALTER` - изменение объекта
- `DROP` - удаление объекта

### 3.2 DML

DML (Data Manipulation Language) - операторы манипуляции данными. Эти операторы уже работают с содержимым таблиц - строками, атрибутами и значениями. С их помощью можно вносить изменения в конкретное значение. Например, заменить поле в колонке «Фамилия» в строке с данными сотрудницы компании посте того, как она вышла замуж. Или удалить строку с данными уволенного сотрудника.

- `SELECT` - выбор данных в соответствии с условием
- `INSERT` - добавление новых данных
- `UPDATE` - изменение существующих данных
- `DELETE` - удаление данных

### 3.3 DCL

DCL (Data Control Language) - оператор определения доступа к данным. Он определяет, кто из пользователей может отправлять запросы к базе, менять объекты и значения. Например, можно отозвать доступ у сотрудника, перешедшего в другой отдел, а также открыть доступ к базе новому маркетологу или разработчику.

- `GRANT` - предоставление доступа к объекту
- `REVOKE` - отзыв ранее выданного разрешения
- `DENY` - запрет, который является приоритетным над разрешением

### 3.4 TCL

TCL (Transaction Control Language) - язык управления транзакциями. Транзакции - это набор команд, которые выполняются поочередно. Если все команды выполнены, транзакция считается успешной, а если где-то произошла ошибка — транзакция откатывается назад, отменяя все выполненные команды. Наглядный пример такой транзакции - оплата онлайн, когда банк просит сначала ввести сумму и получателя, затем проверить и подтвердить операцию, а после ввести одноразовый код. На каждом из этих этапов оплату можно отменить и транзакция откатится назад.

- `BEGIN TRANSACTION` - обозначение начала транзакции
- `COMMIT TRANSACTION` - изменение команд внутри транзакции
- `ROLLBACK TRANSACTION` - откат транзакции
- `SAVE TRANSACTION` - указание промежуточной точки сохранения внутри транзакции

## 2 Порядок выполнения запроса

```sql
FROM
JOIN
WHERE
GROUP BY
HAVING
SELECT
ORDER BY
```
- Порядок выполнения запросов на выборку.

## Встроенные функции

- [Встроенные функции Postgres](https://postgrespro.ru/docs/postgresql/16)

**Встроенная функция** - это реализованный в СУБД код, с помощью которого можно выполнять преобразования строковых, числовых и других данных в запросах.

Каждая функция принимает набор аргументов определённого типа, выполняет заложенные в неё операции и обязательно возвращает один из возможных литералов.

Функции можно применять не только над литералами, но и над значениями, взятыми из таблицы. При этом функция выполняет преобразования для каждой строки отдельно.

```sql
SELECT UPPER("Hello world") AS upper_string;
```
- Функция 

```sql
SELECT SIGN(-69), SIGN(0), SIGN(69);
```
- Функция SIGN возвращает значение -1, если число отрицательно, 0, если число нулевое и 1, если число положительное.

```sql
SELECT ROUND(1691.7,-1), ROUND(1691.7,2), ROUND(1691.7);
```
- Для округления к ближайшему целому числу есть функция ROUND, которая любое число, десятичная часть которого больше или равна 0.5, округляет в большую сторону, иначе в меньшую.

**Дата и время**

Временные данные можно получить одним из следующих способов:

- скопировать данные из существующего столбца с временным типом данных
- задать дату и время через строковое представление
- получить временны́е данные путём вызова встроенных функций, возвращающих временной тип данных

При указании даты допускается использовать любой знак пунктуации в качестве разделительного между частями разделов даты или времени. Также возможно задавать дату вообще без разделительного знака, слитно.

```sql
SELECT  CAST("2022-06-16 16:37:23" AS DATETIME) AS datetime_1,
        CAST("2014/02/22 16*37*22" AS DATETIME) AS datetime_2,
        CAST("20220616163723" AS DATETIME) AS datetime_3,
        CAST("2021-02-12" AS DATE) AS date_1,
        CAST("160:23:13" AS TIME) AS time_1,
        CAST("89" AS YEAR) AS year
```
- Примеры валидного задания временных значений через строковое представление. Для принудительного преобразования строки в дату и время использована функция CAST. Она необходима, если сервер не ожидает временного значения и, соответственно, автоматически не преобразует строку к нужному типу.

```sql
SELECT STR_TO_DATE('November 13, 1998', '%M %d, %Y') AS date;
```
- Если необходимо получить временные данные из строки, которая не соответствует ни одному формату, который принимает функция CAST, то можно использовать встроенную функцию STR_TO_DATE, которая принимает произвольную строку, содержащую дату, и формат, описывающий её.

```sql
SELECT CURDATE(), CURTIME(), NOW();
```
- Функции для генерации же текущей даты или времени.

**Отличие DATETIME от TIMESTAMP**

Они оба направлены на хранение даты и времени, но имеют ряд отличий, определяющих их целевое использование.

| Критерий     | DATETIME                                                                       | TIMESTAMP                                                                              |
| :----------- | :----------------------------------------------------------------------------- | :------------------------------------------------------------------------------------- |
| Диапазон     | от 1000-01-01 00:00:00  <br>до 9999-12-31 23:59:59                             | от 1970-01-01 00:00:00  <br>до 2038-01-19 03:14:07                                     |
| Часовой пояс | Не учитывается  <br>Отображается в таком виде, в котором дата была установлена | Учитывается  <br>При выборках отображается с учётом текущего часового пояса сервера БД |

- COALESCE: Функция принимает список аргументов и возвращает первый, который не равен NULL.
- ISNULL: Функция принимает два аргумента. Если первый аргумент равен NULL, то возвращает второй аргумент, иначе возвращает первый аргумент.
- MONTH: Функция принимает дату и возвращает месяц из этой даты.
- YEAR: Функция принимает дату и возвращает год.
- DATE: Функция принимает дату и возвращает номер дня.
- HOUR: Функция принимает дату и возвращает час.
- MINUTE: Функция принимает дату и возвращает минуту.

**Математические функции**

- CEILING(x): возвращает наименьшее целое число, большее или равное x (округляет до целого числа в большую сторону)
- ROUND(x, k): округляет значение x до k знаков после запятой, если k не указано – x округляется до целого
- FLOOR(x): возвращает наибольшее целое число, меньшее или равное x (округляет до целого числа в меньшую сторону)
- POWER(x, y): возведение x в степень y
- SQRT(x): квадратный корень из x
- DEGREES(x): конвертирует значение x из радиан в градусы
- RADIANS(x): конвертирует значение x из градусов в радианы
- ABS(x): модуль числа x
- PI(): pi = 3.1415926...

## Агрегатные функции

**Агрегирование** - это объединение нескольких элементов в единое целое.

**Агрегатные функции** - это функции, которые выполняют вычисления над набором строк и возвращают один результат для каждой группы. Они используются с `GROUP BY` для объединения строк в группы и получения одного значения на группу.

- Агрегатные функции возвращают один результат на группу, скрывая исходные строки данных, что отличается от оконных функций, где каждая строка сохраняется.
- Агрегация работает только при задании группировки или на всех строках, если `GROUP BY` не задан.

Агрегатные функции применяются для значений, не равных NULL. Исключением является функция `COUNT(*)`.

**Описание агрегатных функций**

- **SUM**: Сумма значений.
- **AVG**: Среднее значение.
- **COUNT**: Кол-вол записей.
- **MIN**: Минимальное значение.
- **MAX**: Максимальное значение.

```sql
SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type
```
- Запрос с использованием агрегатной функции AVG

## Оконные функции

**Оконные функции** - это функции, которые применяются к набору строк в пределах определенного окна, заданного в запросе, и возвращают результат для каждой строки этого окна. Это позволяет выполнять вычисления (например, сумму, среднее, ранжирование) по группе строк без группировки их в одну строку.

**Окно** - это динамический набор строк, который определяет какие конкретные строки в каждой партиции будут использоваться для вычисления оконной функции для каждой строки. Окно может изменяться от строки к строке.

**Партиции** - это подмножества строк, выделенные для оконной функции на основе одного или нескольких столбцов в таблице. Они служат для сегментации данных, позволяя выполнить более детальный анализ и расчёты вроде агрегации или ранжирования внутри каждой такой группы.

**Сортировка в оконных функциях SQL** позволяет упорядочивать данные внутри определённой группы или окна, обеспечивая более точные и нацеленные агрегатные вычисления. Это особенно полезно при работе с временными рядами, где важен порядок событий, или при ранжировании данных внутри групп.

- В отличие от агрегатных функций, которые сводят данные в одну строку на группу, оконные функции показывают результат для каждой строки.
- Оконные функции позволяют работать с разными диапазонами строк, устанавливаемыми через `PARTITION BY` и `ORDER BY`, а также опцией `ROWS` или `RANGE`.

Если в определении оконной функции отсутствует ROWS/RANGE, тогда окно по умолчанию совпадает с партицией. В этом случае, оконная функция будет обрабатывать все строки внутри партиции, не ограничиваясь подмножеством. Это значит, что результат функции будет одинаков для всех строк внутри той же партиции.

В стандартном SQL-запросе все наборы строк рассматриваются как один сплошной блок данных, для которого и вычисляются агрегатные значения.

Однако, когда применяются оконные функции, запрос сегментируется на группы строк (или окна), и для каждого такого сегмента подсчитываются индивидуальные агрегатные значения.

Это окно, которое подаётся в оконную функцию, может быть:

- всей таблицей
- отдельными партициями таблицы, то есть группой строк на основе одного или нескольких полей
- или даже конкретным диапазоном строк в пределах таблицы или партиции. Например, мы можем определить окно, которое будет передаваться в оконную функцию, как предыдущая + текущая строка таблицы. И тогда для каждой строки значение агрегатной функции будет подсчитываться по-своему, так как данные, которые поступают в функцию будут динамически меняться от строке к строке. Окно будет как бы «скользить» по таблице.

```sql
SELECT <оконная_функция>(<поле_таблицы>)
OVER (
	[PARTITION BY <столбцы_для_разделения>]
	[ORDER BY <столбцы_для_сортировки>]
	[ROWS|RANGE <определение_диапазона_строк>]
)
```
- Синтаксис оконной функции.
- <оконная_функция>(<поле_таблицы>) - используемая оконная функция. Например AVG(price).
- Далее следует OVER, который определяет окно (группу строк), которое будет передаваться в оконную функцию. Если конструкцию OVER () оставить без параметров, то окном будет выступать вся таблица.

Далее внутри OVER следуют 3 необязательных параметра, с помощью которых можно гибко настраивать окно:

- с помощью PARTITION BY <столбцы_для_разделения> выборка делится на непересекающиеся подмножества, где каждое подмножество содержит строки с одинаковыми значениями в одном или нескольких столбцах, образуются партиции.
- с помощью ORDER BY <столбцы_для_сортировки> устанавливается порядок строк внутри окна, особо важную роль играет в оконных функциях ранжирования.
- с помощью ROWS|RANGE <определение_диапазона_строк> формируются диапазоны строк. С помощью этого параметра можно указать сколько строк брать до и после текущей в окно.

```sql
SELECT
    Student.first_name,
    Student.last_name,
    Student_in_class.class,
    COUNT(*) OVER (PARTITION BY Student_in_class.class) AS student_count_in_class
FROM
    Student_in_class
JOIN
	Student ON Student_in_class.student = Student.id;
```
- Получим список студентов и идентификатор класса, в котором они учатся. Вычислим сколько учащихся учится в каждом из классов и выведем эту информацию в новую колонку.
- Выражение PARTITION BY Student_in_class.class разделяет все строки таблицы на партиции по полю class. Так, для каждой из строк в оконную функцию будут подаваться только те строки таблицы, где поле class совпадает с полем class в текущей строке.

```sql
SELECT user_id,
       start_date,
       total AS reservation_price,
       SUM(total) OVER (
           PARTITION BY user_id
           ORDER BY start_date
       ) AS cumulative_total
FROM Reservations;
```
- Проанализируем данные о бронированиях жилых помещений, чтобы выяснить, как менялась общая сумма затраченных средств на аренду для каждого пользователя со временем.
- Данные в рамках партиции отсортированы по дате начала бронирования
- Сумма в рамках партиции накапливается, а не выводится как финальная. Это связано с одной особенностью использования сортировки без явного указания ROWS|RANGE в выражении OVER.
- При использовании ORDER BY, если в блоке ROWS|RANGE ничего не указано, то в оконной функции автоматически применяется правило RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW. Это означает, что окно будет начинаться с первой строки и заканчиваться текущей строкой.

**Возможные определения границ окна**

- UNBOUNDED PRECEDING, все строки, предшествующие текущей
- N PRECEDING, N строк до текущей строки
- CURRENT ROW, текущая строка
- N FOLLOWING, N строк после текущей строки
- UNBOUNDED FOLLOWING, все последующие строки

**Отличие ROWS от RANGE**

При использовании ROWS, определение окна основывается на физическом положении строк относительно текущей строки. Например, 1 PRECEDING означает одну строку до текущей. RANGE, в отличие от ROWS, определяет границы окна на основе значений столбцов, упорядоченных в соответствии с ORDER BY в оконной функции.

Определение окна с помощью ROWS чётко ограничивает количество строк, которые включаются в окно, делая его предсказуемым и конкретным. Границы, определённые с помощью RANGE, могут варьироваться в зависимости от данных, что делает окно гибким, но потенциально менее предсказуемым.

**Виды оконных функций**

Оконные функции можно разделить на 3 группы:

- Агрегатные оконные функции
- Ранжирующие оконные функции
- Оконные функции смещения

**Агрегатные функции** - это функции, которые выполняют на наборе данных арифметические вычисления и возвращают итоговое значение.

- SUM - подсчитывает общую сумму значений;
- COUNT - считает общее количество записей в колонке;
- AVG - рассчитывает среднее арифметическое;
- MAX - находит наибольшее значение;
- MIN - определяет наименьшее значение.

```sql
SELECT id,
	home_type,
	price,
	SUM(price) OVER(PARTITION BY home_type) AS 'Sum',
	COUNT(price) OVER(PARTITION BY home_type) AS 'Count',
	AVG(price) OVER(PARTITION BY home_type) AS 'Avg',
	MAX(price) OVER(PARTITION BY home_type) AS 'Max',
	MIN(price) OVER(PARTITION BY home_type) AS 'Min'
FROM Rooms;
```
- Агрегатные оконные функции

**Ранжирующие оконные функции** - это функции, которые ранжируют значение для каждой строки в окне.

В ранжирующих функциях под ключевым словом OVER обязательным идёт указание условия ORDER BY, по которому будет происходить сортировка ранжирования.

- ROW_NUMBER - возвращает номер строки, используется для нумерации;
- RANK - возвращает ранг каждой строки;
- DENSE_RANK - возвращает ранг каждой строки. Но в отличие от функции RANK, она для одинаковых значений возвращает ранг, не пропуская следующий;

```sql
SELECT id,
	home_type,
	price,
	ROW_NUMBER() OVER(PARTITION BY home_type ORDER BY price) AS 'row_number',
	RANK() OVER(PARTITION BY home_type ORDER BY price) AS 'rank',
	DENSE_RANK() OVER(PARTITION BY home_type ORDER BY price) AS 'dense_rank'
FROM Rooms;
```
- Ранжирующие оконные функции.

**Оконные функции смещения** - это функции, которые позволяют перемещаться и обращаться к разным строкам в окне, относительно текущей строки, а также обращаться к значениям в начале или в конце окна.

- LAG - обращается к данным из предыдущих строк окна. Имеет три аргумента: столбец, значение которого необходимо вернуть, количество строк для смещения (по умолчанию 1), значение, которое необходимо вернуть, если после смещения возвращается значение NULL.
- LEAD - обращается к данным из следующих строк. Аналогично LAG имеет 3 аргумента.
- FIRST_VALUE - возвращает первое значение в окне. В качестве аргумента принимает столбец, значение которого необходимо вернуть.
- LAST_VALUE - возвращает последнее значение в окне. В качестве аргумента принимает столбец, значение которого необходимо вернуть.

```sql
SELECT id,
	home_type,
	price,
	LAG(price) OVER(PARTITION BY home_type ORDER BY price) AS 'lag',
	LAG(price, 2) OVER(PARTITION BY home_type ORDER BY price) AS 'lag_2',
	LEAD(price) OVER(PARTITION BY home_type ORDER BY price) AS 'lead',
	FIRST_VALUE(price) OVER(PARTITION BY home_type ORDER BY price) AS 'first_value',
	LAST_VALUE(price) OVER(PARTITION BY home_type ORDER BY price) AS 'last_value'
FROM Rooms;
```
- Оконные функции смещения.

**Пример использования оконных и агрегатных функций**

Пример сравнения средней зарплаты в отделе с зарплатой каждого сотрудника.

```sql
SELECT 
    employee_id,
    salary,
    department_id,
    AVG(salary) OVER (PARTITION BY department_id) AS avg_department_salary
FROM employees;
```
- С оконной функцией.

```sql
SELECT 
    department_id,
    AVG(salary) AS avg_department_salary
FROM employees
GROUP BY department_id;
```
- С агрегатной функцией.

## Подзапросы

**Подзапросы (Вложенные запросы)** - это запросы SQL, которые выполняются внутри другого запроса. Они позволяют создавать более сложные запросы, разбивая их на логические части, и часто используются для получения промежуточных данных или значений, которые затем применяются в основном запросе. Подзапросы могут быть в `SELECT`, `WHERE`, `FROM` и других частях SQL-запроса.

- Подзапросы разбивают сложные запросы на более мелкие части, что улучшает читаемость и делает запросы проще для понимания.
- Позволяют получать промежуточные результаты и использовать их в основном запросе, что упрощает построение сложных условий.
- Подзапросы упрощают выполнение сложных фильтраций и вычислений (например, вычисление максимума или среднего в подзапросе).
- Подзапросы могут быть медленнее, особенно если они коррелированные (то есть выполняются для каждой строки внешнего запроса).

### Скалярные подзапросы

Вложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей `WHERE` как обычное значение совместно с операциями `=, <>, >=, <=, >, <`.

```sql
SELECT name
FROM employees
WHERE salary = (SELECT MAX(salary) FROM employees);
```
- Возвращают одно значение. Применяются в таких выражениях, как `WHERE`, `SELECT`, `HAVING`.

```sql
SELECT * FROM FamilyMembers
WHERE birthday = (SELECT MAX(birthday) FROM FamilyMembers);
```
- С помощью данного запроса можно получить самого младшего члена семьи. Подзапрос в данном случае необходим для получения максимальной даты рождения, которая затем используется в основном запросе для фильтрации строк. При использовании результата подзапроса с операторами сравнения, важно, чтобы подзапрос возвращал именно скалярное значение (1 строка и 1 колонка).

```sql
SELECT * FROM Reservations
WHERE Reservations.room_id = (
	SELECT id FROM Rooms ORDER BY price DESC LIMIT 1
)
```
- Получим список всех бронирований самого дорогого на данный момент жилого помещения. В данном случае запрос на получение самого дорогого жилого помещения выполняется в качестве подзапроса, а затем результат результирующего набора применяется в основном запросе.

### Многострочные подзапросы

Если подзапрос возвращает более одной строки, его нельзя просто использовать с операторами сравнения. Однако c подзапросами, возвращающими несколько строк и один столбец, можно использовать 3 дополнительных оператора.

```sql
SELECT name
FROM employees
WHERE department_id IN (SELECT id FROM departments WHERE location = 'New York');
```
- Возвращают несколько строк. Применяются в `WHERE` с ключевыми словами `IN`, `ANY`, `ALL`.

```sql
SELECT 200 > ALL(SELECT price FROM Rooms)
```
- С помощью оператора ALL мы можем сравнивать отдельное значение с каждым значением в наборе, полученным подзапросом. При этом данное условие вернёт TRUE, только если все сравнения отдельного значения со значениями в наборе вернут TRUE.
- Этот запрос проверяет для всех ли жилых помещений выполняется условие, что оно дешевле чем 200.

```sql
SELECT * FROM Users WHERE id IN (
SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```
- Оператор IN проверяет входит ли конкретное значение в набор значений. В качестве такого набора как раз может использоваться подзапрос, возвращающий несколько строк с одним столбцом.
- Например, получим всю информацию о владельцах жилья стоимостью больше 150 условных единиц.

```sql
SELECT * FROM Users WHERE id = ANY (
SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```
- Условное выражение с ANY имеет схожее поведение, но оно возвращает TRUE, если хотя бы одно сравнение отдельного значения со значением в наборе вернёт TRUE.
- Найдём пользователей, которые владеют хотя бы 1 жилым помещением стоимостью более 150.

```sql
SELECT * FROM Reservations
WHERE (room_id, price) IN (SELECT id, price FROM Rooms);
```
- SQL поддерживает сравнение не только по одной колонке, но позволяет попарно сравнивать значения в основном запросе со значениями в подзапросе. Например, можем получить информацию о всех бронированиях, в которых цена жилья на момент брони (Reservations.price) соответствует текущей стоимостью жилья (Rooms.price). В данном примере, подзапрос возвращает таблицу с идентификаторами жилых помещений и их текущей ценой

### Коррелированные подзапросы

Все предыдущие рассматриваемые подзапросы были некоррелированные (независимые). Они могли выполняться автономно от основного запроса и мы могли посмотреть, что они возвращают перед тем, как их результат будет использоваться в основном запросе. Коррелированные же подзапросы ссылаются на один или несколько столбцов основного запроса.

Использование коррелированных подзапросов может вызвать проблемы с производительностью, особенно если содержащий запрос возвращает много строк, так как коррелированный подзапрос будет выполняться для каждой строки содержащего запроса отдельно.

```sql
SELECT e.name
FROM employees e
WHERE e.salary > (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id);
```

```sql
SELECT FamilyMembers.member_name, (
    SELECT SUM(Payments.unit_price * Payments.amount)
    FROM Payments
    WHERE Payments.family_member = FamilyMembers.member_id
) AS total_spent
FROM FamilyMembers;
```
- В данном случае, коррелированный подзапрос ссылается к столбцу member_id из основного запроса.
- Коррелированный подзапрос отличается от некоррелированного подзапроса тем, что он выполняется не один раз перед выполнением запроса, в который он вложен, а для каждой строки, которая может быть включена в окончательный результат.
- Например, основной запрос к таблице FamilyMembers возвращает 8 записей, то для каждой из них выполняется коррелированный подзапрос.

### Подзапросы в предложении FROM

Иногда подзапрос используется как временная таблица для выполнения дальнейших вычислений.

```sql
SELECT department_id, AVG(salary) AS avg_salary
FROM (SELECT department_id, salary FROM employees) AS emp_data
GROUP BY department_id;
```

## CAST

Когда мы выполняем операции со значениями с разными типами данных, СУБД пытается выполнить преобразование и привести используемые значения к нужному типу. Например, в примере ниже мы сравниваем значения с типами STRING и INT. Чтобы выполнить это сравнение MySQL автоматически сконвертирует строковое значение в числовое.

```sql
SELECT '50' > 49, '50' > 51;
```

Но не все преобразования СУБД может сделать автоматически, и тогда необходимо делать явное преобразование типов. Для этого в MySQL есть две очень схожие функции CAST и CONVERT.

```sql
CAST(значение AS тип_для_конвертации);
CONVERT(значение, тип_для_конвертации);
```
- Синтаксис.

## Транзакции

SQL поддерживает управление транзакциями, такие как `BEGIN`, `COMMIT`, `ROLLBACK`, `SAVEPOINT`. Эти команды не являются процедурами в прямом смысле, но позволяют управлять транзакциями и откатывать изменения при возникновении ошибок.

**Транзакция** - это последовательность операций с базой данных, которые выполняются как единое целое.

Системы управления базами данных обеспечивают возможность одному пользователю извлекать и модифицировать данные. Однако в современном мире тысячи людей могут вносить изменения в базу данных одновременно. Если пользователи в основном осуществляют только чтение данных, то такая нагрузка не представляет особой сложности для сервера базы данных. Но если некоторые пользователи одновременно добавляют и/или изменяют данные, то серверу приходится решать намного более сложные задачи.

**Блокировка** - это метод ограничения доступа к данным для обеспечения корректной обработки транзакций.

Серверы баз данных используют блокировки, чтобы управлять одновременным доступом к данным, чтобы пока одна транзакция работает с данными, другие транзакции не могли их изменять.

Когда данные в базе блокируются, другие пользователи, которые хотят изменить или прочитать эти же данные, должны подождать, пока блокировка не будет снята.

Существует ряд различных стратегий, которые могут использоваться, как именно блокировать ресурс. Сервер может применять блокировку на одном из трёх разных уровней, или гранулярностей.

- Блокировка таблиц: Не позволяет нескольким пользователям одновременно изменять данные в одной таблице.
- Блокировка страниц: Не позволяет нескольким пользователям изменять данные в одной и той же странице (страница - это сегмент памяти, обычно в диапазоне от 2 до 16 Кбайт) таблицы одновременно.
- Блокировка строк: Не позволяет нескольким пользователям одновременно изменять одну и ту же строку в таблице.

Эти подходы имеют свои преимущества и недостатки. Блокировка всей таблицы требует небольшого времени, но при увеличении числа пользователей может привести к долгим ожиданиям. Блокировка строк требует большего объёма дополнительных действий, но зато позволяет нескольким пользователям изменять одну и ту же таблицу, если они работают с разными строками.

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
COMMIT;
```

### Создание транзакций

```sql
-- Начало транзакции
START TRANSACTION;

-- Проверка наличия достаточного баланса у отправителя
SELECT @balance := user_balance FROM accounts WHERE user_id = 1;

-- Если средств недостаточно, отмена транзакции
IF @balance < 1000 THEN
ROLLBACK;
END IF;

-- Проверка на существование получателя
SELECT @exists := COUNT(*) FROM accounts WHERE user_id = 2;
IF @exists = 0 THEN
ROLLBACK;
END IF;

-- Обновление баланса счетов, если все проверки пройдены
UPDATE accounts SET user_balance = user_balance - 1000 WHERE user_id = 1;
UPDATE accounts SET user_balance = user_balance + 1000 WHERE user_id = 2;

-- Применение изменений
COMMIT;
```

Каждая явная транзакция начинается с использования оператора START TRANSACTION.

Завершение же транзакции возможно:

- с помощью команды COMMIT, которая даёт указание серверу пометить изменения как постоянные и освободить все ресурсы (т.е. блокировки строк), использовавшиеся во время транзакции
- с помощью команды ROLLBACK, которая требует от сервера вернуть данные в состояние до начала транзакции. После завершения отката также любые ресурсы, используемые транзакцией, освобождаются.

Помимо использования команд COMMIT и ROLLBACK, транзакция также может завершиться в результате внешних факторов. Например, если сервер выключается, в этом случае ваша транзакция будет автоматически отменена при перезапуске сервера.

### Точки сохранения

В определённых ситуациях вам может потребоваться выполнить откат в транзакции, не отменяя всю проделанную работу. Для этого вы можете установить одну или несколько точек сохранения в рамках транзакции. Это позволяет вам откатиться к конкретной точке в транзакции, а не к её началу.

Каждой точке сохранения в рамках одной транзакции необходимо присвоить уникальное имя, что позволит использовать множество разных точек сохранения. Для создания точки сохранения под названием my_savepoint используйте следующую команду:

```sql
SAVEPOINT my_savepoint;
```

Для отката к определённой точке сохранения просто вводится команда ROLLBACK, за которой следуют ключевые слова TO SAVEPOINT и имя точки сохранения, например:

```sql
START TRANSACTION;

-- Создаем точку сохранения перед изменением баланса первого пользователя
SAVEPOINT before_updating_user_1;
UPDATE accounts SET balance = balance + 100 WHERE user_id = 1;

-- Проверка условия для первого пользователя
-- например, проверяем логику бизнес-правил

-- Здесь мы предполагаем, что условие не выполнилось, и нам нужно отменить изменение баланса
ROLLBACK TO SAVEPOINT before_updating_user_1;

-- Обновляем баланс для второго пользователя
UPDATE accounts SET balance = balance + 200 WHERE user_id = 2;

-- Завершаем транзакцию
COMMIT;
```

В результате этой транзакции баланс первого пользователя останется без изменений из-за отката к точке сохранения, а баланс второго пользователя увеличится на 200. Это показывает, как можно управлять изменениями в базе данных с высоким уровнем контроля при помощи транзакций и точек сохранения.

Когда вы используете точки сохранения, помните следующие моменты:

- Несмотря на название, при создании точки сохранения ничего не сохраняется. Чтобы ваши изменения в рамках транзакции стали постоянными, необходимо выполнить команду COMMIT.
- При выполнении отката транзакции без указания конкретной точки сохранения, все ранее установленные точки сохранения будут проигнорированы, и будет произведён откат всей транзакции.

## Индексы

**Индексы** - это структуры данных, которые ускоряют поиск и сортировку строк в таблице. Они работают как указатели на данные в таблице и позволяют быстро находить строки по значениям одного или нескольких столбцов.

При добавлении в таблицу новой строки, СУБД размещает эти данные не оптимально. БД приходится проверять каждую строку таблицы, чтобы найти соответствия. Это подходит для маленьких таблиц, но становится чрезмерно времязатратным по мере роста объёма данных.

Индексы функционируют как предметные указатели в книге, позволяя быстро находить информацию без прочтения всего текста. Они представляют собой специальные таблицы, строки которых, в отличие от обычных таблиц данных, расположены в строго определённом порядке. Но вместо того, чтобы содержать все данные о некоторой записи, индекс содержит только столбец (или столбцы), используемый, чтобы найти строки в таблице данных, вместе с информацией, описывающей, где физически расположена эта строка. Таким образом, роль индексов состоит в том, чтобы облегчить поиск подмножества строк и столбцов таблицы без необходимости сканировать каждую строку в таблице.

```sql
CREATE INDEX idx_employee_name ON employees(name);
```
- Создание индекса на столбце `name` в таблице `employees`.

При наличии индекса оптимизатор запросов может выбрать использование индекса, если сочтёт это полезным. Если в таблице имеется более одного индекса, оптимизатор должен решить, применение какого именно индекса наиболее выгодно для конкретной инструкции SQL.

Изменение данных (вставка, обновление, удаление) может занимать больше времени, так как индексы тоже нужно обновлять.

```sql
DROP INDEX idx_employee_name ON employees;
```
- Удаление индекса

**Многостолбцовые индексы**

Помимо одностолбцовых индексов, существует возможность создавать индексы, включающие в себя несколько столбцов. К примеру, для поиска студентов по имени и фамилии можно создать совместный индекс по этим двум полям:

```sql
CREATE INDEX idx_full_name
    ON Student (last_name, first_name);
```

Такой индекс окажется полезным для запросов, где необходимы и имя, и фамилия, или только фамилия. Однако, для запросов, задающих только имя, он не принесёт пользы. Это аналогично поиску номера телефона по телефонному справочнику: если известны и имя, и фамилия, поиск упрощается благодаря упорядоченности справочника по фамилии, а затем по имени. Если же известно только имя, придётся перебирать все записи в поисках нужного человека.

При создании индексов, включающих несколько столбцов, важно продумать порядок столбцов в индексе, чтобы он был максимально эффективным. Однако для достижения нужной производительности запросов всегда можно создать несколько индексов с теми же столбцами, но разным порядком их следования.

### Кластеризованные и некластеризованные индексы

**Кластеризованный индекс** - это индекс, который сортирует строки с данными в таблице. Кластеризованный индекс хранит данные в листьях индекса. Главная особенность кластеризованного индекса заключается в том, что все значения отсортированы в определенном порядке либо по возрастанию, либо по убыванию. Следует отметить, что данные в таблице хранятся в отсортированном виде только в том случае, когда у этой таблицы создан кластеризованный индекс. При использовании кластерного индекса данные упорядочены физически (т.е. хранятся, например, на жестком диске). Благодаря этому существенно возрастает скорость поиска данных (при условии последовательного доступа к данным). Однако операция, связанная с изменением порядка данных, может быть затратной и требовать перестроения. В отличие от обычных индексов, кластеризованный индекс создается на всю таблицу сразу, а не на один или более столбцов. В таблице может присутствовать только один кластеризованный индекс.

**Некластеризованный индекс** - это индекс, который используется для применения индексов к неключевым столбцам. Главное отличие от кластеризованного индекса заключается в том, что некластеризованный индекс не упорядочивает данные физически. Некластеризованный индекс хранит данные и индексы в разных местах. Листья некластеризованного индекса содержат только те столбцы таблицы, по которым определен данный индекс. Это означает, что системе запросов необходима дополнительная операция для извлечения требуемых данных. Некластеризованные индексы нельзя отсортировать, в отличие от кластеризованных, однако существует возможность создания более одного некластеризованного индекса. Также при использовании некластеризованного индекса можно добавить уникальный ключ для таблицы.

## Переменные

```sql
SET @var := 1;
```
- Переменные задаются с помощью ключевого слова `SET`,  перед именем указывается символ `@`. Например, создадим переменную `@var` и присвоим ей значение 1. Теперь эту переменную можно использовать в запросах,  кроме того в запросах можно изменить ее значение.

## View && Materialized View

**Представления и материализованные представления** - это виртуальные таблицы, созданные на основе запросов. Они используются для упрощения и оптимизации доступа к данным.

**Представление View** - это виртуальная таблица, созданная на основе SQL-запроса. Она не содержит данных, а лишь ссылку на исходные таблицы и запрос, который выполняется каждый раз при обращении к представлению.

**Материализованное представление Materialized View** - это физически сохраненная копия данных, которая создается на основе SQL-запроса. Данные в этом представлении фиксируются и могут обновляться по расписанию или вручную.

```sql
CREATE VIEW high_value_orders AS
SELECT order_id, customer_id, order_date, total_amount
FROM orders
WHERE total_amount > 100;
```
- Представление создается на основе SQL-запроса и **не хранит данные**. Допустим, у нас есть таблица `orders` с полями `order_id`, `customer_id`, `order_date`, и `total_amount`. Мы хотим создать представление, которое показывает только заказы с общей суммой больше 100.

```sql
CREATE MATERIALIZED VIEW high_value_orders_mv AS
SELECT order_id, customer_id, order_date, total_amount
FROM orders
WHERE total_amount > 100;
```
- Материализованное представление сохраняет данные и может быть обновлено. Создадим материализованное представление `high_value_orders_mv` для тех же данных из таблицы `orders`, но оно будет содержать данные на момент создания.

```sql
REFRESH MATERIALIZED VIEW high_value_orders_mv;
```
- При этом, если данные в `orders` изменятся, то `high_value_orders_mv` не будет автоматически обновляться. Чтобы обновить материализованное представление, используется команда `REFRESH MATERIALIZED VIEW`.

## Процедуры

В SQL под **процедурами** обычно понимают наборы инструкций, которые выполняются на стороне сервера БД. Они могут включать функции, триггеры, хранимые процедуры, и процедуры управления транзакциями.

### Хранимые процедуры

**Хранимые процедуры (Stored procedures)** - это программы, которые хранятся в БД и выполняются на сервере. Они могут включать SQL-запросы, условия, циклы и другие конструкции для управления данными.

- Поддерживают сложную логику и позволяют выполнять несколько команд SQL в одном вызове.
- Могут принимать параметры и возвращать результаты, как значения или выходные параметры.

```sql
CREATE OR REPLACE PROCEDURE update_order_status(order_id INT, new_status TEXT)
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE orders
    SET status = new_status
    WHERE order_id = order_id;
END;
$$;
```
- Пример создания хранимой процедуры в PostgreSQL. 

```sql
CALL update_order_status(123, 'Completed');
```
- Вызов процедуры.

### Функции

Функции (Functions) похожи на процедуры, но они всегда возвращают значение или результат, а также могут использоваться в запросах, например, в `SELECT`. Функции применяют для вычислений или манипуляций с данными и могут возвращать простые типы данных или наборы строк.

```sql
CREATE OR REPLACE FUNCTION get_order_total(order_id INT)
RETURNS DECIMAL AS $$
BEGIN
    RETURN (SELECT SUM(total_amount) FROM order_items WHERE order_id = order_id);
END;
$$ LANGUAGE plpgsql;
```
- Пример создания функции в PostgreSQL.

```sql
SELECT get_order_total(123);
```
- Использование функции в запросе.

### Триггеры

**Триггеры (Triggers)** - это процедуры, которые автоматически выполняются при наступлении определенных событий в таблице, таких как `INSERT`, `UPDATE`, или `DELETE`. Они полезны для поддержания целостности данных или автоматизации действий (например, логирования изменений).

Триггеры могут срабатывать (`BEFORE`) перед тем, как будет выполнено основное действие (например, перед вставкой строки) или (`AFTER`) после того, как основное действие завершено (например, после удаления строки).

Триггеры могут быть настроены на выполнение при выполнении определённых условий (например, если значение определённого поля превышает заданное значение).

```sql
CREATE OR REPLACE FUNCTION log_order_update()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO order_log (order_id, status, updated_at)
    VALUES (NEW.order_id, NEW.status, NOW());
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_order_log
AFTER UPDATE ON orders
FOR EACH ROW
EXECUTE FUNCTION log_order_update();
```
- Этот триггер добавляет запись в таблицу `order_log` каждый раз при обновлении записи в `orders`.

**ПРИМЕНЕНИЕ**

- Тригеры могут использоваться для поддержания целостности данных, например, триггер может предотвращать вставку строки, если значения в ней не соответствуют определённым условиям (например, если поле `дата_рождения` не может быть в будущем).
- Тригеры могут использоваться для автоматического обновления других таблиц, например, триггер может обновлять связанные таблицы при изменении данных в основной таблице. Это может быть полезно для поддержания согласованности данных между таблицами.
- Триггеры могут использоваться для автоматического создания записей в журнале (логах) при добавлении, обновлении или удалении данных. Это может помочь отслеживать изменения и анализировать историю данных.
- Триггеры могут быть настроены для реализации специфических бизнес-правил, таких как ограничение на максимальную сумму заказа или проверка статуса пользователя перед выполнением операции.