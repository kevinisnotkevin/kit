# SQL

- https://sql-academy.org/ru/guide/intro-intro
- https://www.sql-ex.ru/learn_exercises.php
- https://learndb.ru/
- https://stepik.org/lesson/297508/step/1?unit=279268

## 1 Что такое SQL?

```sql
 SELECT список_полей
   FROM список_таблиц
  WHERE ограничения_на_список_строк
  GROUP BY условия_группировки
 HAVING ограничения_на_строки_после_группировки
  ORDER BY порядок_сортировки
  LIMIT ограничение_количества_записей
```
- Базовый синтаксис SQL запроса.

SQL (Structured Query Language) - это язык программирования, используемый в большинстве реляционных баз данных для запросов, обработки и определения данных, а также контроля доступа. SQL был разработан в IBM в 1970-х годах. Со временем у стандарта SQL ANSI появились многочисленные расширения, разработанные такими компаниями как IBM, Oracle и Microsoft. Хотя в настоящее время SQL все еще широко используется, начали появляться новые языки программирования запросов.

Является, прежде всего, информационно-логическим языком, предназначенным для описания, изменения и извлечения данных, хранимых в реляционных базах данных. В общем случае SQL (без ряда современных расширений) считается языком программирования неполным по Тьюрингу, но вместе с тем стандарт языка спецификацией SQL/PSM предусматривает возможность его процедурных расширений.

Язык SQL - универсальный язык для всех реляционных систем управления базами данных, но многие СУБД вносят свои изменения в язык, применяемый в них, тем самым отступая от стандарта. Такие языки называют диалектами или расширениями языка.

Диалекты SQL:

- T-SQL - диалект Microsoft SQL Server
- PL/SQL - диалект Oracle Database
- PL/pgSQL - диалект PostgreSQL

**MySQL**

- **Особенности:** MySQL - это одна из самых популярных реляционных баз данных, широко используемая в веб-разработке и других областях. Его диалект SQL характеризуется простым и интуитивно понятным синтаксисом.
- **Основные различия:** Одним из отличительных особенностей MySQL является использование двойных кавычек для обозначения строковых значений, в то время как в других диалектах SQL используются одинарные кавычки. Кроме того, MySQL имеет свои собственные функции и операторы, такие как LIMIT для ограничения количества возвращаемых записей в запросе.

**PostgreSQL**

- **Особенности:** PostgreSQL - это мощная и расширяемая реляционная база данных с открытым исходным кодом. Ее диалект SQL предоставляет богатый набор функций и возможностей.
- **Основные различия:** PostgreSQL часто использует двойные кавычки для обозначения идентификаторов, таких как имена таблиц и столбцов, что отличается от стандартного использования одинарных кавычек в других диалектах. Кроме того, PostgreSQL предоставляет множество расширений и возможностей, таких как оконные функции и генерируемые столбцы.

**Microsoft SQL Server**

- **Особенности:** Microsoft SQL Server - это коммерческая реляционная база данных, разработанная корпорацией Microsoft. Ее диалект SQL широко используется в корпоративной среде и имеет свои собственные особенности.
- **Основные различия:** В SQL Server, например, используется функция TOP вместо LIMIT для ограничения количества возвращаемых записей. Также в SQL Server могут присутствовать различия в типах данных и синтаксисе для некоторых операторов и функций.

SQL позволяет:

- получать доступ к данным в системах управления РБД
- описывать данные (их структуру)
- определять данные в БД и управлять ими
- взаимодействовать с другими языками через модули SQL, библиотеки и предварительные компиляторы
- создавать и удалять БД и таблицы
- создавать представления, хранимые процедуры (stored procedures) и функции в БД
- устанавливать разрешения на доступ к таблицам, процедурам и представлениям

**Строковые литералы**

**Литерал** - это указанное явным образом фиксированное значение, например, число 12 или строка "SQL".

**Строка** - это последовательность символов, заключённых в одинарные (') или двойные (") кавычки. Например, 'это строка' и "это строка".

```sql
SELECT "Строка \n Другая строка" as String
```

**Числовые литералы**

- `1`
- `2.1`
- `0.01`
- `.2`
- `+1`
- `-1`
- `1e3`, `1000`
- `%`, `MOD`
- `*`
- `+`
- `-`
- `/`
- `DIV`

```sql
SELECT (5 * 2 - 6) AS Result;
```
- Используя эти операторы можно построить любое арифметическое выражение, применяя стандартные правила арифметики.

**Литералы даты и времени**

- `YYYY-MM-DD`, `YYYYMMDD` (дата со временем, равным нулю)
- `hh:mm:ss`, `hh:mm`, `hh`, `ss` (время без конкретной даты)
- `YYYY-MM-DD hh:mm:ss`, `YYYYMMDDhhmmss` (дата и время)

Значения даты и времени могут быть представлены в формате строки или числа.

Например, если мы хотим указать какую-то дату в запросе, то мы можем это сделать с помощью строки "2000-12-30", "20001230" или же числа 20001230. В обоих случаях эти значения будут интерпретироваться как дата «30 декабря 2000 года».

```sql
SELECT * FROM user WHERE birthday > '2000-12-30'
```

**Логические литералы**

Логический литерал - это значения TRUE и FALSE, означающие истинность и ошибочность какого-либо утверждения. При интерпретации запроса TRUE и FALSE становятся 1 и 0 соответственно.

**NULL**

Значение NULL означает "нет данных", "нет значения". Оно нужно, чтобы отличать визуально пустые значения, такие как строка нулевой длины или "пробел", от того, когда значения вообще нет, даже пустого.

**Конкатенация строк**

Часто в запросах приходится объединять несколько значений в одно текстовое значение (конкатенация). Например, может потребоваться получить строку следующего формата: 'текущее время: 2020-02-19 15:28:44.049702+07'. Для выполнения конкатенации строк необходимо воспользоваться оператором `||`:

```sql
SELECT 'текущее время: ' || now() as time

SELECT concat('текущее время: ', now()) as time
```
- Аналогичные записи

## 2 Элементы SQL

### 2.0 Создание БД и таблиц

```bash
# Создание БД
CREATE DATABASE dbname;

# Создание пользователя
CREATE USER dbuser WITH PASSWORD 'password';

# Назначение прав пользователю на БД
GRANT ALL PRIVILEGES ON DATABASE dbname TO dbuser;

# Удаление пользователя
DROP ROLE dbuser;
```

```bash
\c db_test
```

```bash
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    CustomerName VARCHAR(255),
    City VARCHAR(255),
    Country VARCHAR(255)
);

CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    Total_amount DECIMAL(10, 2),
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE employees (
    Employee_id INT PRIMARY KEY,
    Name VARCHAR(255),
    Salary DECIMAL(10, 2),
    Department_id INT,
    Email VARCHAR(255)
);

CREATE TABLE products (
    Product_id INT PRIMARY KEY,
    Price DECIMAL(10, 2),
    Category VARCHAR(255)
);

CREATE TABLE OrderDetails (
    OrderDetail_id INT PRIMARY KEY,
    OrderID INT,
    ProductID INT,
    Quantity INT,
    FOREIGN KEY (OrderID) REFERENCES Orders(OrderID)
);
```

Добавим данные:

```bash
INSERT INTO Customers (CustomerID, CustomerName, City, Country) VALUES
(1, 'Ivan Ivanov', 'Moscow', 'Russia'),
(2, 'John Smith', 'New York', 'USA'),
(3, 'Anna Schmidt', 'Berlin', 'Germany');

INSERT INTO Orders (OrderID, CustomerID, Total_amount) VALUES
(1, 1, 100),
(2, 2, 200),
(3, 3, 300);

INSERT INTO Employees (Employee_id, Name, Salary, Department_id, Email) VALUES
(1, 'John Doe', 5000, 10, 'johndoe@email.com'),
(2, 'Jane Smith', 6000, 20, 'janesmith@email.com'),
(3, 'Emily Johnson', 7000, 30, 'emilyjohnson@email.com');

INSERT INTO products (Product_id, Price, Category) VALUES
(1, 100, 'Category A'),
(2, 200, 'Category B'),
(3, 300, 'Category C');

INSERT INTO OrderDetails (OrderDetail_id, OrderID, ProductID, Quantity) VALUES
(1, 1, 1, 10),
(2, 2, 2, 20),
(3, 3, 3, 30);
```

### 2.1 SELECT

```sql
SELECT * FROM employees;
```
- Одна из основных функций SQL - это получение выборок данных из СУБД. Для этого в SQL используется оператор SELECT. Оператор SELECT можно выводить данные не только из таблиц базы данных, но и произвольные строки, числа, даты и т.д.

```sql
SELECT id AS alias_id FROM users;

SELECT id alias_id FROM users;
```
- В случае, если мы хотим вывести какие-то столбцы таблицы, но чтобы в итоговой выборке они были названы иначе, мы можем использовать псевдонимы (их также называют алиасами). Их синтаксис достаточно простой, мы должны использовать оператор AS. Или же можно обойтись и без него, просто написав желаемое наименование поля через пробел. Псевдонимы могут содержать до 255 знаков (включая пробелы, цифры и специальные символы).

```sql
SELECT 'Hello world'

SELECT 'Hello', 'world'
```
- Если предложение FROM опущено, то оператор SELECT вернет ровно одну строку со значениями, состоящими из констант, строковых литералов, результатов вызовов функций и операций над всем вышеперечисленным.

### 2.2 WHERE

Для ограничения количества возвращаемых строк в SQL существует предложение WHERE. В WHERE указывается логическое выражение, которое служит фильтром строк: в результате остаются только те строки, для которых это выражение истинно.

```sql
SELECT * FROM orders WHERE total_amount > 100;
```
- Условный оператор WHERE используется для фильтрации результатов запроса в соответствии с определенным условием.

### 2.4 HAVING

HAVING - необязательный элемент запроса, который отвечает за фильтрацию на уровне сгруппированных данных (по сути, WHERE, но только на уровень выше). 

```sql
SELECT City, COUNT(CustomerID) 
FROM Customers 
GROUP BY City 
HAVING COUNT(CustomerID) >= 5;
```
- Фильтрация агрегированной таблицы с количеством клиентов по городам, в данном случае оставляем в выгрузке только те города, в которых не менее 5 клиентов.

```sql
SELECT City, COUNT(CustomerID) as number_of_clients 
FROM Customers 
WHERE CustomerName not in ('Around the Horn', 'Drachenblut Delikatessend') 
GROUP BY City 
HAVING COUNT(CustomerID) >= 1;
```
- Пример запроса, содержащего WHERE и HAVING. В данном запросе сначала фильтруется исходная таблица по пользователям, рассчитывается количество клиентов по городам и остаются только те города, где количество клиентов не менее 1.

### 2.5 CREATE TABLE

Для создания таблицы используется оператор CREATE TABLE.

```sql
CREATE TABLE [IF NOT EXIST] имя_таблицы (
     столбец_1 тип_данных,
    [столбец_2 тип_данных,]
    ...
    [столбец_n тип_данных,]
);
```
- Структура



### 2.6 ALTER TABLE

```sql
CREATE TABLE employees_2 (
	employee_id INT PRIMARY KEY,
	name VARCHAR(100),
	department_id INT
);

ALTER TABLE employees_2 ADD COLUMN email VARCHAR(255);
```
- Операторы CREATE TABLE и ALTER TABLE используются для создания и изменения структуры таблиц баз данных.

### 2.7 CONSTRAINT

```sql
CREATE INDEX idx_customer_name ON customers (customername);

ALTER TABLE orders 
ADD CONSTRAINT fk_customerid 
FOREIGN KEY (customerid) 
REFERENCES customers(customerid);
```
- CONSTRAINT используется для ограничения целостности данных в базе данных.
### 2.8 GROUP BY

GROUP BY - необязательный элемент запроса, с помощью которого можно задать агрегацию по нужному столбцу (например, если нужно узнать какое количество клиентов живет в каждом из городов).

При использовании GROUP BY мы можем выводить только:

- литералы, т.е. указанное явным образом фиксированные значения.
- результаты агрегатных функций, т.е. вычисленные значения на основании набора значений.
- поля группировки.

При использовании GROUP BY обязательно:

1. перечень столбцов, по которым делается разрез, был одинаковым внутри SELECT и внутри GROUP BY,
2. агрегатные функции (SUM, AVG, COUNT, SELECT family_member, member_name FROM Payments
INNER JOIN FamilyMembers
    ON Payments.family_member = FamilyMembers.member_idMAX, MIN) должны быть также указаны внутри SELECT с указанием столбца, к которому такая функция применяется.

```sql
SELECT City, COUNT(CustomerID) 
FROM Customers 
GROUP BY City;
```
- Группировка количества клиентов по городу.

```sql
SELECT Country, City, COUNT(CustomerID) 
FROM Customers 
GROUP BY Country, City;
```
- Группировка количества клиентов по стране и городу.

```sql
SELECT ProductID, COUNT(OrderID), SUM(Quantity) 
FROM OrderDetails 
GROUP BY ProductID;
```
- Группировка продаж по ID товара с разными агрегатными функциями: количество заказов с данным товаром и количество проданных штук товара.

```sql
SELECT City, COUNT(CustomerID) 
FROM Customers 
WHERE Country = 'Germany' 
GROUP BY City;
```
- Группировка продаж с фильтрацией исходной таблицы. В данном случае на выходе будет таблица с количеством клиентов по городам Германии.

```sql
SELECT City, COUNT(CustomerID) AS Number_of_clients 
FROM Customers 
GROUP BY City;
```
- Переименование столбца с агрегацией с помощью оператора AS. По умолчанию название столбца с агрегацией равно примененной агрегатной функции, что далее может быть не очень удобно для восприятия.

### 2.9 JOIN

Оператор JOIN используется для объединения таблиц по ключу, который присутствует в обеих таблицах. Перед ключом ставится оператор ON.

В большинстве случаев условием соединения является равенство столбцов таблиц (таблица_1.поле = таблица_2.поле), однако точно так же можно использовать и другие операторы сравнения.

```sql
SELECT поля_таблиц
FROM таблица_1
[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_2
ON условие_соединения
[[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_n
ON условие_соединения]
```
- Общая структура многотабличного запроса.

**Соединение бывает внутренним INNER (по умолчанию) и внешним OUTER, при этом внешнее соединение делится на левое LEFT, правое RIGHT и полное FULL.**

Главным отличием внешнего соединения от внутреннего является то, что оно обязательно возвращает все строки одной (LEFT, RIGHT) или двух таблиц (FULL).

Внутреннее соединение - соединение, при котором находятся пары записей из двух таблиц, удовлетворяющие условию соединения, тем самым образуя новую таблицу, содержащую поля из первой и второй исходных таблиц.

```sql
SELECT family_member, member_name
FROM Payments
INNER JOIN FamilyMembers
ON Payments.family_member = FamilyMembers.member_id
-- OR
SELECT family_member, member_name
FROM Payments, FamilyMembers
WHERE Payments.family_member = FamilyMembers.member_id
```
- Аналогичные запросы. Внутреннее соединение можно выполнить не используя ключевое слово `JOIN`. Для этого достаточно сделать декартово произведение строк таблиц, а условия соединения прописать в предложении `WHERE`.

#### 2.9.1 Типы соединений

- `INNER JOIN` или просто `JOIN` - внутреннее соединение. В результате остаются только те строки, для которых нашлось соответствие.
- `LEFT JOIN` - левое внешнее соединение. Работает как `JOIN`, но если для строки таблицы, находящейся по левую сторону ключевого слова `LEFT JOIN`, не нашлось ни одной строки в таблице, находящейся по правую сторону `LEFT JOIN`, то строка все равно добавляется в результат, а значения столбцов правой таблицы равны `null`.
- `RIGHT JOIN` - правое внешнее соединение. Работает как `JOIN`, но если для строки таблицы, находящейся по правую сторону ключевого слова `RIGHT JOIN`, не нашлось ни одной строки в таблице, находящейся по левую сторону `RIGHT JOIN`, то строка все равно добавляется в результат, а значения столбцов левой таблицы равны `null`.
- `FULL JOIN` - полное внешнее соединение. Если для какой-либо из таблиц не нашлось строки в другой таблице, то строка все равно попадает в результат, а значения столбцов другой таблицы равны `null`.
- `CROSS JOIN` - перекрестное (или декартово) произведение. Каждая строка одной таблицы соединяется с каждой строкой второй таблицы, давая тем самым в результате все возможные сочетания строк двух таблиц. Аналогичного результата можно достичь просто перечислив таблицы в `FROM` через запятую.

Соединение FULL JOIN реализовано не во всех СУБД. Например, в MySQL оно отсутствует, однако его можно очень просто эмулировать.

```sql
SELECT Timepair.id 'timepair.id', start_pair, end_pair,
Schedule.id 'schedule.id', date, class, number_pair, teacher, subject, classroom
FROM Timepair
LEFT JOIN Schedule ON Schedule.number_pair = Timepair.id;
```
- Для примера получим из базы данных расписание звонков, объединённых с соответствующими занятиями в расписании занятий. В выборку попали все строки из левой таблицы, дополненные данными о занятиях. В конце таблицы есть строки с полями, заполненными NULL. Это те строки, для которых не нашлось соответствующих занятий, однако они присутствуют в левой таблице, поэтому тоже были выведены.

#### 2.9.2 Псевдонимы таблиц

В условиях соединения ON имя таблицы обычно не пишут. Подобно псевдонимам столбцов в списке выборки SELECT можно задать псевдонимы таблицам. Для этого после названия таблицы через пробел нужно написать псевдоним таблицы. После того, как таблице назначен псевдоним, обращаться к ней по названию уже нельзя - только по псевдониму.

```sql
SELECT c.city_id, name, time_offset
FROM city c
JOIN timezone t
ON t.timezone_id = c.timezone_id
```
- Алиасы таблиц также удобно использовать в списке выборки SELECT. Выберем, например, из таблиц городов и часовых поясов только идентификатор города, название города и время относительно UTC. Если поле встречается только в одной таблице, то в списке выборки таблицу, из которой взять столбец, указывать не обязательно. Лучше всегда указывать из какой таблицы поле.

#### 2.9.3 Несколько условий соединения

В условии соединения таблиц можно использовать произвольное количество логических выражений (как в предложении WHERE).

```sql
SELECT e.first_name, e.last_name, r.rank_id, r.store_id, r.name as rank_name
FROM employee e
JOIN rank r
ON r.rank_id = e.rank_id
AND r.store_id = e.store_id
LIMIT 5
```
- Например, получим информацию о должностях произвольных 5-ти сотрудников. Чтобы найти информацию о должности сотрудника, нужно из таблицы rank взять строку с таким же идентификатором магазина и идентификатором должности в магазине.

#### 2.9.4 Использование таблицы несколько раз

Если одну и ту же таблицу необходимо использовать в запросе несколько раз, то необходимо воспользоваться псевдонимами для таблиц. Например, для каждой стоимости товара в магазине найдем предложение на такой же товар в другом магазине по меньшей цене.

```sql
SELECT pp.product_id, pp.store_id, pp.price, ppl.store_id AS store_id_less, ppl.price AS price_less
FROM product_price pp
JOIN product_price ppl
ON ppl.product_id = pp.product_id
AND ppl.store_id != pp.store_id
AND ppl.price < pp.price
ORDER BY pp.product_id, pp.store_id, ppl.store_id, ppl.price
```
- Берутся все строки из таблицы product_price. Дальнейшее обращение к этому набору строк происходит через pp.
- Для каждой строки из пункта 1 просматривается еще раз все строки таблицы product_price. Обращение к строкам последней происходит через ppl.
- Если цена price у строки из второй копии product_price меньше, чем у строки из первой копии product_price, то связка этих строк добавляется в результат выполнения запроса.
- В конце результат сортируется согласно ORDER BY.

### 2.10 DISTINCT

Иногда в таблицах встречаются дубликаты, как например имена сотрудников. Для исключения повторяющихся строк, нужно после ключевого слова SELECT написать DISTINCT. DISTINCT может применяться для нескольких колонок.

```sql
SELECT DISTINCT id FROM users;

SELECT DISTINCT id, name FROM users;
```

### 2.11 Логические операторы

В предложении WHERE могут присутствовать логические операторы:

- `AND` - логическое И;
- `OR` - логическое ИЛИ;
- `NOT` - отрицание.

При составлении условия WHERE важно учитывать порядок выполнения условий. А выполняются они в следующем порядке:

1. `NOT`
2. `AND`
3. `OR`

В предложении WHERE помимо проверки на равенство можно использовать и другие операции сравнения. Доступны следующие операторы:

- `<` - меньше;
- `>` - больше;
- `<=` - меньше или равно;
- `>=` - больше или равно;
- `=` - равно;
- `!=` или `<>` - не равно.

### 2.12 IS NULL, BETWEEN, IN

Оператор IS NULL позволяет узнать равно ли проверяемое значение NULL, т.е. пустое ли значение.

```sql
SELECT * FROM Teacher
WHERE middle_name IS NOT NULL;
```

Оператор BETWEEN min AND max позволяет узнать расположено ли проверяемое значение столбца в интервале между min и max, включая сами значения min и max.

```sql
SELECT * FROM Payments
WHERE unit_price BETWEEN 100 AND 500;
```

Оператор IN позволяет узнать входит ли проверяемое значение столбца в список определённых значений.

```sql
SELECT * FROM FamilyMembers
WHERE status IN ('father', 'mother');
```

### 2.13 LIKE

Оператор LIKE используется при условных запросах, когда мы хотим узнать соответствует ли строка определённому шаблону.

В шаблоне LIKE можно использовать два спецсимвола:

- `_` - заменяет один любой символ;
- `%` - заменяет любую последовательность символов (в том числе пустую)

```sql
'abc' LIKE 'abc'    true
'abc' LIKE 'a%'     true
'abc' LIKE '_b_'    true
'abc' LIKE 'c'      false
```
- Примеры

```sql
SELECT name, email FROM users
WHERE email LIKE '%@hotmail.%'
```
- Пример использования оператора LIKE

При проверке по шаблону `LIKE` всегда рассматривается вся строка. Поэтому, если нужно найти последовательность символов где-то в середине строки, шаблон должен начинаться и заканчиваться знаком `%`.

Чтобы найти в строке буквальное вхождение знака процента или подчёркивания, перед соответствующим символом в шаблоне нужно добавить спецсимвол. По умолчанию в качестве спецсимвола выбрана обратная косая черта `\`, но с помощью предложения `ESCAPE` можно выбрать и другой. Чтобы включить спецсимвол в шаблон поиска, продублируйте его. Синтаксис `LIKE` с указанием спецсимвола:

```sql
'_asdfa' LIKE '$_asd%' ESCAPE '$'
```

Вместо `LIKE` можно использовать ключевое слово `ILIKE`, чтобы поиск был регистр-независимым с учётом текущей языковой среды.

### 2.14 REGEXP

Оператор REGEXP (или его синоним RLIKE) в SQL используется для поиска и обработки строковых данных с помощью регулярных выражений. Регулярные выражения предоставляют мощные возможности для сложных шаблонов поиска, которые трудно реализовать с помощью оператора LIKE.

```sql
SELECT * FROM Users WHERE name REGEXP '^John'
```
- Это выражение ищет строки, начинающиеся с «John». Символ ^ указывает на начало строки.

```sql
SELECT * FROM  Subject WHERE name REGEXP '[ey]$'
```
- В этом примере, `[ey]` определяет список возможных значений для паттерна $, определяющего на что должна заканчиваться строка.

```sql
SELECT * FROM Users WHERE phone_number REGEXP '^[^28]*$'
```
- В этом примере символ `[^28]` обозначает любой символ, кроме «2» и «8», а * означает любое количество таких символов. Символы ^ и $ указывают на начало и конец строки соответственно, гарантируя, что вся строка соответствует шаблону.

### 2.15 ORDER BY

При выполнении SELECT запроса, строки по умолчанию возвращаются в неопределённом порядке. Фактический порядок строк в этом случае зависит от плана соединения и сканирования, а также от порядка расположения данных на диске, поэтому полагаться на него нельзя. Для упорядочивания записей используется конструкция ORDER BY.

ASC и DESC - направление сортировки:

- ASC - сортировка по возрастанию (по умолчанию)
- DESC - сортировка по убыванию

```sql
SELECT store_id, name
FROM store
ORDER BY name
```
- Сортировка по возрастанию

```sql
SELECT store_id, name
FROM store
ORDER BY name DESC
```
- Сортировка по убыванию

```sql
SELECT employee_id, rank_id, last_name
FROM employee
ORDER BY rank_id ASC, last_name DESC
```
- Сортировка по нескольким столбцам. Данные будут сортироваться по первому столбцу, но в случае если попадаются несколько записей с совпадающими значениями в первом столбце, то они сортируются по второму столбцу

### 2.16 LIMIT, OFFSET

Конструкция LIMIT позволяет получить только часть строк от результата запроса.

Применяя LIMIT, важно использовать также предложение ORDER BY, чтобы строки результата выдавались в определённом порядке. Иначе будут возвращаться непредсказуемые подмножества строк. Вы можете запросить строки с десятой по двадцатую, но какой порядок вы имеете в виду? Порядок будет неизвестен, если не добавить ORDER BY.

> Оператор LIMIT реализован не во всех СУБД, например, в MSSQL для вывода записей с начала таблицы используется оператор TOP, а для тех случаев, когда необходимо сделать отступ от начала таблицы, предназначена конструкция OFFSET FETCH.

В дополнение к LIMIT можно пропустить определенное количество строк из результата запроса. Для этого после предложения LIMIT нужно написать OFFSET и сколько строк пропустить.

```sql
SELECT store_id, name
FROM store
ORDER BY name
LIMIT 3
OFFSET 3
```

### 2.17 WITH

**Обобщённое табличное выражение или CTE (Common Table Expressions)** - это временный результирующий набор данных, к которому можно обращаться в последующих запросах. Для написания обобщённого табличного выражения используется оператор WITH.

Обобщённые табличные выражения были добавлены в SQL для упрощения сложных длинных запросов, особенно с множественными подзапросами. Их главная задача – улучшение читабельности, простоты написания запросов и их дальнейшей поддержки. Это происходит за счёт сокрытия больших и сложных запросов в созданные именованные выражения, которые потом используются в основном запросе.

Выражение с WITH считается временным, потому что результат не сохраняется где-либо на постоянной основе в схеме БД, а действует как временное представление, которое существует только на время выполнения запроса, то есть оно доступно только во время выполнения операторов SELECT, INSERT, UPDATE, DELETE или MERGE. Оно действительно только в том запросе, которому он принадлежит, что позволяет улучшить структуру запроса, не загрязняя глобальное пространство имён.

```sql
WITH Aeroflot_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot"),
    Don_avia_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Don_avia")

SELECT plane, COUNT(plane) AS amount
FROM Aeroflot_trips
GROUP BY plane;
```
- Создаём табличное выражение Aeroflot_trips, содержащие все полёты, совершенные авиакомпанией Aeroflot. Аналогично, создаём табличное выражение Aeroflot_trips, но с переименованными колонками. С помощью оператора WITH определяем несколько табличных выражений.

### 2.18 UNION

UNION по умолчанию убирает повторения в результирующей таблице. Для отображения с повторением есть необязательный параметр ALL.

Объединение таблиц оператором UNION выполняется для таблиц никак не связанных, но со схожей структурой.

```sql
SELECT поля_таблиц FROM список_таблиц ...
UNION [ALL]
SELECT поля_таблиц FROM список_таблиц ... ;
```
- Общая структура запроса с оператором UNION.

Для корректной работы UNION нужно, чтобы результирующие таблицы каждого из SQL запросов имели одинаковое число столбцов, с одним и тем же типом данных и в той же самой последовательности.

Существует два других оператора, чьё поведение крайне схоже с UNION:

- INTERSECT Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые имеют совпадения во втором элементе SELECT.
- EXCEPT Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые не имеют совпадения во втором элементе SELECT.

```sql
SELECT DISTINCT Goods.good_name AS name FROM Goods
UNION
SELECT DISTINCT FamilyMembers.member_name AS name FROM FamilyMembers;
```
- Например, необходимо вывести наименование всех товаров и имена всех членов семьи.

### 2.19 CASE

CASE - оператор, который реализует условную логику.

Под условной логикой понимается наличие у программы нескольких путей выполнения в зависимости от каких-то условий.

```sql
CASE
    WHEN условие_1 THEN возвращаемое_значение_1
    WHEN условие_2 THEN возвращаемое_значение_2
    WHEN условие_n THEN возвращаемое_значение_n
    [ELSE возвращаемое_значение_по_умолчанию]
END
```
- Синтаксис поискового выражения CASE.
- Если условие_1 возвращает истинное значение, то выражение CASE вернёт возвращаемое_значение_1, иначе будет сделана проверка на условие_2 и т.д. Если ни одно из предложенных условий не будет выполнено, то вернётся NULL или возвращаемое_значение_по_умолчанию, если была использована конструкция ELSE.

```sql
CASE значение
    WHEN сравниваемое_значение_1 THEN возвращаемое_значение_1
    WHEN сравниваемое_значение_2 THEN возвращаемое_значение_2
    WHEN сравниваемое_значение_n THEN возвращаемое_значение_n
    [ELSE возвращаемое_значение_по умолчанию]
END
```
- Синтаксис простого выражения CASE.
- В этом синтаксисе значение в CASE поочерёдно сравнивается с переданными значениями в WHEN и при совпадении возвращается значение следующее за THEN.

Например, в базе данных «Расписание» есть таблица Student с полем birthday, отражающим дату рождения студента. Допустим, в выборке необходимо отобразить не саму дату рождения, а текстовое значение «Совершеннолетний» или «Несовершеннолетний» в зависимости от того, есть ли студенту 18 лет. Это и есть пример условной логики, при которой должно вывестись либо одно значение, либо другое в зависимости от конкретного условия.

```sql
SELECT name,
CASE
  WHEN SUBSTRING(name, 1, INSTR(name, ' ')) IN (10, 11) THEN "Старшая школа"
  WHEN SUBSTRING(name, 1, INSTR(name, ' ')) IN (5, 6, 7, 8, 9) THEN "Средняя школа"
  ELSE "Начальная школа"
END AS stage
FROM Class
```
- Реализация такого запроса с помощью CASE.

```sql
SELECT name,
CASE SUBSTRING(name, 1, INSTR(name, ' '))
	WHEN 11 THEN "Старшая школа"
	WHEN 10 THEN "Старшая школа"
	WHEN 9 THEN "Средняя школа"
	WHEN 8 THEN "Средняя школа"
	WHEN 7 THEN "Средняя школа"
	WHEN 6 THEN "Средняя школа"
	WHEN 5 THEN "Средняя школа"
	ELSE "Начальная школа"
END AS stage
FROM Class
```
- Оператор CASE на примере определения этапа школьного образования.

**IF, IFNULL, NULLIF**

```sql
IF(условное_выражение, значение_1, значение_2);
```
- Если условное выражение, передаваемое в качестве первого аргумента в функцию IF, истинно, функция вернёт значение второго аргумента значение_1, иначе возвращается значение третьего аргумента значение_2. Функции IF можно также вкладывать друг в друга, эмулируя оператор CASE.

```sql
IFNULL(значение, альтернативное_значение);
```
- Функция IFNULL возвращает значение, переданное первым аргументом, если оно не равно NULL, иначе возвращает альтернативное_значение.

```sql
NULLIF(значение_1, значение_2);
```
- Функция NULLIF возвращает NULL, если значение_1 равно значению_2, в противном случае возвращает значение_1.

### 2.20 INSERT

Для добавления новых записей в таблицу предназначен оператор INSERT. 

Следует помнить, что первичный ключ таблицы является уникальным значением и добавление уже существующего значения приведёт к ошибке.

```sql
INSERT INTO имя_таблицы [(поле_таблицы, ...)]
VALUES (значение_поля_таблицы, ...)
| SELECT поле_таблицы, ... FROM имя_таблицы ...
```
- Значения можно вставлять перечислением с помощью слова VALUES, перечислив их в круглых скобках через запятую или c помощью оператора SELECT.

```sql
INSERT INTO Goods (good_id, good_name, type)
SELECT 20, 'Table', 2;
```
- Добавление записи, используя SELECT

```sql
INSERT INTO Goods (good_id, good_name, type)
VALUES (20, 'Table', 2);
```
- Добавление записи, используя VALUES

```sql
CREATE TABLE Goods (
	good_id INT NOT NULL AUTO_INCREMENT
	...
);

INSERT INTO Goods VALUES (NULL, 'Table', 2);
```
- В MySQL введён механизм его автоматической генерации. Для этого достаточно снабдить первичный ключ good_id атрибутом AUTO_INCREMENT. Тогда при создании новой записи в качестве значения good_id достаточно передать NULL или 0 - поле автоматически получит значение, большее предыдущего на единицу.

```sql
CREATE TABLE Goods (
	good_id SERIAL
	...
);

INSERT INTO Goods (good_name, type) VALUES ('Table', 2);
```
- В PostgreSQL есть схожий механизм для автоматической генерации уникального идентификатора. Для этого он имеет типы SMALLSERIAL, SERIAL, BIGSERIAL, которые не являются настоящими типами, а скорее просто удобством записи столбцов с уникальным идентификатором. Столбец с одним из вышеперечисленных типов будет являться целочисленным и автоматически увеличиваться при добавлении новой записи.

### 2.21 UPDATE

Для редактирования существующих записей в таблицах существует SQL оператор UPDATE.

```sql
UPDATE имя_таблицы
SET поле_таблицы1 = значение_поля_таблицы1,
    поле_таблицыN = значение_поля_таблицыN
[WHERE условие_выборки]
```
- Общая структура запроса.

```sql
UPDATE FamilyMembers
SET member_name = "Andie Anthony"
WHERE member_name = "Andie Quincey";
```
- Изменение имени у определенных записей. Если не указать where, то будут обновлены все записи.

```sql
UPDATE Payments
SET unit_price = unit_price * 2;
```
- В запросах на обновление данных можно менять значения, опираясь на предыдущее значение. Разрешается также значения одних столбцов присваивать другим столбцам. Но типы столбцов должны быть совместимыми.

### 2.22 DELETE, TRUNCATE

Для удаления записей в таблицах существует DELETE и TRUNCATE. Если условие отбора записей WHERE отсутствует, то будут удалены все записи указанной таблицы.

```sql
DELETE FROM имя_таблицы
[WHERE условие_отбора_записей];
```
- Общая структура запроса DELETE.

TRUNCATE выполняет удаление таблицы и пересоздает её заново - этот вариант работает гораздо быстрее, чем удаление всех записей одна за другой (как в случае с DELETE) особенно для больших таблиц.

```sql
TRUNCATE TABLE имя_таблицы;
```
- Общая структура запроса TRUNCATE.

> Оптимизатор запросов СУБД MySQL автоматически использует оператор TRUNCATE, если оператор DELETE не содержит условия WHERE или конструкции LIMIT.

Однако у оператора TRUNCATE есть ряд отличий:

- Не срабатывают триггеры, в частности, триггер удаления
- Удаляет все строки в таблице, не записывая при этом удаление отдельных строк данных в журнал транзакций
- Сбрасывает счётчик идентификаторов до начального значения
- Чтобы использовать, необходимы права на изменение таблицы

```sql
DELETE имя_таблицы_1 [, имя_таблицы_2] FROM
имя_таблицы_1 JOIN имя_таблицы_2
ON имя_таблицы_1.поле = имя_таблицы_2.поле
[WHERE условие_отбора_записей];
```
- Удаление записей при многотабличных запросах.

Если в DELETE запросе используется JOIN, то необходимо указать из каких(ой) именно таблиц(ы) требуется удалять записи.

```sql
DELETE Reservations FROM
Reservations JOIN Rooms ON
Reservations.room_id = Rooms.id
WHERE Rooms.has_kitchen = false;
```
- Удаление всех броней жилья, в котором отсутствует кухня.

```sql
DELETE Reservations, Rooms FROM
Reservations JOIN Rooms ON
Reservations.room_id = Rooms.id
WHERE Rooms.has_kitchen = false;
```
- Помимо удаления бронирования, удаление и жилья.

## 3 Группы SQL операторов

### 3.1 DDL

DDL (Data Definition Language) - операторы определения данных. Они работают с объектами, то есть с целыми таблицами. Если базу нужно дополнить таблицей с новыми данными или, наоборот, убрать одну из таблиц с ошибочными данными - используется этот набор операторов.

- `CREATE` - создание объекта в базе данных
- `ALTER` - изменение объекта
- `DROP` - удаление объекта

### 3.2 DML

DML (Data Manipulation Language) - операторы манипуляции данными. Эти операторы уже работают с содержимым таблиц - строками, атрибутами и значениями. С их помощью можно вносить изменения в конкретное значение. Например, заменить поле в колонке «Фамилия» в строке с данными сотрудницы компании посте того, как она вышла замуж. Или удалить строку с данными уволенного сотрудника.

- `SELECT` - выбор данных в соответствии с условием
- `INSERT` - добавление новых данных
- `UPDATE` - изменение существующих данных
- `DELETE` - удаление данных

### 3.3 DCL

DCL (Data Control Language) - оператор определения доступа к данным. Он определяет, кто из пользователей может отправлять запросы к базе, менять объекты и значения. Например, можно отозвать доступ у сотрудника, перешедшего в другой отдел, а также открыть доступ к базе новому маркетологу или разработчику.

- `GRANT` - предоставление доступа к объекту
- `REVOKE` - отзыв ранее выданного разрешения
- `DENY` - запрет, который является приоритетным над разрешением

### 3.4 TCL

TCL (Transaction Control Language) - язык управления транзакциями. Транзакции - это набор команд, которые выполняются поочередно. Если все команды выполнены, транзакция считается успешной, а если где-то произошла ошибка — транзакция откатывается назад, отменяя все выполненные команды. Наглядный пример такой транзакции - оплата онлайн, когда банк просит сначала ввести сумму и получателя, затем проверить и подтвердить операцию, а после ввести одноразовый код. На каждом из этих этапов оплату можно отменить и транзакция откатится назад.

- `BEGIN TRANSACTION` - обозначение начала транзакции
- `COMMIT TRANSACTION` - изменение команд внутри транзакции
- `ROLLBACK TRANSACTION` - откат транзакции
- `SAVE TRANSACTION` - указание промежуточной точки сохранения внутри транзакции

## Встроенные функции

- [Встроенные функции Postgres](https://postgrespro.ru/docs/postgresql/16)

Встроенная функция - это реализованный в СУБД код, с помощью которого можно выполнять преобразования строковых, числовых и других данных в запросах.

Каждая функция принимает набор аргументов определённого типа, выполняет заложенные в неё операции и обязательно возвращает один из возможных литералов.

Функции можно применять не только над литералами, но и над значениями, взятыми из таблицы. При этом функция выполняет преобразования для каждой строки отдельно.

```sql
SELECT UPPER("Hello world") AS upper_string;
```
- Функция 

```sql
SELECT SIGN(-69), SIGN(0), SIGN(69);
```
- Функция SIGN возвращает значение -1, если число отрицательно, 0, если число нулевое и 1, если число положительное.

```sql
SELECT ROUND(1691.7,-1), ROUND(1691.7,2), ROUND(1691.7);
```
- Для округления к ближайшему целому числу есть функция ROUND, которая любое число, десятичная часть которого больше или равна 0.5, округляет в большую сторону, иначе в меньшую.

### Дата и время

Временные данные можно получить одним из следующих способов:

- скопировать данные из существующего столбца с временным типом данных
- задать дату и время через строковое представление
- получить временны́е данные путём вызова встроенных функций, возвращающих временной тип данных

При указании даты допускается использовать любой знак пунктуации в качестве разделительного между частями разделов даты или времени. Также возможно задавать дату вообще без разделительного знака, слитно.

```sql
SELECT  CAST("2022-06-16 16:37:23" AS DATETIME) AS datetime_1,
        CAST("2014/02/22 16*37*22" AS DATETIME) AS datetime_2,
        CAST("20220616163723" AS DATETIME) AS datetime_3,
        CAST("2021-02-12" AS DATE) AS date_1,
        CAST("160:23:13" AS TIME) AS time_1,
        CAST("89" AS YEAR) AS year
```
- Примеры валидного задания временных значений через строковое представление. Для принудительного преобразования строки в дату и время использована функция CAST. Она необходима, если сервер не ожидает временного значения и, соответственно, автоматически не преобразует строку к нужному типу.

```sql
SELECT STR_TO_DATE('November 13, 1998', '%M %d, %Y') AS date;
```
- Если необходимо получить временные данные из строки, которая не соответствует ни одному формату, который принимает функция CAST, то можно использовать встроенную функцию STR_TO_DATE, которая принимает произвольную строку, содержащую дату, и формат, описывающий её.

```sql
SELECT CURDATE(), CURTIME(), NOW();
```
- Функции для генерации же текущей даты или времени.

**Функции извлечения временных данных**

Иногда необходимо получить не всю дату, а только её конкретную часть, например, месяц или год. Для этого в SQL есть следующие функции:

| Функция | Описание                                                   |
| :------ | :--------------------------------------------------------- |
| YEAR    | Возвращает год для указанной даты                          |
| MONTH   | Возвращает числовое значение месяца года (от 1 до 12) даты |
| DAY     | Возвращает порядковый номер дня в месяце (от 1 до 31)      |
| HOUR    | Возвращает значение часа (от 0 до 23) для времени          |
| MINUTE  | Возвращает значение минут (от 0 до 59) для времени         |

**Отличие DATETIME от TIMESTAMP**

Они оба направлены на хранение даты и времени, но имеют ряд отличий, определяющих их целевое использование.

| Критерий     | DATETIME                                                                       | TIMESTAMP                                                                              |
| :----------- | :----------------------------------------------------------------------------- | :------------------------------------------------------------------------------------- |
| Диапазон     | от 1000-01-01 00:00:00  <br>до 9999-12-31 23:59:59                             | от 1970-01-01 00:00:00  <br>до 2038-01-19 03:14:07                                     |
| Часовой пояс | Не учитывается  <br>Отображается в таком виде, в котором дата была установлена | Учитывается  <br>При выборках отображается с учётом текущего часового пояса сервера БД |

## Часовые пояса

Часовой пояс является одной из настроек сервера баз данных и может задаваться:

- глобально
- для текущего пользователя
- для текущей пользовательской сессии

```sql
SET GLOBAL time_zone = '+03:00';    // глобально
SET time_zone = '+03:00';           // для текущего пользователя
SET @@session.time_zone = '+03:00'; // для текущей пользовательской сессии
```

Соответственно, при изменении временной зоны все значения с типом TIMESTAMP будут выводиться с учётом текущей активной временной зоны.

## Агрегатные функции

Агрегатная функция - это функция, которая выполняет вычисление на наборе значений и возвращает одиночное значение.

Агрегатные функции применяются для значений, не равных NULL. Исключением является функция COUNT(`*`).

**Описание агрегатных функций**

|Функция|Описание|
|:--|:--|
|SUM(поле_таблицы)|Возвращает сумму значений|
|AVG(поле_таблицы)|Возвращает среднее значение|
|COUNT(поле_таблицы)|Возвращает количество записей|
|MIN(поле_таблицы)|Возвращает минимальное значение|
|MAX(поле_таблицы)|Возвращает максимальное значение|

```sql
SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type
```
- Запрос с использованием агрегатной функции AVG

## Оконные функции

**Оконные функции** - мощный инструмент языка SQL, позволяющий проводить сложные вычисления по группам строк, которые связаны с текущей строкой.

**Окно** - это динамический набор строк, который определяет какие конкретные строки в каждой партиции будут использоваться для вычисления оконной функции для каждой строки. Окно может изменяться от строки к строке.

**Партиции** - подмножества строк, выделенные для оконной функции на основе одного или нескольких столбцов в таблице. Они служат для сегментации данных, позволяя выполнить более детальный анализ и расчёты вроде агрегации или ранжирования внутри каждой такой группы.

**Сортировка в оконных функциях SQL** - ключ к расширенному анализу данных. Она позволяет упорядочивать данные внутри определённой группы или окна, обеспечивая более точные и нацеленные агрегатные вычисления. Это особенно полезно при работе с временными рядами, где важен порядок событий, или при ранжировании данных внутри групп.

Если в определении оконной функции отсутствует ROWS/RANGE, тогда окно по умолчанию совпадает с партицией. В этом случае, оконная функция будет обрабатывать все строки внутри партиции, не ограничиваясь подмножеством. Это значит, что результат функции будет одинаков для всех строк внутри той же партиции.

В стандартном SQL-запросе все наборы строк рассматриваются как один сплошной блок данных, для которого и вычисляются агрегатные значения.

Однако, когда применяются оконные функции, запрос сегментируется на группы строк (или окна), и для каждого такого сегмента подсчитываются индивидуальные агрегатные значения.

Это окно, которое подаётся в оконную функцию, может быть:

- всей таблицей
- отдельными партициями таблицы, то есть группой строк на основе одного или нескольких полей
- или даже конкретным диапазоном строк в пределах таблицы или партиции. Например, мы можем определить окно, которое будет передаваться в оконную функцию, как предыдущая + текущая строка таблицы. И тогда для каждой строки значение агрегатной функции будет подсчитываться по-своему, так как данные, которые поступают в функцию будут динамически меняться от строке к строке. Окно будет как бы «скользить» по таблице.

Оконные функции всегда принимают на вход окно данных, которое указывает пользователь, и возвращают результат в отдельный столбец.

```sql
SELECT <оконная_функция>(<поле_таблицы>)
OVER (
	[PARTITION BY <столбцы_для_разделения>]
	[ORDER BY <столбцы_для_сортировки>]
	[ROWS|RANGE <определение_диапазона_строк>]
)
```
- Синтаксис оконной функции.
- <оконная_функция>(<поле_таблицы>) - используемая оконная функция. Например AVG(price).
- Далее следует OVER, который определяет окно (группу строк), которое будет передаваться в оконную функцию. Если конструкцию OVER () оставить без параметров, то окном будет выступать вся таблица.

Далее внутри OVER следуют 3 необязательных параметра, с помощью которых можно гибко настраивать окно:

- с помощью PARTITION BY <столбцы_для_разделения> выборка делится на непересекающиеся подмножества, где каждое подмножество содержит строки с одинаковыми значениями в одном или нескольких столбцах, образуются партиции.
- с помощью ORDER BY <столбцы_для_сортировки> устанавливается порядок строк внутри окна, особо важную роль играет в оконных функциях ранжирования.
- с помощью ROWS|RANGE <определение_диапазона_строк> формируются диапазоны строк. С помощью этого параметра можно указать сколько строк брать до и после текущей в окно.

```sql
SELECT
    Student.first_name,
    Student.last_name,
    Student_in_class.class,
    COUNT(*) OVER (PARTITION BY Student_in_class.class) AS student_count_in_class
FROM
    Student_in_class
JOIN
	Student ON Student_in_class.student = Student.id;
```
- Получим список студентов и идентификатор класса, в котором они учатся. Вычислим сколько учащихся учится в каждом из классов и выведем эту информацию в новую колонку.
- Выражение PARTITION BY Student_in_class.class разделяет все строки таблицы на партиции по полю class. Так, для каждой из строк в оконную функцию будут подаваться только те строки таблицы, где поле class совпадает с полем class в текущей строке.

```sql
SELECT user_id,
       start_date,
       total AS reservation_price,
       SUM(total) OVER (
           PARTITION BY user_id
           ORDER BY start_date
       ) AS cumulative_total
FROM Reservations;
```
- Проанализируем данные о бронированиях жилых помещений, чтобы выяснить, как менялась общая сумма затраченных средств на аренду для каждого пользователя со временем.
- Данные в рамках партиции отсортированы по дате начала бронирования
- Сумма в рамках партиции накапливается, а не выводится как финальная. Это связано с одной особенностью использования сортировки без явного указания ROWS|RANGE в выражении OVER.
- При использовании ORDER BY, если в блоке ROWS|RANGE ничего не указано, то в оконной функции автоматически применяется правило RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW. Это означает, что окно будет начинаться с первой строки и заканчиваться текущей строкой.

**Возможные определения границ окна**

- UNBOUNDED PRECEDING, все строки, предшествующие текущей
- N PRECEDING, N строк до текущей строки
- CURRENT ROW, текущая строка
- N FOLLOWING, N строк после текущей строки
- UNBOUNDED FOLLOWING, все последующие строки

**Отличие ROWS от RANGE**

При использовании ROWS, определение окна основывается на физическом положении строк относительно текущей строки. Например, 1 PRECEDING означает одну строку до текущей. RANGE, в отличие от ROWS, определяет границы окна на основе значений столбцов, упорядоченных в соответствии с ORDER BY в оконной функции.

Определение окна с помощью ROWS чётко ограничивает количество строк, которые включаются в окно, делая его предсказуемым и конкретным. Границы, определённые с помощью RANGE, могут варьироваться в зависимости от данных, что делает окно гибким, но потенциально менее предсказуемым.

### Виды оконных функций

Оконные функции можно разделить на 3 группы:

- Агрегатные оконные функции
- Ранжирующие оконные функции
- Оконные функции смещения

**Агрегатные функции** - это функции, которые выполняют на наборе данных арифметические вычисления и возвращают итоговое значение.

- SUM - подсчитывает общую сумму значений;
- COUNT - считает общее количество записей в колонке;
- AVG - рассчитывает среднее арифметическое;
- MAX - находит наибольшее значение;
- MIN - определяет наименьшее значение.

```sql
SELECT id,
	home_type,
	price,
	SUM(price) OVER(PARTITION BY home_type) AS 'Sum',
	COUNT(price) OVER(PARTITION BY home_type) AS 'Count',
	AVG(price) OVER(PARTITION BY home_type) AS 'Avg',
	MAX(price) OVER(PARTITION BY home_type) AS 'Max',
	MIN(price) OVER(PARTITION BY home_type) AS 'Min'
FROM Rooms;
```
- Агрегатные оконные функции

**Ранжирующие оконные функции** - это функции, которые ранжируют значение для каждой строки в окне.

В ранжирующих функциях под ключевым словом OVER обязательным идёт указание условия ORDER BY, по которому будет происходить сортировка ранжирования.

- ROW_NUMBER - возвращает номер строки, используется для нумерации;
- RANK - возвращает ранг каждой строки;
- DENSE_RANK - возвращает ранг каждой строки. Но в отличие от функции RANK, она для одинаковых значений возвращает ранг, не пропуская следующий;

```sql
SELECT id,
	home_type,
	price,
	ROW_NUMBER() OVER(PARTITION BY home_type ORDER BY price) AS 'row_number',
	RANK() OVER(PARTITION BY home_type ORDER BY price) AS 'rank',
	DENSE_RANK() OVER(PARTITION BY home_type ORDER BY price) AS 'dense_rank'
FROM Rooms;
```
- Ранжирующие оконные функции.

**Оконные функции смещения** - это функции, которые позволяют перемещаться и обращаться к разным строкам в окне, относительно текущей строки, а также обращаться к значениям в начале или в конце окна.

- LAG - обращается к данным из предыдущих строк окна. Имеет три аргумента: столбец, значение которого необходимо вернуть, количество строк для смещения (по умолчанию 1), значение, которое необходимо вернуть, если после смещения возвращается значение NULL.
- LEAD - обращается к данным из следующих строк. Аналогично LAG имеет 3 аргумента.
- FIRST_VALUE - возвращает первое значение в окне. В качестве аргумента принимает столбец, значение которого необходимо вернуть.
- LAST_VALUE - возвращает последнее значение в окне. В качестве аргумента принимает столбец, значение которого необходимо вернуть.

```sql
SELECT id,
	home_type,
	price,
	LAG(price) OVER(PARTITION BY home_type ORDER BY price) AS 'lag',
	LAG(price, 2) OVER(PARTITION BY home_type ORDER BY price) AS 'lag_2',
	LEAD(price) OVER(PARTITION BY home_type ORDER BY price) AS 'lead',
	FIRST_VALUE(price) OVER(PARTITION BY home_type ORDER BY price) AS 'first_value',
	LAST_VALUE(price) OVER(PARTITION BY home_type ORDER BY price) AS 'last_value'
FROM Rooms;
```
- Оконные функции смещения.

## Подзапросы

Подзапрос - это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключён в круглые скобки и обычно выполняется перед основным запросом.

```sql
SELECT * FROM Reservations
WHERE Reservations.room_id = (
	SELECT id FROM Rooms ORDER BY price DESC LIMIT 1
)
```
- Получим список всех бронирований самого дорогого на данный момент жилого помещения. В данном случае запрос на получение самого дорогого жилого помещения выполняется в качестве подзапроса, а затем результат результирующего набора применяется в основном запросе.

### Подзапрос с одной строкой с одним столбцом

Данный тип подзапросов также известен как скалярный подзапрос.

Он может использоваться в различных частях основного SQL запроса, но чаще всего он используется в условиях ограничений выборки с помощью операторов сравнения (=, <>, >, <).

```sql
SELECT * FROM FamilyMembers
WHERE birthday = (SELECT MAX(birthday) FROM FamilyMembers);
```
- С помощью данного запроса возможно получить самого младшего члена семьи. Подзапрос в данном случае необходим для получения максимальной даты рождения, которая затем используется в основном запросе для фильтрации строк.

При использовании результата подзапроса с операторами сравнения, важно, чтобы подзапрос возвращал именно скалярное значение (1 строка и 1 колонка).

### Подзапросы с несколькими строками и одним столбцом

Если подзапрос возвращает более одной строки, его нельзя просто использовать с операторами сравнения. Однако c подзапросами, возвращающими несколько строк и один столбец, можно использовать 3 дополнительных оператора.

```sql
SELECT 200 > ALL(SELECT price FROM Rooms)
```
- С помощью оператора ALL мы можем сравнивать отдельное значение с каждым значением в наборе, полученным подзапросом. При этом данное условие вернёт TRUE, только если все сравнения отдельного значения со значениями в наборе вернут TRUE.
- Этот запрос проверяет для всех ли жилых помещений выполняется условие, что оно дешевле чем 200.

```sql
SELECT * FROM Users WHERE id IN (
SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```
- Оператор IN проверяет входит ли конкретное значение в набор значений. В качестве такого набора как раз может использоваться подзапрос, возвращающий несколько строк с одним столбцом.
- Например, получим всю информацию о владельцах жилья стоимостью больше 150 условных единиц.

```sql
SELECT * FROM Users WHERE id = ANY (
SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```
- Условное выражение с ANY имеет схожее поведение, но оно возвращает TRUE, если хотя бы одно сравнение отдельного значения со значением в наборе вернёт TRUE.
- Найдём пользователей, которые владеют хотя бы 1 жилым помещением стоимостью более 150.

### Многостолбцовые подзапросы

SQL поддерживает сравнение не только по одной колонке, но позволяет попарно сравнивать значения в основном запросе со значениями в подзапросе.

```sql
SELECT * FROM Reservations
WHERE (room_id, price) IN (SELECT id, price FROM Rooms);
```
- Например, можем получить информацию о всех бронированиях, в которых цена жилья на момент брони (Reservations.price) соответствует текущей стоимостью жилья (Rooms.price). В данном примере, подзапрос возвращает таблицу с идентификаторами жилых помещений и их текущей ценой

### Коррелированные подзапросы

Все предыдущие рассматриваемые подзапросы были некоррелированные (независимые). Они могли выполняться автономно от основного запроса и мы могли посмотреть, что они возвращают перед тем, как их результат будет использоваться в основном запросе. Коррелированные же подзапросы ссылаются на один или несколько столбцов основного запроса.

```sql
SELECT FamilyMembers.member_name, (
    SELECT SUM(Payments.unit_price * Payments.amount)
    FROM Payments
    WHERE Payments.family_member = FamilyMembers.member_id
) AS total_spent
FROM FamilyMembers;
```
- В данном случае, коррелированный подзапрос ссылается к столбцу member_id из основного запроса.
- Коррелированный подзапрос отличается от некоррелированного подзапроса тем, что он выполняется не один раз перед выполнением запроса, в который он вложен, а для каждой строки, которая может быть включена в окончательный результат.
- Например, основной запрос к таблице FamilyMembers возвращает 8 записей, то для каждой из них выполняется коррелированный подзапрос.

> Использование коррелированных подзапросов может вызвать проблемы с производительностью, особенно если содержащий запрос возвращает много строк, так как коррелированный подзапрос будет выполняться для каждой строки содержащего запроса отдельно.

## CAST

Когда мы выполняем операции со значениями с разными типами данных, СУБД пытается выполнить преобразование и привести используемые значения к нужному типу. Например, в примере ниже мы сравниваем значения с типами STRING и INT. Чтобы выполнить это сравнение MySQL автоматически сконвертирует строковое значение в числовое.

```sql
SELECT '50' > 49, '50' > 51;
```

Но не все преобразования СУБД может сделать автоматически, и тогда необходимо делать явное преобразование типов. Для этого в MySQL есть две очень схожие функции CAST и CONVERT.

```sql
CAST(значение AS тип_для_конвертации);
CONVERT(значение, тип_для_конвертации);
```
- Синтаксис.

## Транзакции

**Транзакция** - это последовательность операций с базой данных, которые выполняются как единое целое.

Системы управления базами данных обеспечивают возможность одному пользователю извлекать и модифицировать данные. Однако в современном мире тысячи людей могут вносить изменения в базу данных одновременно. Если пользователи в основном осуществляют только чтение данных, то такая нагрузка не представляет особой сложности для сервера базы данных. Но если некоторые пользователи одновременно добавляют и/или изменяют данные, то серверу приходится решать намного более сложные задачи.

**Блокировка** - это метод ограничения доступа к данным для обеспечения корректной обработки транзакций.

Серверы баз данных используют блокировки, чтобы управлять одновременным доступом к данным, чтобы пока одна транзакция работает с данными, другие транзакции не могли их изменять.

Когда данные в базе блокируются, другие пользователи, которые хотят изменить или прочитать эти же данные, должны подождать, пока блокировка не будет снята.

Существует ряд различных стратегий, которые могут использоваться, как именно блокировать ресурс. Сервер может применять блокировку на одном из трёх разных уровней, или гранулярностей.

- Блокировка таблиц: Не позволяет нескольким пользователям одновременно изменять данные в одной таблице.
- Блокировка страниц: Не позволяет нескольким пользователям изменять данные в одной и той же странице (страница - это сегмент памяти, обычно в диапазоне от 2 до 16 Кбайт) таблицы одновременно.
- Блокировка строк: Не позволяет нескольким пользователям одновременно изменять одну и ту же строку в таблице.

Эти подходы имеют свои преимущества и недостатки. Блокировка всей таблицы требует небольшого времени, но при увеличении числа пользователей может привести к долгим ожиданиям. Блокировка строк требует большего объёма дополнительных действий, но зато позволяет нескольким пользователям изменять одну и ту же таблицу, если они работают с разными строками.

### Создание транзакций

```sql
-- Начало транзакции
START TRANSACTION;

-- Проверка наличия достаточного баланса у отправителя
SELECT @balance := user_balance FROM accounts WHERE user_id = 1;

-- Если средств недостаточно, отмена транзакции
IF @balance < 1000 THEN
ROLLBACK;
END IF;

-- Проверка на существование получателя
SELECT @exists := COUNT(*) FROM accounts WHERE user_id = 2;
IF @exists = 0 THEN
ROLLBACK;
END IF;

-- Обновление баланса счетов, если все проверки пройдены
UPDATE accounts SET user_balance = user_balance - 1000 WHERE user_id = 1;
UPDATE accounts SET user_balance = user_balance + 1000 WHERE user_id = 2;

-- Применение изменений
COMMIT;
```

Каждая явная транзакция начинается с использования оператора START TRANSACTION.

Завершение же транзакции возможно:

- с помощью команды COMMIT, которая даёт указание серверу пометить изменения как постоянные и освободить все ресурсы (т.е. блокировки строк), использовавшиеся во время транзакции
- с помощью команды ROLLBACK, которая требует от сервера вернуть данные в состояние до начала транзакции. После завершения отката также любые ресурсы, используемые транзакцией, освобождаются.

Помимо использования команд COMMIT и ROLLBACK, транзакция также может завершиться в результате внешних факторов. Например, если сервер выключается, в этом случае ваша транзакция будет автоматически отменена при перезапуске сервера.

### Точки сохранения

В определённых ситуациях вам может потребоваться выполнить откат в транзакции, не отменяя всю проделанную работу. Для этого вы можете установить одну или несколько точек сохранения в рамках транзакции. Это позволяет вам откатиться к конкретной точке в транзакции, а не к её началу.

Каждой точке сохранения в рамках одной транзакции необходимо присвоить уникальное имя, что позволит использовать множество разных точек сохранения. Для создания точки сохранения под названием my_savepoint используйте следующую команду:

```sql
SAVEPOINT my_savepoint;
```

Для отката к определённой точке сохранения просто вводится команда ROLLBACK, за которой следуют ключевые слова TO SAVEPOINT и имя точки сохранения, например:

```sql
START TRANSACTION;

-- Создаем точку сохранения перед изменением баланса первого пользователя
SAVEPOINT before_updating_user_1;
UPDATE accounts SET balance = balance + 100 WHERE user_id = 1;

-- Проверка условия для первого пользователя
-- например, проверяем логику бизнес-правил

-- Здесь мы предполагаем, что условие не выполнилось, и нам нужно отменить изменение баланса
ROLLBACK TO SAVEPOINT before_updating_user_1;

-- Обновляем баланс для второго пользователя
UPDATE accounts SET balance = balance + 200 WHERE user_id = 2;

-- Завершаем транзакцию
COMMIT;
```

В результате этой транзакции баланс первого пользователя останется без изменений из-за отката к точке сохранения, а баланс второго пользователя увеличится на 200. Это показывает, как можно управлять изменениями в базе данных с высоким уровнем контроля при помощи транзакций и точек сохранения.

Когда вы используете точки сохранения, помните следующие моменты:

- Несмотря на название, при создании точки сохранения ничего не сохраняется. Чтобы ваши изменения в рамках транзакции стали постоянными, необходимо выполнить команду COMMIT.
- При выполнении отката транзакции без указания конкретной точки сохранения, все ранее установленные точки сохранения будут проигнорированы, и будет произведён откат всей транзакции.

## Индексы

Когда вы добавляете в таблицу новую строку, СУБД размещает эти данные не оптимально. Например, если вы добавляете строку в таблицу Users, СУБД не размещает строки в числовом порядке значений столбца id или в алфавитном порядке значений столбца last_name. Вместо этого он просто помещает данные в следующее доступное место в файле (СУБД поддерживает список свободных мест для каждой таблицы).

Это приводит к тому, что для выполнения запроса типа:

```sql
SELECT email FROM Users WHERE email LIKE 'l%';
```

Серверу базы данных приходится проверять каждую строку таблицы, чтобы найти соответствия. Это подходит для маленьких таблиц, но становится чрезмерно времязатратным по мере роста объёма данных.

Для сравнения как запрос на поиск по email отработает в зависимости от наличия индекса на поле.

Индексы функционируют как предметные указатели в книге, позволяя быстро находить информацию без прочтения всего текста. Они представляют собой специальные таблицы, строки которых, в отличие от обычных таблиц данных, расположены в строго определённом порядке. Но вместо того, чтобы содержать все данные о некоторой записи, индекс содержит только столбец (или столбцы), используемый, чтобы найти строки в таблице данных, вместе с информацией, описывающей, где физически расположена эта строка. Таким образом, роль индексов состоит в том, чтобы облегчить поиск подмножества строк и столбцов таблицы без необходимости сканировать каждую строку в таблице.

Возвращаясь к таблице Users, вы можете добавить индекс к столбцу email, чтобы ускорить любые запросы, которые работают со значением этого столбца.

Вот как можно добавить такой индекс в СУБД MySQL:

```sql
CREATE INDEX idx_email
    ON Users (email);
```

Эта инструкция создаёт индекс c именем idx_email для столбца Users.email. При наличии индекса оптимизатор запросов может выбрать использование индекса, если сочтёт это полезным. Если в таблице имеется более одного индекса, оптимизатор должен решить, применение какого именно индекса наиболее выгодно для конкретной инструкции SQL.

Если после создания индекса вы решите, что он больше не нужен, можете удалить его следующим образом:

```sql
DROP INDEX idx_email ON Users;
```

### Многостолбцовые индексы

Помимо одностолбцовых индексов, существует возможность создавать индексы, включающие в себя несколько столбцов. К примеру, для поиска студентов по имени и фамилии можно создать совместный индекс по этим двум полям:

```sql
CREATE INDEX idx_full_name
    ON Student (last_name, first_name);
```

Такой индекс окажется полезным для запросов, где необходимы и имя, и фамилия, или только фамилия. Однако, для запросов, задающих только имя, он не принесёт пользы. Это аналогично поиску номера телефона по телефонному справочнику: если известны и имя, и фамилия, поиск упрощается благодаря упорядоченности справочника по фамилии, а затем по имени. Если же известно только имя, придётся перебирать все записи в поисках нужного человека.

При создании индексов, включающих несколько столбцов, важно продумать порядок столбцов в индексе, чтобы он был максимально эффективным. Однако для достижения нужной производительности запросов всегда можно создать несколько индексов с теми же столбцами, но разным порядком их следования.