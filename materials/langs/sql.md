# SQL

- https://sql-academy.org/ru/guide/intro-intro
- https://www.sql-ex.ru/learn_exercises.php
- https://learndb.ru/
- https://stepik.org/lesson/297508/step/1?unit=279268

## 1 Что такое SQL?

SQL (Structured Query Language) - это язык программирования, используемый в большинстве реляционных баз данных для запросов, обработки и определения данных, а также контроля доступа. SQL был разработан в IBM в 1970-х годах. Со временем у стандарта SQL ANSI появились многочисленные расширения, разработанные такими компаниями как IBM, Oracle и Microsoft. Хотя в настоящее время SQL все еще широко используется, начали появляться новые языки программирования запросов.

Является, прежде всего, информационно-логическим языком, предназначенным для описания, изменения и извлечения данных, хранимых в реляционных базах данных. В общем случае SQL (без ряда современных расширений) считается языком программирования неполным по Тьюрингу, но вместе с тем стандарт языка спецификацией SQL/PSM предусматривает возможность его процедурных расширений.

Язык SQL - универсальный язык для всех реляционных систем управления базами данных, но многие СУБД вносят свои изменения в язык, применяемый в них, тем самым отступая от стандарта. Такие языки называют диалектами или расширениями языка.

Диалекты SQL:

- T-SQL - диалект Microsoft SQL Server
- PL/SQL - диалект Oracle Database
- PL/pgSQL - диалект PostgreSQL

**MySQL**

- **Особенности:** MySQL - это одна из самых популярных реляционных баз данных, широко используемая в веб-разработке и других областях. Его диалект SQL характеризуется простым и интуитивно понятным синтаксисом.
- **Основные различия:** Одним из отличительных особенностей MySQL является использование двойных кавычек для обозначения строковых значений, в то время как в других диалектах SQL используются одинарные кавычки. Кроме того, MySQL имеет свои собственные функции и операторы, такие как LIMIT для ограничения количества возвращаемых записей в запросе.

**PostgreSQL**

- **Особенности:** PostgreSQL - это мощная и расширяемая реляционная база данных с открытым исходным кодом. Ее диалект SQL предоставляет богатый набор функций и возможностей.
- **Основные различия:** PostgreSQL часто использует двойные кавычки для обозначения идентификаторов, таких как имена таблиц и столбцов, что отличается от стандартного использования одинарных кавычек в других диалектах. Кроме того, PostgreSQL предоставляет множество расширений и возможностей, таких как оконные функции и генерируемые столбцы.

**Microsoft SQL Server**

- **Особенности:** Microsoft SQL Server - это коммерческая реляционная база данных, разработанная корпорацией Microsoft. Ее диалект SQL широко используется в корпоративной среде и имеет свои собственные особенности.
- **Основные различия:** В SQL Server, например, используется функция TOP вместо LIMIT для ограничения количества возвращаемых записей. Также в SQL Server могут присутствовать различия в типах данных и синтаксисе для некоторых операторов и функций.

SQL позволяет:

- получать доступ к данным в системах управления РБД
- описывать данные (их структуру)
- определять данные в БД и управлять ими
- взаимодействовать с другими языками через модули SQL, библиотеки и предварительные компиляторы
- создавать и удалять БД и таблицы
- создавать представления, хранимые процедуры (stored procedures) и функции в БД
- устанавливать разрешения на доступ к таблицам, процедурам и представлениям

## 2 Элементы SQL

### 2.0 Создание БД и таблиц

```bash
# Создание БД
CREATE DATABASE dbname;

# Создание пользователя
CREATE USER dbuser WITH PASSWORD 'password';

# Назначение прав пользователю на БД
GRANT ALL PRIVILEGES ON DATABASE dbname TO dbuser;

# Удаление пользователя
DROP ROLE dbuser;
```

```bash
\c db_test
```

```bash
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    CustomerName VARCHAR(255),
    City VARCHAR(255),
    Country VARCHAR(255)
);

CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    Total_amount DECIMAL(10, 2),
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE employees (
    Employee_id INT PRIMARY KEY,
    Name VARCHAR(255),
    Salary DECIMAL(10, 2),
    Department_id INT,
    Email VARCHAR(255)
);

CREATE TABLE products (
    Product_id INT PRIMARY KEY,
    Price DECIMAL(10, 2),
    Category VARCHAR(255)
);

CREATE TABLE OrderDetails (
    OrderDetail_id INT PRIMARY KEY,
    OrderID INT,
    ProductID INT,
    Quantity INT,
    FOREIGN KEY (OrderID) REFERENCES Orders(OrderID)
);
```

Добавим данные:

```bash
INSERT INTO Customers (CustomerID, CustomerName, City, Country) VALUES
(1, 'Ivan Ivanov', 'Moscow', 'Russia'),
(2, 'John Smith', 'New York', 'USA'),
(3, 'Anna Schmidt', 'Berlin', 'Germany');

INSERT INTO Orders (OrderID, CustomerID, Total_amount) VALUES
(1, 1, 100),
(2, 2, 200),
(3, 3, 300);

INSERT INTO Employees (Employee_id, Name, Salary, Department_id, Email) VALUES
(1, 'John Doe', 5000, 10, 'johndoe@email.com'),
(2, 'Jane Smith', 6000, 20, 'janesmith@email.com'),
(3, 'Emily Johnson', 7000, 30, 'emilyjohnson@email.com');

INSERT INTO products (Product_id, Price, Category) VALUES
(1, 100, 'Category A'),
(2, 200, 'Category B'),
(3, 300, 'Category C');

INSERT INTO OrderDetails (OrderDetail_id, OrderID, ProductID, Quantity) VALUES
(1, 1, 1, 10),
(2, 2, 2, 20),
(3, 3, 3, 30);
```

### 2.1 SELECT

```sql
SELECT * FROM employees;
```
- Одна из основных функций SQL - это получение выборок данных из СУБД. Для этого в SQL используется оператор SELECT. Оператор SELECT можно выводить данные не только из таблиц базы данных, но и произвольные строки, числа, даты и т.д.

```sql
SELECT id AS alias_id FROM users;

SELECT id alias_id FROM users;
```
- В случае, если мы хотим вывести какие-то столбцы таблицы, но чтобы в итоговой выборке они были названы иначе, мы можем использовать псевдонимы (их также называют алиасами). Их синтаксис достаточно простой, мы должны использовать оператор AS. Или же можно обойтись и без него, просто написав желаемое наименование поля через пробел. Псевдонимы могут содержать до 255 знаков (включая пробелы, цифры и специальные символы).

```sql
SELECT 'Hello world'

SELECT 'Hello', 'world'
```
- Если предложение FROM опущено, то оператор SELECT вернет ровно одну строку со значениями, состоящими из констант, строковых литералов, результатов вызовов функций и операций над всем вышеперечисленным.

### 2.2 WHERE

Для ограничения количества возвращаемых строк в SQL существует предложение WHERE. В WHERE указывается логическое выражение, которое служит фильтром строк: в результате остаются только те строки, для которых это выражение истинно.

```sql
SELECT * FROM orders WHERE total_amount > 100;
```
- Условный оператор WHERE используется для фильтрации результатов запроса в соответствии с определенным условием.

### 2.4 HAVING

HAVING - необязательный элемент запроса, который отвечает за фильтрацию на уровне сгруппированных данных (по сути, WHERE, но только на уровень выше). 

```sql
SELECT City, COUNT(CustomerID) 
FROM Customers 
GROUP BY City 
HAVING COUNT(CustomerID) >= 5;
```
- Фильтрация агрегированной таблицы с количеством клиентов по городам, в данном случае оставляем в выгрузке только те города, в которых не менее 5 клиентов.

```sql
SELECT City, COUNT(CustomerID) as number_of_clients 
FROM Customers 
WHERE CustomerName not in ('Around the Horn', 'Drachenblut Delikatessend') 
GROUP BY City 
HAVING COUNT(CustomerID) >= 1;
```
- Пример запроса, содержащего WHERE и HAVING. В данном запросе сначала фильтруется исходная таблица по пользователям, рассчитывается количество клиентов по городам и остаются только те города, где количество клиентов не менее 1.

### 2.5 Операторы INSERT, UPDATE и DELETE

```sql
INSERT INTO employees (employee_id, name, salary) VALUES (14, 'John', 5000);

UPDATE employees SET salary = 10000 WHERE name = 'John';

DELETE FROM employees WHERE employee_id = 14;
```
- Операторы INSERT, UPDATE и DELETE используются для добавления, обновления и удаления данных в таблицах баз данных соответственно.

### 2.6 Операторы CREATE TABLE и ALTER TABLE

```sql
CREATE TABLE employees_2 (
	employee_id INT PRIMARY KEY,
	name VARCHAR(100),
	department_id INT
);

ALTER TABLE employees_2 ADD COLUMN email VARCHAR(255);
```
- Операторы CREATE TABLE и ALTER TABLE используются для создания и изменения структуры таблиц баз данных.

### 2.7 Операторы INDEX и CONSTRAINT

```sql
CREATE INDEX idx_customer_name ON customers (customername);

ALTER TABLE orders 
ADD CONSTRAINT fk_customerid 
FOREIGN KEY (customerid) 
REFERENCES customers(customerid);
```
- Операторы INDEX и CONSTRAINT используются для определения индексов и ограничений целостности данных в базе данных. Индексация позволяет базе данных быстрее находить записи в таблице на основе значений указанного столбца (в данном случае, "name"). Это очень полезно для ускорения процесса поиска в больших таблицах.

### 2.8 GROUP BY

GROUP BY - необязательный элемент запроса, с помощью которого можно задать агрегацию по нужному столбцу (например, если нужно узнать какое количество клиентов живет в каждом из городов).

При использовании GROUP BY мы можем выводить только:

- литералы, т.е. указанное явным образом фиксированные значения.
- результаты агрегатных функций, т.е. вычисленные значения на основании набора значений.
- поля группировки.

При использовании GROUP BY обязательно:

1. перечень столбцов, по которым делается разрез, был одинаковым внутри SELECT и внутри GROUP BY,
2. агрегатные функции (SUM, AVG, COUNT, SELECT family_member, member_name FROM Payments
INNER JOIN FamilyMembers
    ON Payments.family_member = FamilyMembers.member_idMAX, MIN) должны быть также указаны внутри SELECT с указанием столбца, к которому такая функция применяется.

```sql
SELECT City, COUNT(CustomerID) 
FROM Customers 
GROUP BY City;
```
- Группировка количества клиентов по городу.

```sql
SELECT Country, City, COUNT(CustomerID) 
FROM Customers 
GROUP BY Country, City;
```
- Группировка количества клиентов по стране и городу.

```sql
SELECT ProductID, COUNT(OrderID), SUM(Quantity) 
FROM OrderDetails 
GROUP BY ProductID;
```
- Группировка продаж по ID товара с разными агрегатными функциями: количество заказов с данным товаром и количество проданных штук товара.

```sql
SELECT City, COUNT(CustomerID) 
FROM Customers 
WHERE Country = 'Germany' 
GROUP BY City;
```
- Группировка продаж с фильтрацией исходной таблицы. В данном случае на выходе будет таблица с количеством клиентов по городам Германии.

```sql
SELECT City, COUNT(CustomerID) AS Number_of_clients 
FROM Customers 
GROUP BY City;
```
- Переименование столбца с агрегацией с помощью оператора AS. По умолчанию название столбца с агрегацией равно примененной агрегатной функции, что далее может быть не очень удобно для восприятия.

### 2.9 JOIN

Оператор JOIN используется для объединения таблиц по ключу, который присутствует в обеих таблицах. Перед ключом ставится оператор ON.

В большинстве случаев условием соединения является равенство столбцов таблиц (таблица_1.поле = таблица_2.поле), однако точно так же можно использовать и другие операторы сравнения.

```sql
SELECT поля_таблиц
FROM таблица_1
[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_2
ON условие_соединения
[[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_n
ON условие_соединения]
```
- Общая структура многотабличного запроса.

**Соединение бывает внутренним INNER (по умолчанию) и внешним OUTER, при этом внешнее соединение делится на левое LEFT, правое RIGHT и полное FULL.**

Главным отличием внешнего соединения от внутреннего является то, что оно обязательно возвращает все строки одной (LEFT, RIGHT) или двух таблиц (FULL).

Внутреннее соединение - соединение, при котором находятся пары записей из двух таблиц, удовлетворяющие условию соединения, тем самым образуя новую таблицу, содержащую поля из первой и второй исходных таблиц.

```sql
SELECT family_member, member_name
FROM Payments
INNER JOIN FamilyMembers
ON Payments.family_member = FamilyMembers.member_id
-- OR
SELECT family_member, member_name
FROM Payments, FamilyMembers
WHERE Payments.family_member = FamilyMembers.member_id
```
- Аналогичные запросы. Внутреннее соединение можно выполнить не используя ключевое слово `JOIN`. Для этого достаточно сделать декартово произведение строк таблиц, а условия соединения прописать в предложении `WHERE`.

#### 2.9.1 Типы соединений

- `INNER JOIN` или просто `JOIN` - внутреннее соединение. В результате остаются только те строки, для которых нашлось соответствие.
- `LEFT JOIN` - левое внешнее соединение. Работает как `JOIN`, но если для строки таблицы, находящейся по левую сторону ключевого слова `LEFT JOIN`, не нашлось ни одной строки в таблице, находящейся по правую сторону `LEFT JOIN`, то строка все равно добавляется в результат, а значения столбцов правой таблицы равны `null`.
- `RIGHT JOIN` - правое внешнее соединение. Работает как `JOIN`, но если для строки таблицы, находящейся по правую сторону ключевого слова `RIGHT JOIN`, не нашлось ни одной строки в таблице, находящейся по левую сторону `RIGHT JOIN`, то строка все равно добавляется в результат, а значения столбцов левой таблицы равны `null`.
- `FULL JOIN` - полное внешнее соединение. Если для какой-либо из таблиц не нашлось строки в другой таблице, то строка все равно попадает в результат, а значения столбцов другой таблицы равны `null`.
- `CROSS JOIN` - перекрестное (или декартово) произведение. Каждая строка одной таблицы соединяется с каждой строкой второй таблицы, давая тем самым в результате все возможные сочетания строк двух таблиц. Аналогичного результата можно достичь просто перечислив таблицы в `FROM` через запятую.

Соединение FULL JOIN реализовано не во всех СУБД. Например, в MySQL оно отсутствует, однако его можно очень просто эмулировать.

```sql
SELECT Timepair.id 'timepair.id', start_pair, end_pair,
Schedule.id 'schedule.id', date, class, number_pair, teacher, subject, classroom
FROM Timepair
LEFT JOIN Schedule ON Schedule.number_pair = Timepair.id;
```
- Для примера получим из базы данных расписание звонков, объединённых с соответствующими занятиями в расписании занятий. В выборку попали все строки из левой таблицы, дополненные данными о занятиях. В конце таблицы есть строки с полями, заполненными NULL. Это те строки, для которых не нашлось соответствующих занятий, однако они присутствуют в левой таблице, поэтому тоже были выведены.

#### 2.9.2 Псевдонимы таблиц

В условиях соединения ON имя таблицы обычно не пишут. Подобно псевдонимам столбцов в списке выборки SELECT можно задать псевдонимы таблицам. Для этого после названия таблицы через пробел нужно написать псевдоним таблицы. После того, как таблице назначен псевдоним, обращаться к ней по названию уже нельзя - только по псевдониму.

```sql
SELECT c.city_id, name, time_offset
FROM city c
JOIN timezone t
ON t.timezone_id = c.timezone_id
```
- Алиасы таблиц также удобно использовать в списке выборки SELECT. Выберем, например, из таблиц городов и часовых поясов только идентификатор города, название города и время относительно UTC. Если поле встречается только в одной таблице, то в списке выборки таблицу, из которой взять столбец, указывать не обязательно. Лучше всегда указывать из какой таблицы поле.

#### 2.9.3 Несколько условий соединения

В условии соединения таблиц можно использовать произвольное количество логических выражений (как в предложении WHERE).

```sql
SELECT e.first_name, e.last_name, r.rank_id, r.store_id, r.name as rank_name
FROM employee e
JOIN rank r
ON r.rank_id = e.rank_id
AND r.store_id = e.store_id
LIMIT 5
```
- Например, получим информацию о должностях произвольных 5-ти сотрудников. Чтобы найти информацию о должности сотрудника, нужно из таблицы rank взять строку с таким же идентификатором магазина и идентификатором должности в магазине.

#### 2.9.4 Использование таблицы несколько раз

Если одну и ту же таблицу необходимо использовать в запросе несколько раз, то необходимо воспользоваться псевдонимами для таблиц. Например, для каждой стоимости товара в магазине найдем предложение на такой же товар в другом магазине по меньшей цене.

```sql
SELECT pp.product_id, pp.store_id, pp.price, ppl.store_id AS store_id_less, ppl.price AS price_less
FROM product_price pp
JOIN product_price ppl
ON ppl.product_id = pp.product_id
AND ppl.store_id != pp.store_id
AND ppl.price < pp.price
ORDER BY pp.product_id, pp.store_id, ppl.store_id, ppl.price
```
- Берутся все строки из таблицы product_price. Дальнейшее обращение к этому набору строк происходит через pp.
- Для каждой строки из пункта 1 просматривается еще раз все строки таблицы product_price. Обращение к строкам последней происходит через ppl.
- Если цена price у строки из второй копии product_price меньше, чем у строки из первой копии product_price, то связка этих строк добавляется в результат выполнения запроса.
- В конце результат сортируется согласно ORDER BY.

### 2.10 DISTINCT

Иногда в таблицах встречаются дубликаты, как например имена сотрудников. Для исключения повторяющихся строк, нужно после ключевого слова SELECT написать DISTINCT. DISTINCT может применяться для нескольких колонок.

```sql
SELECT DISTINCT id FROM users;

SELECT DISTINCT id, name FROM users;
```

### 2.11 Логические операторы

В предложении WHERE могут присутствовать логические операторы:

- `AND` - логическое И;
- `OR` - логическое ИЛИ;
- `NOT` - отрицание.

При составлении условия WHERE важно учитывать порядок выполнения условий. А выполняются они в следующем порядке:

1. `NOT`
2. `AND`
3. `OR`

В предложении WHERE помимо проверки на равенство можно использовать и другие операции сравнения. Доступны следующие операторы:

- `<` - меньше;
- `>` - больше;
- `<=` - меньше или равно;
- `>=` - больше или равно;
- `=` - равно;
- `!=` или `<>` - не равно.

### 2.12 IS NULL, BETWEEN, IN

Оператор IS NULL позволяет узнать равно ли проверяемое значение NULL, т.е. пустое ли значение.

```sql
SELECT * FROM Teacher
WHERE middle_name IS NOT NULL;
```

Оператор BETWEEN min AND max позволяет узнать расположено ли проверяемое значение столбца в интервале между min и max, включая сами значения min и max.

```sql
SELECT * FROM Payments
WHERE unit_price BETWEEN 100 AND 500;
```

Оператор IN позволяет узнать входит ли проверяемое значение столбца в список определённых значений.

```sql
SELECT * FROM FamilyMembers
WHERE status IN ('father', 'mother');
```

### 2.13 LIKE

Оператор LIKE используется при условных запросах, когда мы хотим узнать соответствует ли строка определённому шаблону.

В шаблоне LIKE можно использовать два спецсимвола:

- `_` - заменяет один любой символ;
- `%` - заменяет любую последовательность символов (в том числе пустую)

```sql
'abc' LIKE 'abc'    true
'abc' LIKE 'a%'     true
'abc' LIKE '_b_'    true
'abc' LIKE 'c'      false
```
- Примеры

```sql
SELECT name, email FROM users
WHERE email LIKE '%@hotmail.%'
```
- Пример использования оператора LIKE

При проверке по шаблону `LIKE` всегда рассматривается вся строка. Поэтому, если нужно найти последовательность символов где-то в середине строки, шаблон должен начинаться и заканчиваться знаком `%`.

Чтобы найти в строке буквальное вхождение знака процента или подчёркивания, перед соответствующим символом в шаблоне нужно добавить спецсимвол. По умолчанию в качестве спецсимвола выбрана обратная косая черта `\`, но с помощью предложения `ESCAPE` можно выбрать и другой. Чтобы включить спецсимвол в шаблон поиска, продублируйте его. Синтаксис `LIKE` с указанием спецсимвола:

```sql
'_asdfa' LIKE '$_asd%' ESCAPE '$'
```

Вместо `LIKE` можно использовать ключевое слово `ILIKE`, чтобы поиск был регистр-независимым с учётом текущей языковой среды.

### 2.14 REGEXP

Оператор REGEXP (или его синоним RLIKE) в SQL используется для поиска и обработки строковых данных с помощью регулярных выражений. Регулярные выражения предоставляют мощные возможности для сложных шаблонов поиска, которые трудно реализовать с помощью оператора LIKE.

```sql
SELECT * FROM Users WHERE name REGEXP '^John'
```
- Это выражение ищет строки, начинающиеся с «John». Символ ^ указывает на начало строки.

```sql
SELECT * FROM  Subject WHERE name REGEXP '[ey]$'
```
- В этом примере, `[ey]` определяет список возможных значений для паттерна $, определяющего на что должна заканчиваться строка.

```sql
SELECT * FROM Users WHERE phone_number REGEXP '^[^28]*$'
```
- В этом примере символ `[^28]` обозначает любой символ, кроме «2» и «8», а * означает любое количество таких символов. Символы ^ и $ указывают на начало и конец строки соответственно, гарантируя, что вся строка соответствует шаблону.

### 2.15 ORDER BY

При выполнении SELECT запроса, строки по умолчанию возвращаются в неопределённом порядке. Фактический порядок строк в этом случае зависит от плана соединения и сканирования, а также от порядка расположения данных на диске, поэтому полагаться на него нельзя. Для упорядочивания записей используется конструкция ORDER BY.

ASC и DESC - направление сортировки:

- ASC - сортировка по возрастанию (по умолчанию)
- DESC - сортировка по убыванию

```sql
SELECT store_id, name
FROM store
ORDER BY name
```
- Сортировка по возрастанию

```sql
SELECT store_id, name
FROM store
ORDER BY name DESC
```
- Сортировка по убыванию

```sql
SELECT employee_id, rank_id, last_name
FROM employee
ORDER BY rank_id ASC, last_name DESC
```
- Сортировка по нескольким столбцам. Данные будут сортироваться по первому столбцу, но в случае если попадаются несколько записей с совпадающими значениями в первом столбце, то они сортируются по второму столбцу

### 2.16 LIMIT, OFFSET

Конструкция LIMIT позволяет получить только часть строк от результата запроса.

Применяя LIMIT, важно использовать также предложение ORDER BY, чтобы строки результата выдавались в определённом порядке. Иначе будут возвращаться непредсказуемые подмножества строк. Вы можете запросить строки с десятой по двадцатую, но какой порядок вы имеете в виду? Порядок будет неизвестен, если не добавить ORDER BY.

> Оператор LIMIT реализован не во всех СУБД, например, в MSSQL для вывода записей с начала таблицы используется оператор TOP, а для тех случаев, когда необходимо сделать отступ от начала таблицы, предназначена конструкция OFFSET FETCH.

В дополнение к LIMIT можно пропустить определенное количество строк из результата запроса. Для этого после предложения LIMIT нужно написать OFFSET и сколько строк пропустить.

```sql
SELECT store_id, name
FROM store
ORDER BY name
LIMIT 3
OFFSET 3
```

### 2.17 WITH

**Обобщённое табличное выражение или CTE (Common Table Expressions)** - это временный результирующий набор данных, к которому можно обращаться в последующих запросах. Для написания обобщённого табличного выражения используется оператор WITH.

Обобщённые табличные выражения были добавлены в SQL для упрощения сложных длинных запросов, особенно с множественными подзапросами. Их главная задача – улучшение читабельности, простоты написания запросов и их дальнейшей поддержки. Это происходит за счёт сокрытия больших и сложных запросов в созданные именованные выражения, которые потом используются в основном запросе.

Выражение с WITH считается временным, потому что результат не сохраняется где-либо на постоянной основе в схеме БД, а действует как временное представление, которое существует только на время выполнения запроса, то есть оно доступно только во время выполнения операторов SELECT, INSERT, UPDATE, DELETE или MERGE. Оно действительно только в том запросе, которому он принадлежит, что позволяет улучшить структуру запроса, не загрязняя глобальное пространство имён.

```sql
WITH Aeroflot_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot"),
    Don_avia_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Don_avia")

SELECT plane, COUNT(plane) AS amount
FROM Aeroflot_trips
GROUP BY plane;
```
- Создаём табличное выражение Aeroflot_trips, содержащие все полёты, совершенные авиакомпанией Aeroflot. Аналогично, создаём табличное выражение Aeroflot_trips, но с переименованными колонками. С помощью оператора WITH определяем несколько табличных выражений.

### 2.18 UNION

```sql
SELECT поля_таблиц FROM список_таблиц ...
UNION [ALL]
SELECT поля_таблиц FROM список_таблиц ... ;
```
- Общая структура запроса с оператором UNION.

## 3 Группы SQL операторов

### 3.1 DDL

DDL (Data Definition Language) - операторы определения данных. Они работают с объектами, то есть с целыми таблицами. Если базу нужно дополнить таблицей с новыми данными или, наоборот, убрать одну из таблиц с ошибочными данными - используется этот набор операторов.

- `CREATE` - создание объекта в базе данных
- `ALTER` - изменение объекта
- `DROP` - удаление объекта

### 3.2 DML

DML (Data Manipulation Language) - операторы манипуляции данными. Эти операторы уже работают с содержимым таблиц - строками, атрибутами и значениями. С их помощью можно вносить изменения в конкретное значение. Например, заменить поле в колонке «Фамилия» в строке с данными сотрудницы компании посте того, как она вышла замуж. Или удалить строку с данными уволенного сотрудника.

- `SELECT` - выбор данных в соответствии с условием
- `INSERT` - добавление новых данных
- `UPDATE` - изменение существующих данных
- `DELETE` - удаление данных

### 3.3 DCL

DCL (Data Control Language) - оператор определения доступа к данным. Он определяет, кто из пользователей может отправлять запросы к базе, менять объекты и значения. Например, можно отозвать доступ у сотрудника, перешедшего в другой отдел, а также открыть доступ к базе новому маркетологу или разработчику.

- `GRANT` - предоставление доступа к объекту
- `REVOKE` - отзыв ранее выданного разрешения
- `DENY` - запрет, который является приоритетным над разрешением

### 3.4 TCL

TCL (Transaction Control Language) - язык управления транзакциями. Транзакции - это набор команд, которые выполняются поочередно. Если все команды выполнены, транзакция считается успешной, а если где-то произошла ошибка — транзакция откатывается назад, отменяя все выполненные команды. Наглядный пример такой транзакции - оплата онлайн, когда банк просит сначала ввести сумму и получателя, затем проверить и подтвердить операцию, а после ввести одноразовый код. На каждом из этих этапов оплату можно отменить и транзакция откатится назад.

- `BEGIN TRANSACTION` - обозначение начала транзакции
- `COMMIT TRANSACTION` - изменение команд внутри транзакции
- `ROLLBACK TRANSACTION` - откат транзакции
- `SAVE TRANSACTION` - указание промежуточной точки сохранения внутри транзакции

## 4 Базовый синтаксис SQL запроса

```sql
 SELECT список_полей
   FROM список_таблиц
  WHERE ограничения_на_список_строк
  GROUP BY условия_группировки
 HAVING ограничения_на_строки_после_группировки
  ORDER BY порядок_сортировки
  LIMIT ограничение_количества_записей
```

Чтобы разобраться, как именно работает магия запроса, давайте представим его путь от пользователя до нужных ему данных:

Пользователь → Клиент → Запрос → Система управления → База данных → Таблица с базами данных

- Клиент - способ введения запроса. В случае с Google, например, клиентом будет поисковая строка браузера, в которую пользователь вводит сформулированный запрос
- Система управления базами данных (СУБД) - комплекс программ, которые позволяют управлять данными. Эта система помогает таблицам понять, чего хочет пользователь, а пользователю - что ему отвечают таблицы
- База данных - система хранения таблиц, в которой они связаны между собой. База данных сама по себе не умеет манипулировать информацией - это просто хранилище, где у каждого объекта есть свое место

## Литералы

Литерал - это указанное явным образом фиксированное значение, например, число 12 или строка "SQL".

### Строковые литералы

Строка - это последовательность символов, заключённых в одинарные (') или двойные (") кавычки. Например, 'это строка' и "это строка".

```sql
SELECT "Строка \n Другая строка" as String
```

### Числовые литералы

- `1`
- `2.1`
- `0.01`
- `.2`
- `+1`
- `-1`
- `1e3`, `1000`
- `%`, `MOD`
- `*`
- `+`
- `-`
- `/`
- `DIV`

```sql
SELECT (5 * 2 - 6) AS Result;
```
- Используя эти операторы можно построить любое арифметическое выражение, применяя стандартные правила арифметики.

### Литералы даты и времени

- `YYYY-MM-DD`, `YYYYMMDD` (дата со временем, равным нулю)
- `hh:mm:ss`, `hh:mm`, `hh`, `ss` (время без конкретной даты)
- `YYYY-MM-DD hh:mm:ss`, `YYYYMMDDhhmmss` (дата и время)

Значения даты и времени могут быть представлены в формате строки или числа.

Например, если мы хотим указать какую-то дату в запросе, то мы можем это сделать с помощью строки "2000-12-30", "20001230" или же числа 20001230. В обоих случаях эти значения будут интерпретироваться как дата «30 декабря 2000 года».

```sql
SELECT * FROM user WHERE birthday > '2000-12-30'
```

### Логические литералы

Логический литерал - это значения TRUE и FALSE, означающие истинность и ошибочность какого-либо утверждения. При интерпретации запроса TRUE и FALSE становятся 1 и 0 соответственно.

### NULL

Значение NULL означает "нет данных", "нет значения". Оно нужно, чтобы отличать визуально пустые значения, такие как строка нулевой длины или "пробел", от того, когда значения вообще нет, даже пустого.

## Встроенные функции

- [Встроенные функции Postgres](https://postgrespro.ru/docs/postgresql/16)

Встроенная функция - это реализованный в СУБД код, с помощью которого можно выполнять преобразования строковых, числовых и других данных в запросах.

Каждая функция принимает набор аргументов определённого типа, выполняет заложенные в неё операции и обязательно возвращает один из возможных литералов.

Например, функция NOW() принимает ноль аргументов и возвращает литерал в формате даты, а LENGTH('sql-academy') принимает один строковый аргумент и возвращает числовой литерал «11».

Функции можно применять не только над литералами, но и над значениями, взятыми из таблицы. При этом функция выполняет преобразования для каждой строки отдельно.

```sql
SELECT UPPER("Hello world") AS upper_string;
```

## Конкатенация строк

Часто в запросах приходится объединять несколько значений в одно текстовое значение (конкатенация). Например, может потребоваться получить строку следующего формата: 'текущее время: 2020-02-19 15:28:44.049702+07'. Для выполнения конкатенации строк необходимо воспользоваться оператором `||`:

```sql
SELECT 'текущее время: ' || now() as time

SELECT concat('текущее время: ', now()) as time
```
- Аналогичные записи

## Агрегатная функция

Агрегатная функция - это функция, которая выполняет вычисление на наборе значений и возвращает одиночное значение.

Агрегатные функции применяются для значений, не равных NULL. Исключением является функция COUNT(`*`).

**Описание агрегатных функций**

|Функция|Описание|
|:--|:--|
|SUM(поле_таблицы)|Возвращает сумму значений|
|AVG(поле_таблицы)|Возвращает среднее значение|
|COUNT(поле_таблицы)|Возвращает количество записей|
|MIN(поле_таблицы)|Возвращает минимальное значение|
|MAX(поле_таблицы)|Возвращает максимальное значение|

```sql
SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type
```
- Запрос с использованием агрегатной функции AVG

## Подзапросы

Подзапрос - это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключён в круглые скобки и обычно выполняется перед основным запросом.

```sql
SELECT * FROM Reservations
WHERE Reservations.room_id = (
	SELECT id FROM Rooms ORDER BY price DESC LIMIT 1
)
```
- Получим список всех бронирований самого дорогого на данный момент жилого помещения. В данном случае запрос на получение самого дорогого жилого помещения выполняется в качестве подзапроса, а затем результат результирующего набора применяется в основном запросе.

### Подзапрос с одной строкой с одним столбцом

Данный тип подзапросов также известен как скалярный подзапрос.

Он может использоваться в различных частях основного SQL запроса, но чаще всего он используется в условиях ограничений выборки с помощью операторов сравнения (=, <>, >, <).

```sql
SELECT * FROM FamilyMembers
WHERE birthday = (SELECT MAX(birthday) FROM FamilyMembers);
```
- С помощью данного запроса возможно получить самого младшего члена семьи. Подзапрос в данном случае необходим для получения максимальной даты рождения, которая затем используется в основном запросе для фильтрации строк.

При использовании результата подзапроса с операторами сравнения, важно, чтобы подзапрос возвращал именно скалярное значение (1 строка и 1 колонка).

### Подзапросы с несколькими строками и одним столбцом

Если подзапрос возвращает более одной строки, его нельзя просто использовать с операторами сравнения. Однако c подзапросами, возвращающими несколько строк и один столбец, можно использовать 3 дополнительных оператора.

```sql
SELECT 200 > ALL(SELECT price FROM Rooms)
```
- С помощью оператора ALL мы можем сравнивать отдельное значение с каждым значением в наборе, полученным подзапросом. При этом данное условие вернёт TRUE, только если все сравнения отдельного значения со значениями в наборе вернут TRUE.
- Этот запрос проверяет для всех ли жилых помещений выполняется условие, что оно дешевле чем 200.

```sql
SELECT * FROM Users WHERE id IN (
SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```
- Оператор IN проверяет входит ли конкретное значение в набор значений. В качестве такого набора как раз может использоваться подзапрос, возвращающий несколько строк с одним столбцом.
- Например, получим всю информацию о владельцах жилья стоимостью больше 150 условных единиц.

```sql
SELECT * FROM Users WHERE id = ANY (
SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```
- Условное выражение с ANY имеет схожее поведение, но оно возвращает TRUE, если хотя бы одно сравнение отдельного значения со значением в наборе вернёт TRUE.
- Найдём пользователей, которые владеют хотя бы 1 жилым помещением стоимостью более 150.

### Многостолбцовые подзапросы

SQL поддерживает сравнение не только по одной колонке, но позволяет попарно сравнивать значения в основном запросе со значениями в подзапросе.

```sql
SELECT * FROM Reservations
WHERE (room_id, price) IN (SELECT id, price FROM Rooms);
```
- Например, можем получить информацию о всех бронированиях, в которых цена жилья на момент брони (Reservations.price) соответствует текущей стоимостью жилья (Rooms.price). В данном примере, подзапрос возвращает таблицу с идентификаторами жилых помещений и их текущей ценой

### Коррелированные подзапросы

Все предыдущие рассматриваемые подзапросы были некоррелированные (независимые). Они могли выполняться автономно от основного запроса и мы могли посмотреть, что они возвращают перед тем, как их результат будет использоваться в основном запросе. Коррелированные же подзапросы ссылаются на один или несколько столбцов основного запроса.

```sql
SELECT FamilyMembers.member_name, (
    SELECT SUM(Payments.unit_price * Payments.amount)
    FROM Payments
    WHERE Payments.family_member = FamilyMembers.member_id
) AS total_spent
FROM FamilyMembers;
```
- В данном случае, коррелированный подзапрос ссылается к столбцу member_id из основного запроса.
- Коррелированный подзапрос отличается от некоррелированного подзапроса тем, что он выполняется не один раз перед выполнением запроса, в который он вложен, а для каждой строки, которая может быть включена в окончательный результат.
- Например, основной запрос к таблице FamilyMembers возвращает 8 записей, то для каждой из них выполняется коррелированный подзапрос.

> Использование коррелированных подзапросов может вызвать проблемы с производительностью, особенно если содержащий запрос возвращает много строк, так как коррелированный подзапрос будет выполняться для каждой строки содержащего запроса отдельно.