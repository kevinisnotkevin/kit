- https://theswissbay.ch/pdf/Books/Computer%20science/prometheus_upandrunning.pdf

# Prometheus

**Prometheus** - это набор инструментов для мониторинга и алертинга с открытым исходным кодом, который собирает метрики в виде временных рядов с помощью http эндпоинтов на целевых узлах.

**Метрики** - это числовые измерения, которые помогают отслеживать состояние приложения. Примеры измерений: время обработки запроса, кол-во активных соединений или запросов.

**Временные ряды** - это записи изменений метрик с течением времени, которые показывают, как метрика меняется каждый промежуток времени.

- Используется многомерная модель данных, где временные ряды идентифицируются по имени метрики и набором пар ключ-значение.
- Используется язык запросов PromLQ для анализа временных рядов. Позволяет строить сложные запросы, выполнять математические операции и агрегировать данные.
- Каждый сервер prometheus автономен и не зависит от распределенного хранилища. Это значит, что не нужно настраивать сложные инфраструктурные зависимости и сервер остается доступным, даже если другие части инфраструктуры не работают.
- Данные собираются через модель pull. Сервер отправляет http запросы целевым узлам (экспортерам) и получает от них данные о метриках.
- Поддерживается push модель. Для этого используется gateway, на который приложения отправляют метрики, которые prometheus затем извлекает.
- Поддерживается автоматическое обнаружение целевых систем или с помощью статических конфигураций.
- Prometheus предоставляет свой эндпоинт, который позволяет скрейпить и отслеживать самого себя.
- Можно создавать правила для создания уведомлений при достижении определенных условий, например, если метрика превышает заданный порог.

**Samples** - это данные, составляющие временные ряды. Каждый сэмпл включает значение типа float64 (Кол-во запросов, температура, использование процессора и др) и timestamp (Время фиксации сэмпла).

```lua
http_requests_total{method="GET", status="200"} 100 1638765551000
```
- Метрика, отслеживающая кол-во http запросов.
- `100`: значение.
- `1638765551000`: Таймстамп в миллисекундах.
- `{method="GET", status="200"}`: Лейблы метрики.

## Storage

Prometheus включает локальную tsdb на диске, но также может интегрироваться с удаленными системами хранения. Используется эффективный формат хранения данных.

Образуются блоки данных каждые два часа. Каждый блок хранится в отдельной директории и содержит:

- `chunks`: Подкаталог, содержащий сегменты данных временных рядов.
- `index`: Индекс метрик и лейблов, сопоставленных временным рядам.
- `meta.json`: Метаданные блока.
- `tombstones`: Файлы, помеченные для удаления данных. При удалении серий через API записи об удалении сохраняются тут.

По умолчанию сегменты в `chunks` группируются в файлы по 512 мб.

WAL хранит необработанные данные, которые еще не скомпактированы в блоки. Хранится в директории `wal` и состоит из сегментов по 128 мб. Минимум 3 файла WAL сохраняются на диске. Если трафик высокий, может храниться больше для обеспечения 2 часов необработанных данных.

Блок для поступающих данных хранится в оперативной памяти и не полностью записывается на диск до завершения 2-часового периода. Данные в памяти защищены за счёт WAL.

- Локальное хранилище не масштабируется автоматически и не защищено от сбоев дисков или узлов.
- Требует тщательного управления, как и другие БД, не поддерживающие кластеризацию.
- Рекомендуется использовать снапшоты.
- Резервное копирование без снапшотов может потерять данные, записанные с последней синхронизации WAL (обычно каждые 2 часа).
- Правильно настроенное локальное хранилище может хранить данные годами.
- Для больших объемов данных или масштабируемости лучше использовать внешнее хранилище.

Prometheus поддерживает интеграцию с внешними хранилищами через remote read/write API.

**Варианты интеграции с удаленным хранилищем**

- **Удаленная запись (Remote Write):** Prometheus отправляет собранные выборки в удаленное хранилище через URL. Формат передачи данных: протокол буферов с компрессией (Snappy) через HTTP.
- **Получение данных от клиентов (Remote Write):** Prometheus может принимать выборки от других систем (например, агентов, собирающих метрики) через интерфейс удаленной записи.
- **Удаленное чтение (Remote Read):** Prometheus может читать данные из удаленного хранилища. Использует тот же формат передачи данных (протокол буферов с компрессией через HTTP). Оценка выражений PromQL выполняется локально в Prometheus, что ограничивает масштабируемость.
- **Предоставление данных клиентам (Remote Read):** Prometheus может обслуживать запросы клиентов, предоставляя данные в формате Remote Read.

Оба протокола удаленного чтения и записи используют мгновенное сжатие буфера протокола через HTTP.

## Metrics

Все данные хранятся как временные ряды, то есть каждое значение метрики связано с определенным временным штампом и принадлежит конкретному лейблу или набору лейблов.

- Имя метрики может содержать ASCII символы, цифры, подчеркивания.
- Имя метрики должно иметь префикс приложения (Например, `docker_`, `protmetheus_`).
- Метрика должна иметь единую единицу измерения.
- Метрика должна использовать базовые единицы (Например, секунда, байт).
- Метрика должна иметь суффикс, описывающий единицу измерения во множественном числе (Например, `_seconds`, `_bytes`).

Например, метрика может быть измерена для конкретного сервера, в определенный момент времени с определенным значением.

В дополнение к основным временным рядам, можно генерировать временные ряды при выполнении запросов. Например можно агрегировать данные, вычислять среднее или фильтровать, создавая новые временные ряды с новыми лейблами или агрегированными значениями на время выполнения запроса. А также можно строить прогнозы (например, по модели Хольта-Уинтерса).

Клиентские библиотеки предоставляют 4 типа метрик. Эти типы метрик различаются только на уровне клиентских библиотек и сетевого протокола, а сервер prometheus все метрики обрабатывает и хранит как неструктурированные (untyped) временные ряды.

**Counter (Счетчик)** - это метрика, которая может увеличиваться и сбрасываться до нуля. Применяется для измерения событий, которые могут только накапливаться, например, количество запросов к серверу или число ошибок.

**Gauge (Измеритель)** - это метрика, которая может уменьшаться и увеличиваться. Применяется для отслеживания текущего состояния системы, например, нагрузка процессора, использование памяти или кол-во одновременных запросов.

**Histogram (Гистограмма)** - это метрика, которая рассчитывает средние значения и относительные измерения значений по заданным критериям. Применяется для измерения время обработки запросов, размера запросов.

**Summary (Сводка)** - это метрика, которая расширяет гистограмму. Измеряет сумму и кол-во измерений, а также квантили за скользящий период. Она хранит информацию о количественных характеристиках значений, например общее кол-во и сумма. Применяется для измерения времени ответа api с перцентилями или времени выполнения запроса.

Квантили - это деление плотности вероятности на отрезки равной вероятности.

## Labels

**Лейблы (labels)** позволяют использовать многомерную модель данных, где каждая комбинация лейбла и его значения создает отдельный временной ряд, что дает возможность фильтровать и агрегировать данные по различным критериям.

Например, метрика `http_requests_total` отслеживает количество запросов и может иметь временные ряды, помеченные такими лейблами, как `status="200"`, `method="GET"`, `path="/home"`.

```lua
http_requests_total{method="POST", path="/home", status="200"} 100
http_requests_total{method="GET", path="/api", status="200"} 200
```
- Два разных временных ряда для одного и того же измерения `http_requests_total`, но с разными метками.
- Если изменяется значение какого-либо лейбла или добавляется/удаляется лейбл, то создается новый временной ряд.

- Имена лейблов могут содержать ASCII символы, цифры, подчеркивания. 
- Значения лейблов могут содержать любые символы unicode. 
- Лейблы, начинающиеся с двойного подчеркивания, зарезервированы и не могут быть использованы.
- Лейблы, имеющие пустое значение, считаются несуществующими.
- Не рекомендуется помещать имена лейблов в имя метрики, так как это может вызвать путаницу.
- Каждая уникальная комбинация пар лейблов представляет собой новый временной ряд, который может значительно увеличить обьем хранимых данных. Поэтому не рекомендуется использовать лейблы, которые могут иметь неограниченные наборы значений (Например, логин, почта).

## Jobs

**Instance** - это эндпоинт, с которого сервер собирает метрики. Обычно соответствует одному процессу или экземпляру приложения.

**Job** - это группа instance, которые выполняют одну и ту же функцию. Используется для обьединения instance с одинаковой целью.

Цели можно настроить статически с помощью `static_configs` или обнаружить динамически с помощью одного из механизмов обнаружения служб.

```yml
scrape_configs:
  - job_name: 'web_servers'
    scrape_interval: 15s
    static_configs:
      - targets: ['192.168.10.10:8000', '192.168.10.11:8000']
```
- Конфигурация задания с двумя экземплярами.

При скрепинге целей, автоматически добавляются лейблы, которые идентифицируют цель:

- `job`: Имя задания, которой принадлежит цель.
- `instance`: host:port цели.

Для каждого instance, с которых происходит сбор метрик, хранятся метрики для мониторинга процесса сбора данных:

- `up{job="job_name", instance="instance_id"}`: Метрика определяет доступность инстанса для сбора данных.
- `scrape_duration_seconds{job="job_name", instance="instance_id"}`: Метрика определяет время, затраченное на сбор метрик с данного инстанса.
- `scrape_samples_post_metric_relabeling{job="job_name", instance="instance_id"}`: Метрика определяет кол-во сэмплов метрик.
- `scrape_samples_scraped{job="job_name", instance="instance_id"}`: Метрика определяет кол-во метрик, которые были извлечены из инстанса.
- `scrape_series_added{job="job_name", instance="instance_id"}`: Метрика определяет приблизительное кол-во новых временных рядов, которые были добавлены во время данного сбора метрик.

## Rules

Prometheus позволяет настраивать правила для вычислений (Recording Rules) и оповещений (Alerting Rules) в yml файлах. Сигнал `SIGHUP` позволяет применить изменения в правилах.

**Recording rules** - это правила, которые используются для вычисления и сохранения метрик в новых временных рядах. Это позволяет заранее вычислять часто используемые выражения и сохранять их результаты в виде новых временных рядов. Дашборды, использующие такие записи, будут работать быстрее, так как не нужно пересчитывать сложные выражения при каждом обновлении.

**Alerting rules** - это правила, которые используются для определения условий оповещения на основе выражений PromQL. Эти правила могут отправлять уведомления о срабатывании оповещений во внешние сервисы, такие как Alertmanager.

```bash
promtool check rules /path/example.rules.yml
```
- Проверка файл с правилами на синтаксическую корректность без перезапуска prometheus.

```yml
groups:
  - name: example
    interval: global.evaluation_interval  # (default)
    limit: 0  # (default)
    query_offset: global.rule_query_offset  # (default)
    labels:
      label_name: "label_value"
    rules:
      - record: code:prometheus_http_requests_total:total
        expr: sum by (code) (prometheus_http_requests_total)
        labels:
          label_name: "label_value"
      - alert: HighRequestLatency
        expr: avg(rate(http_requests_total[5m])) by (job) > 0.5
        for: 0s  # (default)
        keep_firing_for: 0s  # (default)
        labels:
        annotations:
          ann_name: "ann_value"
```
- `groups`: Группирует несколько правил.
- `name`: Имя группы, должно быть уникальным в пределах файла.
- `interval`: Интервал оценки правил.
- `limit`: Макс кол-во срабатываний.
- `label`: Дополнительные лейблы для добавления или перезаписи для всех правил внутри группы.
- `rules`: Список правил в группе.
- `record`: Имя метрики (нового временного ряда), в котором будет сохранен результат вычисления.
- `expr`: запрос promql, который будет выполнен.
- `alert`: Имя оповещения.
- `for`: Минимальное время, в течение которого условие должно оставаться истинным для срабатывания оповещения. Это предотвращает активацию оповещений из-за кратковременных пиков или временных изменений метрик. Например, можно настроить правило, которое будет активировано, только в том случае, если использование памяти остается выше 90% в течение 10 минут.
- `keep_firing_for`: Как долго оповещение будет срабатывать, даже если условие стало ложным. Это предотвращает частое включение/выключение оповещений, ложные срабатывания из-за временной потери данных. Если установлено значение 0, то оповещение сразу будет деактивировано, как только условие перестанет быть истинным.
- `annotations`: Аннотации описывают доп. данные оповещения. Поддерживают шаблоны.

```yml
groups:
  - name: group_name
    rules:
      - alert:
        expr: up == 0
        for: 5m
        labels:
          severity: page
        annotations:
          summary: "Instance {{ $labels.instance }} down"
          description: "{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes."
```
- Значения лейблов и аннотаций можно задавать с помощью шаблонов.
- `$labels`: Лейблы метрики, вызвавшей оповещение.
- `$value`: Значение метрики.
- `$externalLabels`: Лейблы глобальной конфигурации.

Оповещения можно увидеть в разделе `alerts` в prometheus.

## Components

- **Prometheus server**: Компонент, который собирает (scrapes) метрики с целевых узлов и хранит временные ряды данных.
- **Client lib**: Компонент, который интерируется в приложение для отслеживания и сбора данных, передачи метрик prometheus. Это называется инструментирование.
- **Push gateway**: Компонент, который используется для отправки метрик prometheus от быстрых процессов (short-lived jobs), которым не подходит scrape модель.
- **Exporter**: Компонент, который собирает данные с целевых систем и преобразует их в формат prometheus.
- **Alertmanager**: Компонент, который принимает и обрабатывает уведомления на основе правил от prometheus, а затем отправляетв сторонние системы.

### 1 Prometheus server

Конфигурация prometheus может происходить с помощью флагов `prometheus -h` и файла конфигурации `prometheus.yml`. Флаги настраивают неизменяемые системные параметры (место хранения, обьем хранимых данных на диске и др). Файл конфигурации определяет все, что связано со сбором метрик и их инстансами, а также правила.

Prometheus может перезагрузить свою конфигурацию во время работы с помощью сигнала sighup процессу prometheus или с помощью отправки post запроса к эндпоинту `/-/reload` (Если включен флаг `--web.enable-lifecycle`). Если новая конфигурация содержит ошибки, то изменения не будут применены.

#### Flags

```yml
# Путь, где Prometheus хранит свою базу данных.
"--storage.tsdb.path=data/"  # (default)

# Максимальный срок хранения данных.
"--storage.tsdb.retention.time=15d"  # (default)

# Ограничение на максимальный объем блоков хранения в байтах.
# Только постоянные блоки (persistent blocks) удаляются для соблюдения ограничения. WAL и сегменты `chunks_head` учитываются в общем объеме, но не удаляются.
"--storage.tsdb.retention.size=0"

# Включает сжатие WAL, что может снизить его объем примерно вдвое с минимальной нагрузкой на процессор.
"--storage.tsdb.wal-compression"
```
- Флаги конфигурации хранилища.

#### global

```yml
global:
  scrape_interval: 1m  # (default)
  evaluation_interval: 1m  # (default)
  scrape_timeout: 10s  # (default)
  scrape_protocols:  # (default)
    - OpenMetricsText1.0.0
    - OpenMetricsText0.0.1
    - PrometheusText0.0.4
  external_labels:
    label_name: "label_value"
  rule_query_offset: 0s  # (default)
  query_log_file: file
  scrape_failure_log_file: file
  body_size_limit: 0  # (default)
  sample_limit: 0  # (default)
  label_limit: 0  # (default)
  label_name_length_limit: 0  # (default)
  label_value_length_limit: 0  # (default)
  target_limit: 0  # (default)
  keep_dropped_targets: 0  # (default)
  metric_name_validation_scheme: "utf8"  # (default)
```
- `global`: Определяет параметры, которые действительны во всех других контекстах конфигурации и служат значениями по умолчанию.
- `scrape_interval`: Параметр определяет интервал сбора метрик.
- `evaluation_interval`: Параметр определяет частоту выполнения правил.
- `scrape_timeout`: Параметр определяет тайм-аут ожидания запроса от цели во время сбора метрик.
- `scrape_protocols`: Параметр определяет протоколы, которые используются для взаимодействия с целями.
- `external_labels`: Параметр позволяет добавить лейблы ко всех лейблам. Используется для идентификации источника данных при нескольких prometheus серверах.
- `rule_query_offset`: Параметр определяет сдвиг для времени, на которое будет сдвигаться временной интервал для выполнения запроса. Например, если указать `1h`, то запрос будет выполняться на 1 час назад от текущего времени.
- `query_log_file`: Параметр определяет путь к файлу, в который записываются promql запросы.
- `scrape_failure_log_file`: Параметр определяет путь к файлу, в который записываются неудачные попытки сбора метрик.
- `body_size_limit`: Параметр определяет максимальный размер тела в байтах http запроса, который приходит через http api (Например другой сервер отправляет метрики через remote_write). 
- `sample_limit`: Параметр определяет лимит метрик за один запрос.
- `label_limit`: Параметр определяет ограничение кол-ва лейблов для сэмпла.
- `label_name_length_limit`: Параметр определяет макс длину имени метки.
- `label_value_length_limit`: Параметр определяет макс длину значения метки.
- `target_limit`: Параметр определяет лимит уникальных целей сбора метрик.
- `keep_dropped_targets`: Параметр определяет кол-во целей, которые исключены через relabeling и будут сохранены в памяти.
- `metric_name_validation_scheme`: Параметр определяет схему валидации имен метрик и лейблов. `legacy` разрешает буквы, цифры, двоеточия и подчеркивания. `utf8` разрешает все utf8 символы.

#### scrape_configs

```yml
scrape_configs:
  - job_name: "prometheus"
    scrape_interval: global_config.scrape_interval  # (default)
    scrape_timeout: global_config.scrape_timeout  # (default)
    scrape_protocols: global_config.scrape_protocols  # (default)
    metrics_path: "/metrics"  # (default)
    honor_labels: false  # (default)
    honor_timestamps: true  # (default)
    scheme: http  # (default)
    enable_compression: true  # (default)
    static_configs:
      - targets:
          - "localhost:9090"
        labels:
          label_name: label_value
    sample_limit: 0  # (default)
    params:
      metric_type: ["histogram"]  # ?metric_type=histogram
    scrape_failure_log_file: "/scrape_failures.log"
    body_size_limit: 0  # (default)
    label_limit: 0  # (default)
    label_name_length_limit: 0  # (default)
    label_value_length_limit: 0  # (default)
    target_limit: 0  # (default)
    metric_name_validation_scheme: "utf8"  # (default)
    metric_relabel_configs:
```
- `scrape_configs`: Параметр определяет список целей и параметров для сбора данных из них. Целевые обьекты можно настроить статически или обнаружить динамически.
- `job_name`: Параметр определяет уникальное имя задания для идентификации набора метрик.
- `metrics_path`: Параметр определяет путь для сбора метрик.
- `honor_labels`: Параметр определяет, следует ли сохранять лейблы из исходных метрик цели или заменять их серверными в случае, если лейблы уже существуют.
- `honor_timestamps`: Параметр определяет, использовать ли временные лейблы из метрик цели.
- `scheme`: Параметр определяет протокол, используемый для запросов.
- `enable_compression`: Параметр определяет, сжимать ли запросы.
- `static_configs`: Параметр определяет статический список целей для сбора метрик. `targets` содержит список целей, `labels` содержит лейбы, присваемые всем метрикам цели.
- `params`: Параметр позволяет добавить параметры url запроса при сборе метрик.
- `metric_relabel_configs`: Параметр имеет тот же формат, что и `relabel_configs`, применяется к метрикам после их получения от цели, но перед записью в бд. Может применяться для исключения временных рядов, которые слишком дороги для обработки.

##### relabel_configs

Каждая цель начинается с предварительно заданного набора лейблов.Перед завершением relabeling удаляются все лейблы, начинающиеся с `__`.

Начальный набор лейблов:

- `job`: Лейбл содержит значение `scrape_config.job_name`.
- `__address__`: Лейбл содержит адрес цели (`host:port`), заданный в `scrape_config`.
- `__scheme__`: Лейбл содержит значение `scrape_config.scheme`.
- `__metrics_path__`: Лейбл содержит значение `scrape_config.metrics_path`. 
- `__param_<name>`: Лейбл содержит параметры url из `scrape_config.params`.
- `__scrape_interval__`: Лейбл содержит значение `scrape_config.scrape_interval`.
- `__scrape_timeout__`: Лейбл содержит значение `scrape_config.scrape_timeout`.
- `__meta_...`: Лейблы, предоставленные service discovery (Например docker).

```yml
scrape_config:
  - job_name: "job_name"
    relabel_configs:
      - source_labels:
          - "__address__"
        separator: ";"  # (default)
        target_label: "instance"
        regex: "(.*)"  # (default)
        replacement: "$1"  # (default)
        action: "replace"  # (default)
```
- `relabel_configs`: Параметр позволяет динамически изменять лейблы для каждой цели перед тем, как метрики будут собраны. Лейблы, добавленные во время relabeling, доступны для следующих шагов обработки.
- `source_labels`: Параметр определяет из каких лейблов брать значения для обработки. Если указано несколько лейблов, то их значения конкатенируются с помощью разделителя `separator`.
- `separator`: Параметр определяет символ, который будет использоваться для соединения значений из `source_labels`.
- `target_label`: Параметр определяет имя лейбла, в который будет записано обработанное значение.
- `regex`: Параметр определяет регулярное выражение для сопоставления значений из `source_labels`. Если есть совпадение, то действие выполняется, иначе игнорируется.
- `replacement`: Параметр определяет значение, которое заменит совпадение с регулярным выражением. `$1` - первая группа из регулярного выражения.
- `action`: Параметр определяет действие, которое будет выполнено.
	- `replace`: Заменить значение лейбла или добавить новый.
	- `keep`: Сохранить цель.
	- `drop`: Удалить цель.
	- `hashmod`: Хешировать значение.
	- `labelmap`: Преобразовать ключи лейблов.
	- `labeldrop`: Удалить лейбл.
	- `labeldrop`: Сохранить только лейблы, которые совпадают.

**ПРИМЕРЫ**

```yml
relabel_configs:
  - source_labels:
      - "__meta_docker_container_name"
    regex: "web-.*"
    targer_label: job
    replacement: "web_application"
    action: replace
```
- Пример с заменой значения лейбла. Если имя контейнера начинается с `web-`, то в лейбл `job` будет записано `web_application`.
```yml
relabel_configs:
  - source_labels:
      - "__meta_docker_network_name"
    regex: "frontend_net"
    action: keep
```
- Пример с фильтрацией целей. Оставить только те цели, которые подключены к сети `frontend_net`.
```yml
relabel_configs:
  - regex: "__meta_docker_.*"
    action: labeldrop
```
- Пример с удалением ненужных лейблов. Удалить все лейблы, которые начинаются с `__meta_docker_`.
```yml
relabel_configs:
  - regex: "meta_(.*)"
    action: labelmap
```
- Пример с изменением лейблов. Убрать у лейблов с префиксом `meta_` их префикс.

##### http_config

```yml
scrape_configs:
  - job_name: "job_name"
    http_config:
      basic_auth:
      authorization:
      oauth2:
      tls_config:
      proxy_url:
      headers:
      follow_redirects: true  # (default)
      enable_http2: true  # (default)
```
- `http_config`: Параметр определяет настройки параметров http запросов, которые используются при сборе метрик.
- `basic_auth`: Параметр определяет базовую аутентификацию.
- `authorization`: Параметр определяет токен авторизации.
- `oauth2`: Параметр определяет oauth2 авторизацию. Prometheus автоматически получает и обновляет токены.
- `tls_config`: Параметр определяет tls/ssl для подключения.
- `proxy_url`: Параметр определяет прокси-сервер, через который будут отправляться http запросы.
- `headers`: Параметр позволяет добавить http заголовки в запросы.
- `follow_redirects`: Параметр определяет, следовать ли http редиректам (3xx).
- `enable_http2`: Параметр включает http2.

#### docker_sd_configs

```yml
scrape_configs:
  - job_name: "job_name"
    docker_sd_configs:
      - host: "unix:///var/run/docker.sock"
        port: 80  # (default)
        host_networking_host: "localhost"  # (default)
        match_first_network: true  # (default)
        refresh_interval: 60s  # (default)
        http_config:
        filters:
          - name: "label"
            values:
              - "prometheus.enabled=true"
          - name: "status"
            values:
              - "running"
```
- `docker_sd_configs`: Параметр позволяет настроить автоматическое обнаружение целей в docker контейнерах. Prometheus подключается к docker api, получает список запущенных контейнеров, фильтрует их на основе конфигурации и собирает из них метрики.
- `host`: Параметр определяет адрес docker демона, который будет давать информацию о контейнерах.
- `port`: Параметр определяет порт, с которого будут собираться метрики. Для контейнеров, у которых нет открытых портов.
- `host_networking_host`: Параметр определяет имя хоста для контейнеров в режиме host networking.
- `match_first_network`: Параметр указывает выбрать первую сеть в алфовитном порядке, если контейнер подключен к нескольким сетям. Иначе контейнер будет добавлен несколько раз.
- `filters`: Параметр содержит список фильтров, которые определяют, какие контейнеры учитывать.
- `refresh_interval`: Параметр определяет интервал обновления списка контейнеров.
- `http_config`: Параметр содержит настройки http для подключения к docker api.

#### alerting

Оповещения определяются в файле конфигурации и задают набор правил для метрик. Если во временных рядах возникает соответствие правилу, оповещение инициируется и отправляется заданным получателям.

```yml
alerting:
  alert_relabel_configs:
  alertmanagers:
    timeout: 10s  # (default)
    api_version: v2  # (default)
    path_prefix: "/"  # (default)
    scheme: http  # (default)
    http_config:
    docker_sd_configs:
    static_configs:
    relabel_configs:
    alert_relabel_configs:
```
- `alerting`: Параметр определяет, куда отправлять уведомления о срабатывании правил оповещения.
- `alertmanagers`: Параметр определяет список инстансов alertmanager, которым prometheus будет отправлять алерты. Менеджеры оповещений могут быть настроены статически или обнаружены динамически.
- `alert_relabel_configs`: Параметр имеет тот же формат, что и `relabel_configs`, определяет правила для переименования или фильтрации оповещений перед отправкой в alertmanager. Может применяться для фильтрации ненужных алертов, устранения дублирующих алертов между экземплярами prometheus.
- `timeout`: Параметр определяет тайм-аут отправки оповещения менеджеру оповещений.
- `api_version`: Параметр определяет версию апи менеджера.

#### storage

```yml
storage:
  tsdb:
    path: "/prometheus/data"
    retention_time: "15d"
  exemplars:
    max_exemplars: 10000  # (default)
```
- `storage`: Параметр определяет настройки, связанные с хранением метрик и других данных.
- `tsdb`: Параметр определяет настройки хранения временных рядов метрик, управляет файлом на диске.
- `exemplars`: Параметры для управления сохранением и использованием экземпляров (точечных данных), что помогает в отладке и трассировке.

#### other

```yml
rule_files:
  - "rules/general_rules.yml"

runtime:
  gocs: 75  # (default)

scrape_config_files:
  - "scrape_configs/default_scrape.yml"

remote_write:
  - url: "url"
    queue_config:
      max_samples_per_send: 1000
      max_shards: 10
    basic_auth:
      username: "username"
      password: "password"

otlp:
  promote_resource_attributes: [ ]  # (default)
  translation_strategy: "NoUTF8EscapingWithSuffixes"  # (default)

remote_read:
  - url: "url"
    read_recent: true
    basic_auth:
      username: "username"
      password: "password"

tracing:
  endpoint: "url"
  sample_rate: 0.1
```
- `rule_files`: Параметр определяет список файлов с правилами (Alerting rules, Recording rules) для выполнения выражений и создания оповещений.
- `runtime`: Параметр определяет частоту сборки мусора в Go. Уменьшение значения увеличит частоту сборок мусора, что снизит потребление памяти, но увеличит нагрузку на cpu.
- `scrape_config_files`: Параметр определяет список файлов конфигураций для сбора метрик, которые будут добавлены в общий список конфигураций. Это позволяет разделять источники метрик по файлам.
- `remote_write`: Параметр определяет настройки для удаленной записи данных. Это позволяет отправлять собранные метрики на удаленные сервисы для долговременного хранения данных.
- `otlp`: Параметр определяет настройки для работы с OpenTelemetry. 
	- `promote_resource_attributes`: Параметр определяет список атрибутов из ресурса opentelemetry, которые следует сохранять как лейблы в метрики.
	- `translation_strategy`: Параметр определяет стратегию перевода метрик OTLP в формат Prometheus. `UnderscoreEscapingWithSuffixes` заменяет специальные символы на нижнее подчеркивание, `NoUTF8EscapingWithSuffixes` сохраняет символы, поддерживающие UTF-8.
- `remote_read`: Параметр определяет настройки для чтения метрик из удаленного хранилища.
- `tracing`: Параметры для экспорта трассировок, которые могут помочь в отладке производительности. Позволяет отслеживать, как запросы обрабатываются внутри Prometheus, и анализировать время их выполнения.

### 2 Exporters

**Экспортеры** - это инструменты, которые предоставляют данные временных рядов на хостах и сервисах.

Для приложений удобно настраивать метрики с помощью инструментирования. А для известных приложений, серверов и БД существуют экспортеры, с помощью которых можно мониторить целевые обьекты. Экспортеры обычно представлены в виде docker образов и легко настраиваются. Они предоставляют готовый набор метрик и готовые панели мониторинга.

#### Node exporter

```yml
services:
  node_exporter:
    image: quay.io/prometheus/node-exporter:latest
    container_name: node_exporter
    command:
      - '--path.rootfs=/host'
    pid: host
    restart: unless-stopped
    volumes:
      - '/:/host:ro,rslave'
    networks:
      monitoring:

networks:
  monitoring:
    external: true
```
- Пример.

### 3 Alertmanager

Alertmanager обрабатывает оповещения, отправленные клиентскими приложениями, например prometheus. Он занимается дедубликацией, группировкой, маршрутизацией оповещений к нужному получателю, например email, telegram, slack.

**Задачи:**

- **Дедубликация**: Устраняет повторяющиеся оповещения, отправленные по одним и тем же условиям.
- **Группировка (Grouping)**: Обьединяет уведомления по заранее заданным правилам в одно уведомление. Это может быть полезно при массовых сбоях, когда одновременно срабатывает множество оповещений. Например, можно обьединить оповещения с лейблом `instance="db1"` в одно уведомление.
- **Маршрутизация**: Отправляет оповещения на соответствующие интеграции (telegram, email и др). Маршруты настраиваются для указания куда отправлять сообщения (Отправка всех оповещений с `severity="critical"` в telegram, а с `severity="warning"` в email.
- **Подавление (Inhibition)**: Устраняет оповещения, которые зависят от других оповещений (Например, исключить менее критичные оповещения, если вызвано более важное). Это позволяет устанавливать зависимости таким образом, чтобы во время сбоя отправлялись только наиболее важные предупреждения.
- **Тишина (Silencing)**: Позволяет временно подавлять определенные оповещения, чтобы избежать избыточных уведомлений. Например, можно отключить уведомления для кластера `cluster="maintenance"` на два часа для запланированного обслуживания.

Настраивается с помощью флагов `alertmanager -h` и файла конфигурации `alertmanager.yml`. Флаги настраивают неизменяемые параметры системы, файл конфигурации настраивает правила мута, маршрутизацию, и получателей уведомлений. Alertmanager может перезагрузить свою конфигурацию во время выполнения с помощью сигнала `SIGHUP`.

#### Flags

```yml
# Определяет файл конфигурации.
"--config.file=alertmanager.yml"  # (default)
```

#### global

```yml
global:
  # -- Тут могут быть различные параметры для настройки smtp
  # -- Тут могут быть различные параметры для настройки slack
  # -- Тут могут быть различные параметры для настройки victorops
  # -- Тут могут быть различные параметры для настройки opsgenie
  # -- Тут могут быть различные параметры для настройки wechat
  telegram_api_url: "https://api.telegram.org"  # (default)
  http_config:
  resolve_timeout: 5m  # (default)

templates:
  - "/etc/alertmanager/templates/*.tmpl"

route:
  receiver: "receiver"
  group_by:
    - "alertname"
    - "..."  # Отключение агрегации
  continue: false  # (default)
  matchers:
    - alertname = "HighCPUUsage"
    - severity =~ "critical|warning"
  group_wait: 30s  # (default)
  group_interval: 5m  # (default)
  repeat_interval: 4h  # (default)
  mute_time_intervals:
    - "night"
  active_time_intervals:
    - "day"
  routes:
    - receiver: "telegram-dev"
      match:
        severity: "critical"

receivers:
  - name: "receiver"
    telegram_configs:  # На примере тг.
      send_resolved: true  # (default)
      api_url: global.telegram_api_url  # (default)
      bot_token:
      bot_token_file:
      chat_id:
      message: '{{ template "telegram.default.message" .}}'  # (default)
      disable_notifications: false  # (default)
      parse_mode: "HTML"  # (default)
      http_config: global.http_config  # (default)

inhibit_rules:

time_intervals:
  - name: "night"
    time_interval:
      - times:
        - start_time: "09:00"
          end_time: "10:00"
        weekdays:
          - "monday:friday"
          - "monday"
        days_of_month:
          - "1:5"
          - "-3:-1"
        months:
          - "1:3"
          - "may:august"
		years:
		  - "2023:2024"
		  - "2030"
        location: "UTC"
```
- `global`: По смыслу аналогичен `global` в `prometheus server`.
- `resolve_timeout`: Время, через которое алерт автоматически будет считаться разрешенным (неактуальным), если для этого алерта не было получено обновлений или отсутствует поле `EndsAt`. Не влияет на prometheus, так как он всегда включает `EndsAt`.
- `templates`: Список путей к файлам, содержащим шаблоны уведомлений.
- `route`: Корневой узел дерева маршрутизации уведомлений. Он определяет, как уведомления будут маршрутизироваться к разным получателям на основе разных условий.
	- `receiver`: Получатель уведомления.
	- `group_by`: Лейблы, по которым алерты должны быть сгруппированы.
	- `continue`: Должен ли алерт продолжать соответствовать последующим маршрутам, если текущий совпал.
	- `matchers`: Условия, которым должен соответствовать алерт. Может включать равенства и регулярные выражения для лейблов.
	- `group_wait`: Время ожидания, прежде чем отправить уведомление для группы алертов. Это позволяет подождать получения нескольких алертов, относящихся к одной группе, прежде чем отправить уведомление.
	- `group_interval`: Время ожидания перед отправкой уведомлений для новых алертов, которые присоединились к уже существующей группе.
	- `repeat_interval`: Время ожидания перед повторной отправкой уведомления для уже существующего алерта, если он снова становится активным.
	- `mute_time_intervals`: Список временных интервалов, в которые не нужно отправлять уведомления.
	- `active_time_intervals`: Список временных интервалов, в которе нужно отправлять уведомления.
	- `routes`: Список дочерних маршрутов, которые могут быть настроены внутри текущего маршрута.
- `receivers`: Список получателей уведомлений. Получатели могут быть настроены для разных каналов.
	- `telegram_configs`: Параметры для отправки уведомлений через telegram.
	- `send_resolved`: Нужно ли отправлять уведомления об алертах, которые были разрешены.
	- `api_url`: URL API Telegram.
	- `bot_token`: Токен тг-бота.
	- `bot_token_file`: Путь к файлу с токеном тг-бота. Вместо `bot_token`.
	- `chat_id`: id чата тг.
	- `message`: Шаблон сообщения.
	- `disable_notifications`: Следует ли отключить уведомления для этого получателя.
	- `parse_mode`: Режим парсинга сообщений (`MarkdownV2`, `Markdown`, `HTML`).
- `inhibit_rules`: Список правил, которые позволяют блокировать уведомления для определенных алертов, если другие алерты находятся в активном состянии.
- `time_intervals`: Определяет именованный интервал времени, на который можно ссылаться в `route` для включения/выключения определенных маршрутов в определенное время дня.
	- `name`: Уникальное имя интервала времени.
	- `times`: Начало (`start_time`) и конец (`end_time`) временного диапазона в формате `HH:MM`.
	- `weekdays`: Дни недели, где неделя начинается в вс.
	- `days_of_month`: Числа в месяцах. Принимаются и отрицательные значения, где например -1 это 31 января.
	- `months`: Месяцы года.
	- `years`: Годы.
	- `location`: Часовой пояс интервала времени в формате IANA.

## Docker compose

```yml
services:
  prometheus:
    image: prom/prometheus:${PM_VERSION}
    container_name: prometheus
    command:
      - "--config.file=/etc/prometheus/prometheus.yml"
      - "--storage.tsdb.path=data/"
      - "--storage.tsdb.retention.time=30d"
      - "--storage.tsdb.retention.size=0"
      - "--storage.tsdb.wal-compression"
      - "--web.listen-address=${PM_HOST}:${PM_PORT}"
      - "--config.auto-reload-interval=30s"
      - "--log.level=info"
      - "--log.format=logfmt"
    volumes:
      - "./prometheus.yml:/etc/prometheus/prometheus.yml"
      - "${PM_HOME_DIR}/data:/prometheus"
      - "${PM_HOME_DIR}/logs:/var/log/prometheus"
    healthcheck:
      test: ["CMD", "wget", "--spider", "--quiet", "${PM_HOST}:${PM_PORT}/-/ready"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    networks:
      monitoring:
  alertmanager:
    image: quay.io/prometheus/alertmanager:${AM_VERSION}
    container_name: alertmanager
    networks:
      monitoring:

networks:
  monitoring:
    external: true
```
- Пример конфигурации `prometheus` и `alertmanager` в docker compose с healthcheck для prometheus.