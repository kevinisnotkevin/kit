# GITLAB

**GitLab** - это веб-платформа для управления репозиториями Git, непрерывной интеграции и разработки (CI/CD), отслеживания ошибок, планирования задач. Он предоставляет командам разработчиков инструменты для совместной работы над проектами программного обеспечения.

Logrotate в gitlab управляет всеми журналами, кроме тех, которые записывает runit. Он перемещает, сжимает, удаляет журналы.

Переменная окружения `GITLAB_OMNIBUS_CONFIG` в docker позволяет настроить конфигурацию gitlab до загрузки основного конфигурационного файла `/etc/gitlab/gitlab.rb`. Все параметры, переданные через `GITLAB_OMNIBUS_CONFIG`, не записываются в файл `gitlab.rb`. Они только используются в процессе старта GitLab, и после этого основной конфигурационный файл остаётся нетронутым.

Gitlab содержит следующие утилиты, которые могут быть настроены: `Gitlab Rails`, `Gitlab Shell`, `PostgreSQL`, `Redis`, `Puma`, `GitLab Workhorse`, `NGINX status`, `Prometheus`, `Node exporter`, `Redis exporter`, `PostgreSQL exporter`, `GitLab Exporter`, `Sidekiq exporter`, `Sidekiq health check`, `Elastic search`, `GitLab Pages`, `GitLab Registry`, `SMTP`, `OmniAuth`.

- **KAS (Kubernetes Agent Server)** - это компонент, который по умолчанию устанавливается вместе с gitlab. Он требуется для управления агентом kubernetes.

```bash
cat /etc/gitlab/initial_root_password
```
- Файл с изначально сгенерированным паролем.

```bash
gitlab-ctl reconfigure
# Или
docker restart gitlab
```
- После внесения изменений необходимо обновить конфигурацию.

```bash
docker exec -t gitlab gitlab-backup create
```
- Создание резервной копии gitlab.

```bash
docker exec -t gitlab gitlab-backup create SKIP=artifacts,repositories,registry,uploads,builds,pages,lfs,packages,terraform_state
```
- Создание резервной копии БД. Полезно перед обновлением версии gitlab. Копия будет находиться в `/var/opt/gitlab/backups`.

## Initial account

По умолчанию автоматически генерируется пароль для `root` и сохраняется в `/etc/gitlab/initial_root_password`. Через 24 часа этот файл удаляется. Учетная запись по умолчанию привязана к рандомной почте. 

```rb
GITLAB_ROOT_EMAIL = example@example.com
GITLAB_ROOT_PASSWORD = password
```
- Для предоставления собственного пароля и почты, используются переменные окружения.

```rb
gitlab_rails['initial_root_password'] = 'password'
```
- Второй способ предоставления пароля для `root`.

## Gitlab runner

**GitLab Runner** - это агент, который выполняет задачи CI/CD (jobs), такие как сборка, тестирование, развертывание кода, описанные в `.gitlab-ci.yml`. Агент может работать на физических машинах или виртуальных экземплярах.

Можно указать образ контейнера, который будет использоваться при запуске заданий. Ранер загрузит образ, клонирует проект, запустит задание локально или в контейнере.

Ранеры могут работать для одного проекта, для группы проектов или для всех проектов.

Для работы с ранером, его необходимо зарегистрировать в гитлаб.

**Executor** - это компонент, который выполняет задачи в разных средах.

Каждый ранер может выполнять несколько заданий и подключаться к различным исполнителям (docker, shell и др), чтобы изолировать выполнение каждой задачи в своем окружении.

Docker-образ ранера основан на Ubuntu или Alpine Linux. Ранер может работать, как один двоичный файл и не имеет требований к языку. При запуске ранера в контейнере, необходимо дать доступ к docker демону (Например, через монтирование `/var/run/docker.sock`). Это позволяет ранеру запускать другие контейнеры, необходимые для ci/cd задач.

---

### Commands

- `register`: Команда регистрирует ранер в гитлаб. 
	- После регистрации ранер добавляется в конфигурационный файл `config.toml`. 
	- Можно регистрировать несколько ранеров в одном экземпляре гитлаб ранер. 
	- Ранер можно зарегистрировать в интерактивном режиме, автономном режиме (Флаг `--non-interactive` или переменная `REGISTER_NON_INTERACTIVE`) или с помощью файла конфигурации `config.toml` (Флаг `--template-config` или переменная `TEMPLATE_CONFIG_FILE`). 
	- Параметры ранера можно задать с помощью аргументов командной строки, переменных окружения или в интерактивном режиме.
- `list`: Команда выводит ранеры из файла конфигурации.
- `verify`: Команда проверяет, могут ли зарегистрированные ранеры подключиться к гитлаб. Флаг `--delete` удаляет ранеры, которые были удалены из гитлаб.
- `unregister`: Команда отменяет регистрацию ранера с помощью имени ранера или url gitlab и токена ранера. Флаг `--all-runners` отменяет регистрацию всех ранеров.
- `reset-token`: Команда сбрасывает токен ранера.
- `run`: Команда запускает ранер, чтобы он начал обрабатывать задачи из гитлаб.

### Registration

Каждый ранер необходимо зарегистрировать (Связать ранер с одним или несколькими экземплярами gitlab), чтобы он смог получать задачи от gitlab. После аутентификации ранера в гитлаб, он получает токен задачи, который он использует для выполнения задачи.

Зарегистрировать ранер можно в автономном режиме с помощью флага `--non-interactive` или переменной окружения `REGISTER_NON_INTERACTIVE=true`. Также, ранер можно зарегистрировать с использованием шаблона конфигурации.

Чтобы получить токен аутентификации, необходимо создать ранер в гитлаб.

```bash
# Способ 1
gitlab-runner register 
	--non-interactive \
	--url "${GITLAB_URL}" \
	--token "${RUNNER_TOKEN}" \
	--executor "docker" \
	--docker-image alpine \
	--description "docker_runner"

# Способ 2
gitlab-runner register
```
- Регистрация ранера.

Файл `config.toml` позволяет изменить поведение ранера. При изменении параметров в `[[runners]]`, глобальном разделе, кроме listen_address, не требуется перезагрузка для их применения. Ранер проверяет конфигурацию каждые 3 секунды или с помощью сигнала `SIGHUP`.

### Web terminal

Веб-терминал использует веб-сокеты. Поэтому каждый обратный прокси сервер перед ранером должен быть настроен на это. Gitlab по умолчанию настроен на это. Но, если перед Gitlab находится обратный прокси сервер, то необходимо его настроить.

### Configurations

Конфигурация ранера находится в файле `gitlab-runner/config.toml`.

```toml
concurrent = 1
log_level = 'info'
log_format = runner  # (default)
check_interval = 3  # (default)
connection_max_age = 15m  # (default)
listen_address = host:port
shutdown_timeout = 30  # (default)

[session_server]
  listen_address = "[::]:8093"
  advertise_address = "runner-host-name.tld:8093"
  session_timeout = 1800  # (default)

[[runners]]
  name = "runner_name"
  url = "gitlab url"
  token = "auth token"
  limit = 0  # (default)
  executor = "docker"
  shell = ""
  builds_dir = ""
  cache_dir = ""
  environment = ["ENV=value", "ENV=value"]
  request_concurrency = 1  # (default)
  output_limit = 4096  # (default)
  pre_get_sources_script = ""
  post_get_sources_script = ""
  pre_build_script = "echo start\necho second command"
  post_build_script = "echo end"
  clone_url = ""
  debug_trace_disabled = true
  referees = ""
  unhealthy_requests_limit = ""
  unhealthy_interval = "3600s"  # (default)

  [runners.docker]
  allowed_images = ["*/*:*"]  # (default)
  allowed_privileged_images = ["*/*:*"]  # (default)
  allowed_services = ["*/*:*"]  # (default)
  allowed_privileged_services = ["*/*:*"]  # (default)
  cache_dir = ""
  cpu_shares = 1024  # (default)
  cpus = "1"
  disable_cache = false
  disable_entrypoint_overwrite = false
  dns = ["8.8.8.8", "8.8.4.4"]
  helper_image_flavor = "alpine"  # (default)
  host = "unix:///var/run/docker.sock"  # (default)
  image = "python:3.12.7-slim"
  memory = "4g"
  network_mode = "host"
  oom_kill_disable = false
  tls_verify = false
  volumes = ["/cache"]
  wait_for_services_timeout = 30  # (default)
```
- `concurrent`: Кол-во задач, которые могут выполняться одновременно на всех зарегистрированных ранерах.
- `log_level`: Уровень логов (`debug`, `info`, `warn`, `error`, `fatal`, `panic`). Флаги `--debug`, `-l`, or `--log-level` имеют более высокий приоритет.
- `log_format`: Формат логов (`runner`, `text`, `json`). `runner` - цветная консоль. Флаг `--log-format` имеет более высокий приоритет.
- `check_interval`: Интервал в секундах между проверками на наличие новых задач. Если есть несколько ранеров, то процесс проверки задач распределяется между всеми ранерами (Если значение 10 и есть 2 раннера, то первый ранер сделает запрос задач и уснет на 5 сек, затем это сделает второй, затем цикл повторится).
- `connection_max_age`: Продолжительность поддержания tls соединения с gitlab перед переподключением.
- `listen_address`: Адрес, который должен прослушивать prometheus.
- `shutdown_timeout`: Время ожидания до принудительного завершения процесса при выключении ранера. Нужно для корректного завершения задач.
- `[session_server]`: Раздел позволяет пользователям взаимодействовать с задачами в интерактивном веб-терминале.
	- `listen_address`: Внутренний url, на котором слушает сервер сессий. Этот адрес используется для связи ранера с сервером сессий.
	- `advertise_address`: Внешний url, по которому можно получить доступ к серверу сессий. Этот браузер должен быть доступен из браузера пользователя, так как именно он инициирует соединение для веб-сессий.
	- `session_timeout`: Время в секундах, в течение которого сессия остается активной после завершения задачи.
- `[[runners]]`: Раздел настройки каждого ранера. Каждый такой блок представляет уникальную конфигурацию ранера.
	- `name`: Описание ранера.
	- `url`: url гитлаб.
	- `token`: Уникальный токен для аутентификации раннера. Выдается при регистрации раннера.
	- `limit`: Лимит количества задач, которые этот раннер может обрабатывать одновременно.
	- `executor`: Тип среды для выполнения задач (`docker`, `shell`, `ssh`, `kubernetes`).
	- `shell`: Тип оболочки, который используется для выполнения команд. По умолчанию зависит от операционной системы.
	- `builds_dir`: Абсолютный путь к директории, где будут храниться файлы билдов.
	- `cache_dir`: Абсолютный путь к директории, где будут храниться кешированные файлы.
	- `request_concurrency`: Лимит одновременных запросов на получение новых задач от GitLab.
	- `output_limit`: Максимальный размер логов выполнения задачи в килобайтах.
	- `pre_get_sources_script`: Команды, которые выполняются до обновления репозитория.
	- `post_get_sources_script`: Команды, которые выполняются после обновления репозитория.
	- `pre_build_script`: Команды, которые выполняются до начала выполнения задачи.
	- `post_build_script`: Команды, которые выполняются после выполнения задачи, но до выполнения `after_script`.
	- `clone_url`: Перезапись URL GitLab. Используется только в том случае, если ранер не может подключиться к URL GitLab.
	- `debug_trace_disabled`: Если установлено в `true`, отладочный лог (`CI_DEBUG_TRACE`) будет отключен, даже если он включен в конфигурации задачи.
	- `unhealthy_requests_limit`: Лимит неудачных попыток получения задач, после которого раннер временно отключается.
	- `unhealthy_interval`: Время, на которое раннер отключается после превышения лимита неудачных запросов. Если GitLab недоступен в течение длительного периода времени (например, во время обновления версии), механизмы запуска, настроенные для этого экземпляра, переходят в режим ожидания и не возобновляют обработку задач в течение указанного интервала времени.
- `[runner.docker]`: Раздел определяет настройки для выполнения задач внутри docker контейнеров.
	- `image`: Базовый docker образ для выполнения задач.
	- `privileged`: Запуск контейнеров с повышенными правами.
	- `allowed_images`: Список разрешенных образов.
	- `allowed_services`: Список разрешенных сервисов.
	- `cpu_shares`: Приоритет контейнера в использовании cpu.
	- `disable_cache`: Отключение локального кэша docker, чтобы сэкономить место.
	- `disable_entrypoint_overwrite`: Отключение изменения entrypoint образа при запуске задачи.
	- `host`: Эндпоинт docker.
	- `network_mode`: Режим сети контейнера.
	- `oom_kill_disable`: В случае возникновения ошибки памяти не завершать процессы в контейнере.
	- `volumes`: Список томов, которые нужно смонтировать (как у docker флага `-v`).
	- `wait_for_services_timeout`: Как долго ждать docker сервисы.

## Administration

Настраиваемые значения:

- Максимальное кол-во проектов для новых пользователей. 0 запрещает пользователям создавать проекты, но разрешает создавать проекты в группе. (`Admin-Settings-General-Account`). Также можно задать лимит для конкретного пользователя.
- max attachment size в комментариях и ответах - 100 мб.
- max push size уведомлений.
- Префикс для personal access tokens. По умолчанию `glpat-`.
- **Session duration**: Время, в течение которого пользователи могут оставаться в системе без активности.
- Флажок при входе "Запомнить меня".
- Возможность регистрации аккаунта.
- Возможность создания `top-level groups`.
- Возможность создавать проекты и группы `non-members` пользователям.
- Новые пользователи будут иметь приватный профиль по умолчанию.
- **Auto DevOps** для всех проектов.
- Новым проектам доступны существующие ранеры.
- Максимальный размер артефакта.
- Срок годности артефакта.
- **Telegram**: Есть возможность настроить уведомления в телеграм по различным событиям в gitlab.
- **Auto DevOps**: Отключение функции.
- **Instance runners**: Доступ к существующим ранерам для новых проектов.


- Настройка projects
- Настройка groups
- Настройка roles
- Gitlab поддерживает импорт проектов из многих внешних источников.

---

Рекомендации по безопасности

- Использование сложного пароля root
- Отключение новых регистрация
- Включение подтверждений по почте
- Включение 2FA
- Отключение аутентификации по паролю для git через https.
- Включение уведомлений по почте при входе для неизвестных входов
- Настройка ограничения скорости пользователя и ip
- Ограничение локального доступа вебхуков.

### Auth

Gitlab поддерживает LDAP, SAML, SCIM, OmniAuth, OAuth 2.0, JWT, Kerberos.

### Performance bar

Панель производительности позволяет смотреть статистику производительности страницы пользовательского интерфейса. `p + b` отображает эту панель. По умолчанию доступна только админам. Значения, которые превышают пределы, имеют значок предупреджения ⚠️.

- **Host**: Хост, который обслужил страницу.
- **SQL queres**: Затраченное время и кол-во запросов к БД.
- **Gitaly calls**: Затраченное время и кол-во обращений к gitaly.
- **Redis calls**: Затраченное время и кол-во обращений к redis.
- **Elasticsearch calls**: Затраченное время и кол-во обращений к elasticsearch.
- **ClickHouse queries**: Затраченное время и кол-во обращений к ClickHouse.
- **External Http calls**: Затраченное время и кол-во запросов к другим системам.
- **Memory**: Обьем потребляемой памяти, выделенной во время загрузки страницы.
- **Frontend resources**: Время загрузки страницы. **Backend** - время загрузки базовой страницы, **First Contentful Paint** - первая отрисовка контента, **DOM Content Loaded** - время загрузки DOM, **Total** - кол-во запросов для загрузки страницы.
- **Wall flamegraph**: Выборка каждого интервала времени.
- **CPU flamegraph**: Выборка каждого интервала активности cpu.
- **Object flamegraph**: Выборка каждого интервала.

## Logs

Чтобы свести к минимуму проблемы с производительностью, в каждом файле журнала отображается не более 2000 строк.

```sh
GITLAB_LOG_LEVEL = DEBUG  # (default)
```
- Уровень логов (`DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL`, `UNKNOWN`).

- `gitlab-rails/production_json.log`: Журнал запросов rails, полученных от gitlab, благодаря lograge. Запросы от api записываются в отдельный файл `api_json.log`.
- `gitlab-rails/production.log`: Журнал с информацией обо всех выполненных запросах.
- `gitlab-rails/api_json.log`: Журнал с запросами к апи.
- `gitlab-rails/application_json.log`: Журнал с событиями гитлаб (Например, создание пользователя, удаление проекта).
- `gitlab-rails/integrations_json.log`: Журнал с интеграционными действиями (Jira, asana и др).
- `gitlab-rails/git_json.log`: Журнал с неудачными запросами от гитлаб к гит.
- `gitlab-rails/audit_json.log`: Журнал с записями об изменении настроек группы или проекта.

## Configuration

```rb
# Продолжительность кэширования настроек
gitlab_rails['application_settings_cache_seconds'] = 60  # (default)
# Использование артефактов
gitlab_rails['artifacts_enabled'] = true  # (default)
# Каталог хранения артефактов
gitlab_rails['artifacts_path'] = "/var/opt/gitlab/gitlab-rails/shared/artifacts"  # (default)
# Частота удаления устаревших артефактов
gitlab_rails['artifacts_expire_worker_cron'] = '*/7 * * * *'  # (default)
# Использование LFS
gitlab_rails['lfs_enabled'] = true  # (default)
# Каталог хранения LFS
gitlab_rails['lfs_storage_path'] = "/var/opt/gitlab/gitlab-rails/shared/lfs-objects"
```

## Gitlab

---

**Namespaces**

Есть два типа пространств имен:

- **User**: Пространство имен основано на имени пользователя.
	- Нельзя создавать подгруппы.
	- Группы не наследуют разрешения в пространстве имен или функции группы.
	- При изменении имени пользователя изменяются URL-адреса проекта и пространства имен.
- **Group**: Пространство имен группы или подгруппы основано на имени группы или подгруппы.
	- Можно создавать несколько подгрупп для управления несколькими проектами. 
	- Подгруппы наследуют некоторые настройки родительской группы. 
	- Можно настроить параметры конкретно для каждой подгруппы и проекта.
	- Можно управлять URL-адресом группы или подгруппы независимо от имени.

---

**Members**

Каждый участник получает роль, которая определяет, что он может делать в проекте. Пользователи могут стать участниками группы или проекта прямо или косвенно. Косвенное членство может быть унаследовано, разделено или унаследовано совместно.

- **Direct**: Пользователь добавляется непосредственно в текущую группу или проект.
- **Inherited**: Пользователь является членом родительской группы, содержащей текущую группу или проект.
- **Shared**: Пользователь является членом группы, приглашенной в текущую группу или проект.
- **Inherited shared**: Пользователь является членом группы, приглашенной предком текущей группы или проекта.
- **Indirect**: Общий термин для `inherited`, `shared`, и `inherited shared` членов.

---

**Groups**

Группы используются для одновременного управления несколькими связанными проектами. При наличии доступа к группе, автоматически есть доступ ко всем проектам в группе. Можно смотреть аналитику активности, проблемы и мерж реквесты проектов группы.

Пользователи не могут создать подгруппу или проект с более высоким уровнем видимости, чем у непосредственной родительской группы. Как и проекты, группу можно настроить так, чтобы ее видели:  

- Анонимные пользователи.  
- Все авторизованные пользователи.  
- Только явные члены группы.

Для группы можно создать README, чтобы предоставить информацию о команде. Для этого нужна роль владельца. Создается специальный проект gitlab-profile, который содержит README файл. `Settings-General-Group README`.

---

### Roles

Роль пользователя определяет, какие разрешения он имеет в проекте.

Роли по умолчанию:

- **Guest**
- **Report**
- **Developer**
- **Maintaner**
- **Owner**

По умолчанию все пользователи могут создавать группы верхнего уровня и изменять имена пользователей.

### SSH

**Git** - это распределенная система контроля версий, которая позволяет работать локально, а затем делиться изменениями или отправлять их на сервер. В данном случае сервер - это Gitlab. Gitlab использует протокол ssh для безопасного взаимодействия с git. Ключи SSH для аутентификации позволяют не вводить каждый раз имя пользователя и пароль.

SSH использует два ключа: открытый и закрытый. Открытый ключ может быть распределен. Закрытый ключ должен быть защищен.

Для связи с гитлабом можно использовать следующие типы ключей ssh: ed25519, ed25519_sk, rsa, ecdsa_sk, scdsa.

Можно ограничить разрешенные технологии ключей ssh, а также указать минимальную длину ключа для каждой технологии.

### Gitlab Registry

**Gitlab container registry** - это встроенный в gitlab приватный docker реестр, который позволяет пользователям хранить, управлять и развертывать docker образы.

- Каждый проект в GitLab автоматически получает доступ к собственному пространству в Container Registry. Это позволяет хранить образы в контексте конкретного проекта.
- Веб-интерфейс GitLab позволяет просматривать, удалять и управлять Docker-образами прямо из интерфейса проекта.
- Поддерживает авторизацию через GitLab-токены. Ограничивает доступ на уровне проекта, что обеспечивает безопасность образов.
- Администраторы могут настроить правила очистки (cleanup policies) для автоматического удаления старых или неиспользуемых образов, чтобы экономить место.
- В GitLab CI/CD легко настраивается создание, загрузка и использование Docker-образов.
- Невозможно переименовать пространство имен, если оно содержит проект с тегами реестра контейнеров, поскольку проект невозможно переместить.

```bash
docker login gitlab.example.com
```
- Проверить наличие реестра в гитлаю по умолчанию, и подключиться к нему.

```rb
registry_external_url 'https://gitlab.example.com:5050'
```
- Реестр можно настроить для домена gitlab или для другого домена. Если реестр контейнеров настроен на использование существующего домена GitLab, можно предоставить доступ к реестру контейнеров через порт. Таким образом, можно повторно использовать существующий сертификат TLS GitLab.

Срок действия токенов реестра контейнеров истекает каждые пять минут. Это значение регулируется в настройках админа.

```bash
gitlab-ctl registry-garbage-collect
```
- Удаление неиспользуемых слоев. Слой считается неиспользуемым, если на него не ссылается ни один манифест изображения.
- `-m`: Удаление образов без тегов.

### SSL

Если external_url содержит `https://`, то NGINX настраивается для использования SSL. Однако при настройке GitLab для работы через обратный прокси-сервер или внешний балансировщик нагрузки, может потребоваться отключить SSL вне приложения GitLab.

```rb
nginx['listen_port'] = 80
nginx['listen_https'] = false

registry_nginx['listen_port'] = 80
registry_nginx['listen_https'] = false
```
- Запретить встроенному nginx обрабатывать ssl. Конфигурация для других, входящих в комплект, компонентов, работает также.

```
external_url "http://gitlab.example.com"
```
- `external_url`: Внешний URL, по которому пользователи и другие сервисы могут обращаться к gitlab. Параметр `external_url` автоматически конфигурирует встроенный Nginx для работы с указанным URL. Если URL начинается с `https://`, Nginx будет настроен на использование HTTPS.

### Gitlab CI

**Gitlab CI/CD** - это инструмент автоматизиации процессов CI/CD. Он позволяет постоянно собирать, тестировать, развертывать и мониторить изменения кода. Gitlab CI/CD включен по умолчанию во всех новых проектах.

Чтобы исполльзовать Gitlab CI/CD, необходимо создать конфигурационный файл `.gitlab-ci.yml` в корне репозитория. В этом файле определяются этапы, задания, переменные, зависимости.

**Stage (Этап)** - это этап, который описывает последовательное выполнение заданий (Например, build, test, deploy). Задания чаще всего группируются по этапам. Если есть несколько ранеров, то задания на одном этапе выполняются параллельно. Если задание завершается неудачей, то весь этап считается неудачным, а задания на поздних этапах не запускаются. Если `stages` не определен, то `build`, `test`, `deploy` являются этапами по умолчанию.

**Job (Задание)** - это автономные части пайплайна, выполняющие команды на определенном этапе (Например, тестирование, сборка) в ранере. Задания являются автономными и не используют ресурсы друг друга.

Задача содержит:

- `Status`: Статус задания (`passed`, `skipped`, `failed`)
- `Job`: Ссылки на задачу, ветку и комит, который начал задачу.
- `Pipeline`: Ссылка на пайплайн.
- `Project`: Имя проекта и организация, которой принадлежит задача.
- `Runner`: Имя ранера, назначенного на выполнение задачи.
- `Stage`: Этап задачи из `.gitlab-ci.yml`.
- `Name`: Имя задачи из `.gitlab-ci.yml`.
- `Timing`: Продолжительность задачи и время его завершения.
- `Coverage`: Процент покрытия тестов.

**Variables (Переменные)** - это пары ключ-значение, которые используются для передачи настроек, токенов, паролей и других параметров задачам в пайплайне.

- **Custom variables (Пользовательские переменные)** определяются пользователем в Gitlab или в файле конфигурации.
- **Predefined variables (Предопределенные переменные)** автоматически устанавливаются Gitlab и предоставляют информацию о текущем задании, конвейере и среде. Обычно имеют формат `$CI_`.
- **Protected variables (Защищенные переменные)** доступны только для защищенных веток или тегов.
- **Masked variables (Маскированные переменные)** скрыты в журналах заданий, чтобы предотвратить раскрытие конфиденциальной информации.

**CI/CD component** - это повторно используемая единица конфигурации пайплайна, которая позволяет избежать дублирования, улучшить читаемость, поделиться конфигурацией.

`needs` позволяет запускать задания вне порядка стадий, чтобы повысить эффективность конвейера.

#### Keywords

```yml
default:
include:
stages:
variables:
workflow:
```
- `default`: Значения по умолчанию для ключевых слов, которые применяются ко всем заданиям, если они не определены. Часто используется с `before_script` и `after_script`.
- `include`: Импорт из других yml файлов.
- `stages`: Имена и порядок этапов пайплайна.
- `variables`: Переменные среды для всех заданий в пайплайне.
- `workflow`: Контроль типов выполняемых пайплайнов.
- `spec`: Спецификации для внешних файлов конфигурации.
- `script`: Список команд, которые выполняются по порядку. Каждая команда выполняется так, будто она запущена как команда cli. По умолчанию, если команда завершается неудачно или возвращает ошибку, то задание помечается как невыполненное и команды больше не выполняются.
- `image`: Образ контейнера для запуска задания.
- `artifacts`: Сохраненные данные, созданные в процессе выполнения задачи.
- `stage`: Этап пайплайна.
- `allow_failure`: Разрешение ошибок задания без остановки пайплайна.
- `dependencies`: Задания, из которых следует получать артефакты. Значение `[]` ускоряет работу задания.
- `rules`: Список условий для выполнения задания. Например, выполнение задания в merge request пайплайне.
- `.`: Задания, начинающиеся с точки не добавляются к пайплайн. Они используются для хранения конфигурации.
- `extends`: Расширение конфигурации другого задания (Чаще всего задания, которое начинается с точки).

---

**Artifacts**

**Artifact** - это данные, создаваемые в процессе выполнения задач. После выполнения задачи ранер может загрузить архив с артефактами в гитлаб. Параметр `artifacts:when` определяет это поведение (`on_success` - загрузка при успешном выполнении задачи (по умолчанию), `on_failure` - загрузка только при сбое задачи, `always` - загрузка всегда). Большинство артефактов ранер сжимает перед отправкой гитлабу, кроме артефактов, относящихся к отчету.

Параметр `artifacts:expire_in` позволяет задать срок действия в секундах для артефактов (По умолчанию 30 дней). После завершения срока действия артефакты автоматически помечаются для удаления.

Удалением устаревших артефактов занимается задача `expire_build_artifacts_worker`, которая запускается через **Sidekiq**. Эта задача выполняется по расписанию каждые 7 минут (в формате Cron это `*/7 * * * *`).

### Pipeline

**Pipeline (Конвейер)** - это последовательность этапов и задач, описанных в конфигурационном файле. Пайплайн может запускаться по расписанию (cron) или различными событиями (merge request, commit).

**Pipeline editor** - это редактор конфигурации Gitlab CI/CD, который позволяет выбрать рабочую ветку, изменить конфигурацию, проверить синтаксис конфигурации, выполнить анализ конфигурации, визуализировать конфигурацию.

При редактировании конфигурации пайплайна, редактор проверяет синтаксис и выполняет базовые логические проверки.

Обычная задача пайплайна - сборка кода и его развертывание.

## Omnibus

**Omnibus GitLab** - это пакет, который включает в себя все необходимые компоненты для работы GitLab, такие как веб-сервер, база данных, Redis и другие зависимости. Omnibus упрощает процесс установки и конфигурации GitLab, объединяя всё в одном пакете.

Omnibus GitLab включает в себя различные программные компоненты для поддержки запуска GitLab в конфигурации высокой доступности. По умолчанию некоторые из этих вспомогательных служб отключены, а Omnibus GitLab настроен для запуска в качестве установки с одним узлом. Каждую службу можно включить или отключить с помощью параметров конфигурации в `/etc/gitlab/gitlab.rb`, но введение ролей позволяет легко включить группу служб и обеспечивает лучшую конфигурацию по умолчанию на основе включенных вами ролей высокой доступности.

Основные компоненты:

- 

По умолчанию, гитлаб включает службы для установки на одном узле. Туда входят postgresql, redis, puma, sidekiq, gitaly, workhorse, nginx и др.

```rb
roles ['application_role']
```
- Роли передаются в виде списка в файле конфигурации.
- `application_role`: Роль для настройки только гитлаб. Службы Redis, PostgreSQL, Consul отключены.

## Gitlab Rails

**Gitlab Rails** - это сердце GitLab, обеспечивающее всю серверную функциональность. Оно отвечает за основную логику работы GitLab, включая взаимодействие с БД, обработку API-запросов, управление пользовательским интерфейсом и выполнение бизнес-логики.

Задачи:

- Отвечает за маршрутизацию запросов к нужным компонентам системы (например, к API, веб-интерфейсу или сторонним сервисам).
- Управляет взаимодействием с PostgreSQL (основная база данных GitLab), включая чтение и запись данных о репозиториях, пользователях, проектах и настройках.
- REST API и GraphQL API реализованы на уровне GitLab Rails, предоставляя возможность взаимодействия с GitLab через программные интерфейсы.
- Координирует работу между Redis, Sidekiq, Gitaly и другими службами, чтобы обеспечить их согласованное функционирование.
- Создание и удаление проектов, управление правами доступа, ведение аудита действий, настройка уведомлений.
- Обработка email-уведомлений, вебхуков и других интеграций.
- Генерация HTML-страниц для фронтенда, обеспечивая интерактивность пользовательского интерфейса.

### Workhorse

**Workhorse** - это компонент, который помогает управлять ресурсоемкими задачами (загрузка или скачивание файлов и др). Он выполняет роль прокси сервера, который улучшает производительность за счет делегирования зада на отдельные сервисы.

- Включен по умолчанию.

### Puma

**Puma** - это сервер приложений на ruby. Он оптимизирован для работы в многопоточном режиме и является лёгким, быстрым и современным решением для обработки HTTP-запросов.

В GitLab, Puma используется как сервер приложений для обработки веб-запросов и API-запросов, поступающих к приложению GitLab.

Ранее GitLab использовал сервер приложений Unicorn, но с версии GitLab 13.0 по умолчанию используется Puma. Причины перехода на Puma:

- Unicorn работает в однопоточном режиме, что менее эффективно.
- Puma требует меньше памяти и CPU.
- Puma подходит для высоконагруженных сред.

### Sidekiq

**Sidekiq** - это инструмент для обработки фоновых задач в ruby приложениях.

Sidekiq требует подключения к Redis, PostgreSQL, Gitaly. Sidekiq в GitLab использует Redis как механизм хранения очередей. Каждый worker - это отдельный класс в Ruby, который определяет, как обрабатывать задачу. GitLab имеет множество предопределённых воркеров для разных типов задач. - Когда задача добавляется в очередь, Sidekiq берёт её из Redis, выполняет и помечает как завершённую или провалившуюся. При сбое задача может быть перенесена в очередь повторных попыток.

GitLab позволяет запускать несколько процессов Sidekiq для более быстрой обработки фоновых заданий в одном экземпляре. По умолчанию Sidekiq запускает один рабочий процесс и использует только одно ядро. По умолчанию, gitlab использует unix сокеты и не настроен для связи через tcp.

Задачи:

- Обработка фоновых задач, которые не должны или не могут выполняться непосредственно в процессе запроса пользователя. Это позволяет ускорить время отклика интерфейса GitLab и эффективно распределить нагрузку на систему.
- Sidekiq позволяет обрабатывать множество заданий одновременно, используя многопоточность. Это улучшает пропускную способность и распределяет нагрузку на сервер.

При запуске нескольких процессов их количество должно быть не больше количества ядер cpu, которые может использовать sidekiq. По умолчанию, каждый процесс, определенный в sidekiq, начинается с кол-ва потоков, равного кол-ву очередей, но не более 50. Процесс, который обрабатывает все очереди, по умолчанию использует 50 потоков. Потоки выполняются внутри одного процесса ruby, и каждый процесс может использовать только одно ядро cpu.

Правильное максимальное количество потоков зависит от рабочей нагрузки. Типичные значения варьируются от 5 для задач с высокой нагрузкой на cpu до 15 или выше для смешанных задач с низким приоритетом. Разумный стартовый диапазон составляет от 15 до 25 для неспециализированного развертывания.

Каждому потоку требуется соединение Redis, поэтому добавление потоков может увеличить задержку Redis.

При настройках по умолчанию Sidekiq перезагружается не чаще, чем раз в 15 минут, при этом перезапуск приводит к задержке примерно на одну минуту для входящих фоновых заданий. Это связано с утечками памяти.

```rb
SIDEKIQ_MEMORY_KILLER_MAX_RSS = 2000000  # (default)
SIDEKIQ_MEMORY_KILLER_GRACE_TIME = 900  # (default)
SIDEKIQ_MEMORY_KILLER_HARD_LIMIT_RSS = 0
SIDEKIQ_MEMORY_KILLER_CHECK_INTERVAL = 3  # (default)
SIDEKIQ_MEMORY_KILLER_SHUTDOWN_WAIT = 30  # (default)
GITLAB_MEMORY_WATCHDOG_ENABLED = true  # (default)
```
- Переменные окружения, которые позволяют предотвратить чрезмерное потребление памяти процессом Sidekiq.
- `SIDEKIQ_MEMORY_KILLER_MAX_RSS`: Лимит использования памяти RSS процесса Sidekiq в килобайтах. Если процесс Sidekiq превышает указанный лимит по памяти дольше, чем время, заданное в `SIDEKIQ_MEMORY_KILLER_GRACE_TIME`, инициируется плавная перезагрузка (graceful restart) процесса.
- `SIDEKIQ_MEMORY_KILLER_GRACE_TIME`: Время, в течение которого процесс Sidekiq может превышать лимит `SIDEKIQ_MEMORY_KILLER_MAX_RSS`.
- `SIDEKIQ_MEMORY_KILLER_HARD_LIMIT_RSS`: Жесткий лимит для потребления памяти RSS процесса Sidekiq в килобайтах. Если процесс Sidekiq превышает этот лимит, немедленно инициируется плавная перезагрузка независимо от времени.
- `SIDEKIQ_MEMORY_KILLER_CHECK_INTERVAL`: Интервал проверки объема используемой памяти процесса Sidekiq в секундах.
- `SIDEKIQ_MEMORY_KILLER_SHUTDOWN_WAIT`: Максимальное время в секундах, в течение которого Sidekiq должен завершить выполнение текущих задач при перезагрузке. Новые задания при этом не принимаются. Если плавная перезагрузка не завершается вовремя (`SIDEKIQ_MEMORY_KILLER_SHUTDOWN_WAIT` + 2 секунды), процесс принудительно завершается с использованием сигнала SIGTERM.
- `GITLAB_MEMORY_WATCHDOG_ENABLED`: Использование механизма Memory Watchdog, который следит за памятью Sidekiq.

### Gitaly


### PostgreSQL



### Redis

Redis можно развернуть в качестве локального компонента на сервере с GitLab или как внешний, выделенный сервер Redis. В Omnibus, Redis автоматически устанавливается и запускается на том же сервере, где установлен GitLab. То есть, Redis работает как часть Omnibus-сборки, и ничего настраивать не нужно.

- По умолчанию Redis настроен на работу через Unix-сокет, а не через сетевой интерфейс. Хост: `/var/opt/gitlab/redis/redis.socket`. Соответственно, порт и пароль не настроены.

Задачи:

- Кэширование промежуточных данных (результаты вычислений, веб-страницы, метаданные).
- Кэширование фоновых задач sidekiq (задачи отправки уведомлений, обработки изменений в репозиториях или обновления зеркал).
- Управление статусом задач (запущена, завершена, в очереди и т.д.).
- Хранение сессий пользователей, чтобы обеспечить быстрый доступ к информации о сессиях и поддерживать авторизацию без необходимости постоянных запросов к базе данных.
- Ограничение числа запросов за определенный интервал времени.
- Передача сообщений между различными компонентами GitLab.

```rb
redis['enable'] = true  # (default)
```
- Redis как локальный компонент GitLab.

```rb
# Конфигурация на отдельном сервере gitlab, который будет играть роль только как Redis сервер
roles ['redis_master_role']
redis['enable'] = true
redis['bind'] = '0.0.0.0'
redis['port'] = 6379  # Порт, на котором будет Redis
redis['password'] = 'redis_password'
gitlab_rails['auto_migrate'] = false  # (Миграцию должен выполнять основной сервер)


# Конфигурация на основном сервере gitlab
# Отключение встроенного Redis и подключение внешнего
redis['enable'] = false
gitlab_rails['redis_host'] = 'redis.example.com'
gitlab_rails['redis_port'] = 6379  # Порт Redis для подключения
gitlab_rails['redis_password'] = 'redis_password'
```
- Redis как отдельный сервер (Standalone Redis).

## Monitoring

Gitlab поставляется с собственной системой измерений производительности, которая включает:

- Статистика транзакций (Продолжительность транзакции, время выполнения запросов, время, затраченное на рендеринг haml представлений). Эти показатели собираются для каждого веб-запроса и задания sidekiq.
- Время, затраченное на выполнение sql-запросов.
- Время, потраченное на выполнение методов ruby.
- Системная аналитика (Использование памяти, дескрипторы открытых файлов).
- Статистика сборки мусора ruby.

### Prometheus

**Prometheus** - это основной инструмент мониторинга производительности Gitlab.

- 🟢 Сервисы prometheus включены по умолчанию.
- Prometheus и его экспортеры не аутентифицируют пользователей и доступны любому, кто может получить доступ.
- Gitlab отслеживает собственные метрики, которые доступны на эндпоинте `/-/metrics`. В отличие от других экспортеров, этот эндпоинт требует аутентификации, так как он доступен по тому же адресу, что и пользовательский трафик.
- Многие из зависимостей gitlab предварительно настроены для экспорта метрик prometheus.
- **Node exporter**: Метрики хоста.
- **Web exporter**: Сервер метрик, который позволяет разделить трафик пользователя и трафик prometheus для повышения производительности и доступности.
- **Redis exporter**: Метрики Redis.
- **PortgreSQL expoter**: Метрики PostgresSQL.
- **PgBouncer exporter**: Метрики PgBouncer.
- **Registry exporter**: Метрики Gitlab Registry
- **Gitlab exporter**: Метрики Gitlab, полученные из Redis и БД.