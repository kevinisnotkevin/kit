# Docker

## 1 Что такое Docker?

Docker - это платформа с открытым исходным кодом для автоматизации развертывания приложений в виде автономных модулей, называемых контейнерами. 

Он использует многоуровневую файловую систему и функции изоляции ресурсов для обеспечения гибкости и переносимости.

Контейнеры упрощают разработку и доставку распределенных приложений. Они становятся все более популярными по мере того, как организации переходят на облачную разработку и гибридные мультиоблачные среды. Разработчики могут создавать контейнеры без Docker, работая напрямую с возможностями, встроенными в Linux и другие операционные системы. Но Docker делает контейнеризацию быстрее, проще и безопаснее.

### 1.1 Установка Docker

```bash
curl -sSL https://get.docker.com | sh
sudo usermod -aG docker $(whoami)
exit
```
- Установка Docker на Linux

## 2 Архитектура ядра

Когда Docker был только запущен, он имел монолитную архитектуру. Теперь он разделен на следующие три различных части.

1. Docker Engine (dockerd)
2. docker-containerd (containerd)
3. docker-runc

Docker и другие крупные организации внесли свой вклад в создание стандартной среды выполнения контейнеров и уровней управления. Таким образом, Containerd и Runc теперь являются частью Cloud Native Foundation, в которую вносят вклад все организации.

**Docker Engine**

Docker Engine включает в себя демон Docker, интерфейс API и интерфейс командной строки Docker. Демон Docker (dockerd) работает постоянно как служба dockerd systemd. Он отвечает за создание образов докера.

**Docker-containerd**

Containerd - это еще одна служба системного демона, которая отвечает за загрузку образов докеров и их запуск в качестве контейнера. Он предоставляет свой API для получения инструкций от службы dockerd.

**Docker-runc**

Runc - это среда выполнения контейнера, ответственная за создание пространств имен и контрольных групп, необходимых для контейнера. Затем он запускает команды контейнера внутри этих пространств имен.

## 3 Компоненты

![](materials/images/devops/docker_components.png)
- Docker имеет клиент-серверную архитектуру. За все действия, связанные с контейнерами, отвечает Docker Daemon (dockerd) или сервер.

Вы вызываете Docker-клиент, чтобы получить информацию или дать инструкции демону. Демон - это сервер, который получает запросы и возвращает ответы от клиента по протоколу HTTP. В свою очередь, он будет отправлять запросы в другие службы для отправки и получения образов, также используя протокол HTTP. Сервер будет принимать запросы от клиента командной строки или любого, кто авторизован для подключения.

Клиент Docker может находиться на том же хосте, что и демон, или присутствовать на любом другом хосте.

Демон также отвечает за заботу о ваших образах и контейнерах за кулисами, тогда как клиент выступает в качестве посредника между вами и интерфейсом RESTful.

Образы (Images) - это основные строительные блоки Docker. Он содержит библиотеки ОС, зависимости и инструменты для запуска приложения.

Контейнеры Docker создаются из существующих образов. Это записываемый слой образа.

Частный реестр Docker - это сервис, который хранит образы Docker. Их можно запросить у любого демона Docker, у которого есть соответствующий доступ. Этот реестр находится во внутренней сети и не является общедоступным, поэтому считается закрытым.

Docker Hub - это общедоступный реестр, управляемый Docker Inc. В интернете также могут существовать другие публичные реестры, и ваш демон Docker способен взаимодействовать с ними.

Также в сети могут существовать другие публичные реестры Docker, к которым мы можем получить доступ и звпросить у них образы Docker.

Docker host - это просто компьютер или виртуальный сервер, на котором установлен Docker. Кстати, Docker можно запустить и из WSL 2. Это удобно, если вы работаете под Windows и используете Visual Studio Code.

### 3.1 Docker Daemon

Демон Docker - это центр взаимодействий с Docker, и поэтому он является лучшим местом, где можно начать понимать все соответствующие элементы. Он контролирует доступ к Docker на компьютере, управляет состоянием контейнеров и образов, а также взаимодействует с внешним миром.

Демон - это процесс, который выполняется в фоновом режиме, а не под непосредственным контролем пользователя. 

Сервер - процесс, который принимает запросы от клиента и осуществляет действия, необходимые для выполнения запросов. 

Демоны часто также являются серверами, принимающими запросы от клиентов для выполнения действий для них. Команда docker - это клиент, а демон Docker выступает в качестве сервера, выполняющего обработку ваших контейнеров и образов Docker.

По умолчанию демон docker прослушивает UNIX-сокет docker.sock. Если у вас есть вариант использования удаленного доступа к API-интерфейсу Docker, вам необходимо предоставить его через порт хоста. Одним из таких вариантов использования является запуск Docker в качестве агентов Jenkins.

### 3.2 Docker Client

Клиент Docker - самый простой компонент в архитектуре Docker. Это то, что запускается при вводе таких команд, как docker run или docker pull на компьютере. Его задача - взаимодействовать с демоном Docker посредством HTTP-запросов.

### 3.3 Образы Docker

Образ - это шаблон, по которому создают контейнеры. Его часто сравнивают со слоёным пирогом: мы накладываем слой файловой системы поверх слоя базового образа и получаем неизменяемый образ. В него можно установить приложение, конфигурации и зависимости. Другие образы могут наследоваться, поэтому если положить сверху слой файлов и закоммитить, то мы получим ещё один неизменяемый образ.

```bash
# Создать образ из Dockerfile
docker build -t image_name path_to_dockerfile

# Список локальных образов
# Или: docker image ls
docker images

# Запулить образ из DockerHub
docker pull image_name:tag

# Удалить локальный образ
# Или: docker rmi container_id
docker rmi image_name:tag

# Тегнуть образ
docker tag source_image:tag new_image:tag

# Закинуть образ в DockerHub
docker push image_name:tag

# Детали образа
docker image inspect image_name:tag

# Сохранить образ в архив
docker save -o image_name.tar image_name:tag

# Загрузить образ из архива
docker load -i image_name.tar

# Удалить не используемые образы
docker image prune

# Загрузка репозитория в tar
docker image load --input ubuntu.tar

# Сохранение образа в tar-архив
docker image save busybox > ubuntu.tar
```

### 3.4 Контейнеры Docker

Контейнер - это runtime-сущность на основе образа, приложение, которое мы развернули с помощью Docker. Можно провести такую аналогию: образ - это инсталлятор программы, а контейнер - уже запущенная программа. При развёртывании контейнера поверх файловой системы создаётся ещё один изменяемый слой. Приложение внутри контейнера может записывать туда данные или редактировать их. После удаления контейнера данные стираются, но их можно сохранить с помощью volumes.

```bash
# Запустить контейнер с именем из образа
docker run --name container_name image_name:tag

# Список всех контейнеров
docker ps -a

# Внутрь контейнера
docker exec -it container_name_or_id /bin/bash

# Статистика контейнера
docker stats container_name_or_id

# Остановить запущенный контейнер
docker stop container_name_or_id

# Запустить остановленный контейнер
docker start container_name_or_id

# Удалить запущенный контейнер
docker rm -f container_name_or_id

# Детали контейнера
docker inspect container_name_or_id

# Логи контейнера
docker logs container_name_or_id

# Поставить на паузу запущенный контейнер
docker pause container_name_or_id

# Поставить на плей запущенный контейнер
docker unpause container_name_or_id

# Создание контейнера
docker container create -t -i eon01/infinite --name infinite

# Переименование контейнера
docker container rename infinite infinity

# Обновление контейнера
docker container update --cpu-shares 512 -m 300M infinite
```

### 3.5 Docker Registers

Реестр Docker позволяет нескольким пользователям размещать и извлекать образы из центрального хранилища, используя RESTful API. Код реестра, как и сам Docker, – это ПО с открытым исходным кодом. Многие компании создают частные реестры для внутреннего хранения и совместного использования своих собственных образов.

По умолчанию при установке Docker он ищет образы в Docker Hub, если вы не укажете собственный реестр в настройках Docker.

```bash
# Вход в регистр
docker login localhost:5000

# Выход из реестра
docker logout localhost:5000
```
- Вход/Выход из реестра

```bash
docker search nginx
docker search --filter stars=3 --no-trunc nginx
```
- Поиск образа в реестре

```bash
docker run --name my-registry -p 5000:5000 -d --restart always registry:2
```
- Создаем контейнер, который будет являться приватным реестром

```bash
docker image tag image localhost:5000/image
```
- Меняем тег образов, которые будем закидывать в реестр

```bash
# Загрузка образа в реестр
docker push localhost:5000/image

# Выгрузка образа из реестра
docker pull localhost:5000/nginx
```
- Загрузка/Выгрузка образа из реестра

```bash
curl -X GET localhost:5000/v2/_catalog
```
- Смотрим какие образы есть в частном реестре


### 3.6 Docker Hub

Docker Hub - это реестр, поддерживаемый Docker Inc. Он содержит десятки тысяч образов, готовых к загрузке и запуску. Любой пользователь Docker может создать бесплатную учетную запись и хранить там общедоступные образы Docker. В дополнение к предоставленным пользователями официальные образы поддерживаются для справочных целей.

Ваши образы защищены аутентификацией пользователя, и существует звездная система популярности, похожая на ту, что есть в GitHub. Официальные образы могут быть представлениями дистрибутивов Linux, таких как Ubuntu или CentOS, предустановленными пакетами программного обеспечения, такими как Node.js, или целыми программными стеками, такими как WordPress.

Другие пользователи Docker Hub смогут получить доступ ко всем вашим образам, если ваш репозиторий является общедоступным. Вы также можете создать частный реестр в Docker Hub.

## 4 Хранение данных

Одной из основных отличительных черт контейнеров считается эфемерность. Это значит, то что контейнеры могут быть остановлены, перезапущены или ликвидированы в любой период времени. В данном случае вся без исключения собранная в контейнере информация будет утрачена. Таким образом, приложения обязаны быть спроектированы таким способом, чтобы они никак не полагались на сохранение сведений в контейнере, данное зовется принципом без сохранения состояния (Stateless).

Это хорошо для приложений или сервисов, которые не сохраняют результаты своей работы. Например, функции для вычисления или преобразования данных: они получили один набор данных в качестве входных данных, они преобразовали его или вычислили и вернули результат. Вот и все, вам не нужно ничего нигде сохранять.

Но не все приложения такие, и нужно сохранять много данных. Контейнеры предоставляют несколько способов сделать: volumes, bind mount, tmpfs mount.

Независимо от того, какой тип монтирования вы выберете, данные внутри контейнера будут выглядеть одинаково. Он предоставляется либо как каталог, либо как отдельный файл в файловой системе контейнера.

Простой способ визуализировать разницу между volumes (тома), bind mount (монтирование с привязкой) и tmpfs mount - это подумать о том, где находятся данные на хосте Docker.

Тома хранятся в части файловой системы хоста, которая управляется Docker (/var/lib/docker/volumes/ в Linux). Процессы, не относящиеся к Docker, не должны изменять эту часть файловой системы. Тома - лучший способ сохранить данные в Docker.

При монтировании с привязкой данные могут храниться где угодно в хост-системе. Это могут быть даже важные системные файлы или каталоги. Не-Docker-процессы на хосте Docker или в контейнере Docker могут изменить их в любое время.

Монтирования tmpfs хранятся только в оперативной памяти хост-системы и никогда не записываются в файловую систему хост-системы.

### 4.1 Docker volumes

Тома являются предпочтительным способом сохранения данных, созданных и использованных контейнерами docker. Хотя монтирование зависит от структуры каталогов и операционной системы хост-компьютера, тома полностью контролируются docker. У томов есть несколько преимуществ по сравнению с монтированием:

- Тома легче резервировать и мигрировать, чем монтирование.
- Управление томами возможно с помощью команд docker CLI или docker API.
- Тома работают как с контейнерами Linux, так и с Windows.
- Возможность безопасного распределения томов между несколькими контейнерами.
- Драйверы томов позволяют хранить тома на удаленных хостах или у облачных провайдеров, шифровать содержимое и добавлять другие функции.
- Новые тома могут быть предварительно заполнены контейнером.
- Тома на Docker Desktop обладают значительно высокой производительностью по сравнению с монтированием на Mac и Windows.
- Тома часто являются лучшим выбором для сохранения данных, поскольку они не увеличивают размер контейнеров, использующих их, и содержимое тома существует вне жизненного цикла конкретного контейнера.

Если контейнер генерирует непостоянные данные о состоянии, рекомендуется использовать монтирование tmpfs, чтобы избежать постоянного хранения данных и повысить производительность контейнера, избегая записи в доступный для записи слой контейнера.

```bash
# Create a named volume
docker volume create volume_name
# List of all volumes
docker volume ls
# Inspect details of a volume
docker volume inspect volume_name
# Remove a volume
docker volume rm volume_name
# Run a container with a volume (mount)
docker run --name container_name -v volume_name:/path/in/container image_name:tag
# Copy files between a container and a volume
docker cp local_file_or_directory container_name:/path/in/container
```

### 4.2 Bind mount

Монтирование с привязкой существуют с первых дней существования Docker. Этот способ организации файловой системы контейнера имеет ограниченную функциональность по сравнению с томами. При использовании монтирования с привязкой файл или каталог на хост-компьютере монтируется в контейнер. На файл или каталог ссылаются по его абсолютному пути на хост-компьютере. Напротив, когда вы используете том, в каталоге хранилища Docker на хост-компьютере создается новый каталог, и Docker управляет содержимым этого каталога.

Файл или каталог не обязательно должен уже существовать на хосте Docker. Он создается по требованию, если он еще не существует. Монтирование с привязкой очень эффективно, но оно зависит от наличия в файловой системе хост-компьютера определенной структуры каталогов. Если вы разрабатываете новые приложения Docker, рассмотрите возможность использования вместо них именованных томов. Вы не можете использовать команды Docker CLI для прямого управления данными при монтировании с привязкой.

### 4.3 Tmpfs mount

Тома и монтирования с привязкой позволяют обмениваться файлами между хост-компьютером и контейнером, чтобы вы могли сохранять данные даже после остановки контейнера.

Если вы используете Docker в Linux, у вас есть третий вариант: монтирование tmpfs. Когда вы создаете контейнер с монтированием tmpfs, контейнер может создавать файлы вне доступного для записи слоя контейнера.

В отличие от томов и монтирования с привязкой, монтирование tmpfs является временным и сохраняется только в оперативной памяти хоста. Когда контейнер останавливается, монтирование tmpfs удаляется, и записанные в него файлы не сохраняются.

Это полезно для временного хранения конфиденциальных файлов, которые вы не хотите сохранять ни на хосте, ни на доступном для записи уровне контейнера.

Ограничения tmpfs монтирования:

- В отличии от томов и монтирования с привязкой, монтирование tmpfs не позволяет установить одну точку крепления для разных контейнеров.
- Доступно только в том случае, если вы используете Docker на Linux.
- Неаккуратная установка прав доступа к tmpfs может привести к очистке информации после перезапуска контейнера.

## 5 Сети

Под сетью контейнеров подразумевается способность контейнеров подключаться и взаимодействовать друг с другом или с рабочими нагрузками, не относящимися к Docker.

В контейнерах по умолчанию включена сеть, и они могут устанавливать исходящие соединения. Контейнер не имеет информации о том, к какому типу сети он подключен, а также о том, являются ли его одноранговые узлы также рабочими нагрузками Docker или нет. Контейнер видит только сетевой интерфейс с IP-адресом, шлюзом, таблицей маршрутизации, службами DNS и другими сетевыми деталями. Только контейнер не использует сетевой драйвер none.

Можно создавать собственные пользовательские сети и подключать несколько контейнеров к одной сети. После подключения к определяемой пользователем сети контейнеры могут взаимодействовать друг с другом, используя IP-адреса контейнеров или имена контейнеров.

```bash
# Run a container with a port mapping
docker run --name container_name -p host_port:container_port image_name
# List all networks
docker network ls
# Inspect details of a network
docker network inspect network_name
# Create a user-defined bridge network
docker network create network_name
# Remove a network
docker network rm network_name
# Connect a container to a network
docker network connect network_name container_name
# Disconnect a container from a network
docker network disconnect network_name container_name
```

### 5.1 Сетевые драйверы

Сетевая подсистема Docker основывается на использовании

⭐ **Bridge network driver**

С точки зрения сети мостовая сеть представляет собой устройство канального уровня, которое перенаправляет трафик между сегментами сети. Мост может быть аппаратным или программным устройством, работающим в ядре хост-машины.

С точки зрения Docker, мостовая сеть использует программный мост, который позволяет контейнерам, подключенным к одной и той же мостовой сети, взаимодействовать, обеспечивая при этом изоляцию от контейнеров, которые не подключены к этой мостовой сети. Драйвер моста Docker автоматически устанавливает правила на хост-компьютере, чтобы контейнеры в разных сетях мостов не могли напрямую взаимодействовать друг с другом.

Сети мостов применяются к контейнерам, работающим на одном хосте демона Docker. Для связи между контейнерами, работающими на разных хостах демона Docker, можно управлять маршрутизацией на уровне ОС или использовать оверлейную сеть.

При запуске Docker, сеть мостов по умолчанию (также называемая мостом) создается автоматически, и вновь запущенные контейнеры подключаются к ней, если не указано иное. Можно создавать пользовательские сети мостов. Мостовые сети, определяемые пользователем, превосходят мостовую сеть по умолчанию.

**Различия между определяемыми пользователем мостами и мостом по умолчанию**

- Пользовательские мосты обеспечивают автоматическое разрешение DNS между контейнерами. Контейнеры в мостовой сети по умолчанию могут обращаться друг к другу только по IP-адресам, если только вы не используете опцию --link, которая считается устаревшей. В определяемой пользователем мостовой сети контейнеры могут разрешать друг друга по имени или псевдониму.
- Пользовательские мосты обеспечивают лучшую изоляцию. Все контейнеры подключаются к мостовой сети по умолчанию. Это может быть рискованно, поскольку несвязанные стеки/сервисы/контейнеры могут взаимодействовать друг с другом.
- Каждая определяемая пользователем сеть создает настраиваемый мост. Если ваши контейнеры используют мостовую сеть по умолчанию, вы можете настроить ее, но все контейнеры будут использовать одни и те же настройки, такие как MTU и правила iptables. Кроме того, настройка мостовой сети по умолчанию происходит вне самого Docker и требует перезапуска Docker.

⭐ **Overlay network driver**

Драйвер оверлейной сети создает распределенную сеть между несколькими хостами демона Docker. Эта сеть располагается поверх (перекрывает) сетей, специфичных для хоста, позволяя контейнерам, подключенным к ней, безопасно взаимодействовать при включенном шифровании. Docker прозрачно обрабатывает маршрутизацию каждого пакета к правильному хосту демона Docker и к правильному контейнеру назначения и обратно.

Вы можете создавать пользовательские оверлейные сети точно так же, как вы можете создавать пользовательские мостовые сети. Сервисы или контейнеры могут быть подключены к более чем одной сети одновременно. Службы или контейнеры могут взаимодействовать только между сетями, к которым каждый из них подключен.

Оверлейные сети часто используются для создания соединения между сервисами Swarm, но вы также можете использовать их для подключения автономных контейнеров, работающих на разных хостах. При использовании автономных контейнеров по-прежнему необходимо использовать режим Swarm для установления соединения между хостами.

⭐ **Host network driver**

Если вы используете режим сети хоста для контейнера, сетевой стек этого контейнера не изолирован от хоста Docker (контейнер использует сетевое пространство имен хоста), и контейнеру не выделяется собственный IP-адрес. Например, если вы запускаете контейнер, который привязывается к порту 80, и используете сеть хоста, приложение контейнера будет доступно через порт 80 по IP-адресу хоста.

⭐ **IPvlan network driver**

Драйвер IPvlan предоставляет пользователям полный контроль над адресацией IPv4 и IPv6. Драйвер VLAN построен на основе этого, предоставляя операторам полный контроль над маркировкой VLAN уровня 2 и даже маршрутизацией IPvlan L3 для пользователей, заинтересованных в базовой сетевой интеграции. Для развертываний наложения, которые абстрагируют физические ограничения, см. драйвер наложения с несколькими хостами.

IPvlan - это новый поворот в проверенной и надежной технике виртуализации сети. Реализации Linux чрезвычайно легки, поскольку вместо использования традиционного моста Linux для изоляции они связаны с интерфейсом или субинтерфейсом Ethernet Linux для обеспечения разделения между сетями и подключения к физической сети.

IPvlan предлагает ряд уникальных функций и много возможностей для дальнейших инноваций в различных режимах. Двумя преимуществами этих подходов являются положительное влияние на производительность при обходе моста Linux и простота использования меньшего количества движущихся частей. Удаление моста, который традиционно находится между сетевым адаптером хоста Docker и интерфейсом контейнера, оставляет простую настройку, состоящую из интерфейсов контейнера, подключенных непосредственно к интерфейсу хоста Docker. К этому результату легко получить доступ для внешних служб, поскольку в этих сценариях нет необходимости в сопоставлении портов.

⭐ **Macvlan network driver**

Некоторые приложения, особенно устаревшие приложения или приложения, отслеживающие сетевой трафик, ожидают прямого подключения к физической сети. В такой ситуации вы можете использовать сетевой драйвер macvlan, чтобы назначить MAC-адрес виртуальному сетевому интерфейсу каждого контейнера, делая его похожим на физический сетевой интерфейс, напрямую подключенный к физической сети. В этом случае вам необходимо назначить физический интерфейс на вашем хосте Docker, который будет использоваться для Macvlan, а также подсеть и шлюз сети. Вы даже можете изолировать свои сети Macvlan, используя разные физические сетевые интерфейсы.

Имейте в виду следующее:

- Вы можете непреднамеренно ухудшить качество своей сети из-за нехватки IP-адресов или «распространения VLAN» - ситуация, которая возникает, когда в вашей сети имеется недопустимо большое количество уникальных MAC-адресов.
- Ваше сетевое оборудование должно поддерживать «неразборчивый режим», когда одному физическому интерфейсу может быть назначено несколько MAC-адресов.
- Если ваше приложение может работать с использованием моста (на одном хосте Docker) или оверлея (для взаимодействия между несколькими хостами Docker), эти решения могут быть лучше в долгосрочной перспективе.
- None network driver.

Если вы хотите полностью изолировать сетевой стек контейнера, вы можете использовать флаг `--network none` при запуске контейнера. Внутри контейнера создается только устройство обратной связи (loopback interface).


⭐⭐ **Сравнение сетевых драйверов**

- Мостовая сеть по умолчанию хороша для запуска контейнеров, которым не требуются специальные сетевые возможности.
- Пользовательские мостовые сети позволяют контейнерам на одном хосте Docker взаимодействовать друг с другом. Пользовательская сеть обычно определяет изолированную сеть для нескольких контейнеров, принадлежащих общему проекту или компоненту.
- Хост-сеть разделяет сеть хоста с контейнером. Когда вы используете этот драйвер, сеть контейнера не изолирована от хоста.
- Оверлейные сети лучше всего подходят, когда вам нужны контейнеры, работающие на разных хостах Docker, для связи или когда несколько приложений работают вместе с помощью сервисов Swarm.
- Сети Macvlan лучше всего подходят, когда вы переходите с установки виртуальной машины или хотите, чтобы ваши контейнеры выглядели как физические хосты в вашей сети, каждый из которых имеет уникальный MAC-адрес.
- IPvlan похож на Macvlan, но не назначает контейнерам уникальные MAC-адреса. Рассмотрите возможность использования IPvlan, когда существует ограничение на количество MAC-адресов, которые можно назначить сетевому интерфейсу или порту.

### 5.2 Проброс портов

Под публикацией портов стоит понимать тот случай, когда необходимо позволить к приложению, запущенному в контейнере Docker, подключаться извне.

По умолчанию, когда вы создаете или запускаете контейнер с помощью `docker create` или `docker run`, контейнер не раскрывает ни один из своих портов внешнему миру. Флаг `--publish` или `-p` позволяет сделать порт доступным для служб за пределами Docker. Это создает правило брандмауэра на хосте, сопоставляющее порт контейнера порту хоста Docker с внешним миром.

Публикация портов контейнеров по умолчанию небезопасна. Это означает, что когда вы публикуете порты контейнера, он становится доступен не только хосту Docker, но и внешнему миру.

Вот некоторые примеры:

```
-p 8080:80
```
- Сопоставление порта 8080 на хосте Docker с TCP-портом 80 в контейнере.
```
-p 192.168.1.100:8080:80
```
- Сопоставление порта 8080 на IP-адресе хоста Docker 192.168.1.100 с TCP-портом 80 в контейнере.
```
-p 8080:80/udp
```
- Сопоставление порта 8080 на хосте Docker с портом UDP 80 в контейнере.
```
-p 8080:80/tcp -p 8080:80/udp
```
- Сопоставление порта TCP 8080 на хосте Docker с портом TCP 80 в контейнере и сопоставление порта UDP 8080 на хосте Docker с портом UDP 80 в контейнере.

```bash
docker run -p 127.0.0.1:8080:80 nginx
```
- Если включить IP-адрес локального хоста (127.0.0.1) в флаг публикации, только хост Docker сможет получить доступ к порту опубликованного контейнера.

### 5.3 Сервисы DNS

По умолчанию контейнеры наследуют настройки DNS, определенные в файле конфигурации /etc/resolv.conf. Контейнеры, подключающиеся к мостовой сети по умолчанию, получают копию этого файла. Контейнеры, подключаемые к пользовательской сети, используют встроенный DNS-сервер Docker. Встроенный DNS-сервер перенаправляет внешние запросы DNS на DNS-серверы, настроенные на хосте.

Вы можете настроить разрешение DNS для каждого контейнера, используя флаги для команды `docker run` или `docker create`, используемой для запуска контейнера.

| Флаг         | Описание                                                                                                                                                                                                                                                                                         |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| --dns        | IP-адрес DNS-сервера. Чтобы указать несколько DNS-серверов, используйте несколько флагов --dns. Если контейнер не может связаться ни с одним из указанных вами IP-адресов, он использует общедоступный DNS-сервер Google по адресу 8.8.8.8. Это позволяет контейнерам разрешать интернет-домены. |
| --dns-search | Домен поиска DNS для поиска неполных имен хостов. Чтобы указать несколько префиксов поиска DNS, используйте несколько флагов --dns-search.                                                                                                                                                       |
| --dns-opt    | Пара ключ-значение, представляющая параметр DNS и его значение. Допустимые параметры смотрите в документации вашей операционной системы для resolv.conf.                                                                                                                                         |
| --hostname   | Имя хоста, которое контейнер использует для себя. По умолчанию используется идентификатор контейнера, если он не указан.                                                                                                                                                                         |

### 5.4 Фильтрация пакетов и межсетевые экраны

В Linux Docker манипулирует правилами iptables для обеспечения сетевой изоляции. Хотя это деталь реализации, и вам не следует изменять правила, которые Docker вставляет в ваши политики iptables, это имеет некоторые последствия для того, что вам нужно делать, если вы хотите иметь свои собственные политики в дополнение к тем, которые управляются Docker.

Если вы используете Docker на хосте, подключенном к Интернету, вам, вероятно, понадобится политика iptables, предотвращающая несанкционированный доступ к контейнерам или другим службам, работающим на вашем хосте.

Docker устанавливает две собственные цепочки iptables с именами DOCKER-USER и DOCKER и гарантирует, что входящие пакеты всегда сначала проверяются этими двумя цепочками. Эти сети являются частью сети FORWARD.

Все правила iptables Docker добавляются в цепочку DOCKER. Не изменяйте эту цепочку вручную. Если вам нужно добавить правила, которые загружаются раньше правил Docker, добавьте их в цепочку DOCKER-USER. Эти правила применяются до того, как Docker автоматически создаст какие-либо правила.

Другие правила, добавленные в цепочку FORWARD вручную или с помощью другого брандмауэра на основе iptables, оцениваются после цепочек DOCKER-USER и DOCKER. Это означает, что если вы публикуете порт через Docker, этот порт будет проброшен независимо от того, какие правила настроены в вашем брандмауэре. Если вы хотите, чтобы правила применялись даже при публикации порта через Docker, вам необходимо добавить эти правила в цепочку DOCKER-USER.

Когда пакеты поступают в цепочку DOCKER-USER, они уже прошли фильтр трансляции сетевых адресов назначения (DNAT). Это означает, что используемые вами флаги iptables могут соответствовать только внутренним IP-адресам и портам контейнеров.

## 6 Dockerfile

Dockerfile - это простой текстовый файл, в котором содержится список команд Докер-клиента. Это простой способ автоматизировать процесс создания образа. Команды в Dockerfile почти идентичны своим аналогам в Linux.

Инструкции Dockerfile

```dockerfile
# Базовый образ
FROM image_name:tag

# Активный рабочий каталог. Все последующие команды (COPY, RUN, CMD и др) будут выполнены из этого каталога
WORKDIR /path/to/directory

# Копирует в контейнер файлы и папки
COPY host_source_path container_destination_path

# Выполнение команд. Используется для установки в контейнер пакетов. Может быть неограниченное кол-во, но каждая инструкция создает свой слой. Для выполнения цепочки команд рекомендуется использовать &&
RUN command1 && command2

# Установка постоянных переменных среды
ENV KEY=VALUE

# Информирование о том, какие порты могут быть использованы приложением внутри контейнера
EXPOSE port

# Финальной инструкцией в любом Dockerfile является CMD или ENTRYPOINT. CMD может быть только одна и она может быть переопределена при старте контейнера командой docker run. Инструкция CMD наследует условия установленные инструкцией WORKDIR
CMD [“executable”, “param1”, “param2”]

# Команда с аргументами для вызова при старте контейнера. Отличается от CMD тем, что аргументы не переопределяются. Может использоваться вместе с CMD
ENTRYPOINT [“executable”, “param1”, “param2”]

# Задаёт переменные для передачи Docker во время сборки образа
ARG VARIABLE_NAME=default_value

# Создаёт точку монтирования для работы с постоянным хранилищем
VOLUME /path/to/volume

# Метаданные. Например сведения о том, кто создал образ
LABEL key=”value”

# Указание пользователя, под которым будут выполняться команды внутри контейнера
USER user_name

# Копирует файлы и папки в контейнер, может распаковывать .tar-файлы и загружать данные из URL
ADD source_path destination_path

# Команда для проверки работы контейнера во время его работы
HEALTHCHECK options

# Указание контактов. Лучше использовать LABEL
MAINTAINER name

# Команды, которые будут выполнены в дочерних образах, созданных на основе текущего образа
ONBUILD instruction

# Указание командой оболочки, которая будет использоваться для выполнения команд из Dockerfile
SHELL [“/bin/bash”, “-c”]

# Указание сигнала, который будет отправлен контейнеру для его остановки
STOPSIGNAL signal
```

**ПРИМЕР ИСПОЛЬЗОВАНИЯ DOCKERFILE**

Создадим Docker контейнер в качестве сервера «хостинга файлов» при передаче определенных файлов на целевые системы. Поэтому создадим Dockerfile на основе Ubuntu с работающим сервером Apache и SSH. Благодаря этому мы можем использовать scp для передачи файлов в образ Docker, а Apache позволяет нам размещать файлы и использовать такие инструменты, как Curl, wget и другие, в целевой системе для загрузки необходимых файлов.

```bash
FROM ubuntu:latest

RUN apt-get update && \
    apt-get install -y \
        apache2 \
        openssh-server \
        && \
    rm -rf /var/lib/apt/lists/*

RUN useradd -m docker-user && \
    echo "docker-user:password" | chpasswd

RUN chown -R docker-user:docker-user /var/www/html && \
    chown -R docker-user:docker-user /var/run/apache2 && \
    chown -R docker-user:docker-user /var/log/apache2 && \
    chown -R docker-user:docker-user /var/lock/apache2 && \
    usermod -aG sudo docker-user && \
    echo "docker-user ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers

EXPOSE 22 80

CMD service ssh start && /usr/sbin/apache2ctl -D FOREGROUND
```

После того, как _Dockerfile_ определен, нужно преобразовать его в _image_. С помощью команды _build_ берем каталог с _Dockerfile_, выполняем шаги из _Dockerfile_ и сохраняем _image_ в нашем локальном _Docker Engine_. Если один из шагов завершится неудачно из-за ошибки, создание контейнера будет прервано.

```bash
docker build .
```

После создания _image_ его можно выполнить с помощью _Docker Engine_, что делает его очень эффективным и простым способом запуска контейнера. _Image_ является шаблоном только для чтения и предоставляет файловую систему, необходимую для выполнения и всех параметров. Контейнер можно считать запущенным процессом образа. Когда контейнер должен быть запущен в системе, сначала загружается пакет с соответствующим образом, если он недоступен локально.

```bash
# Создание образа
docker run -p 8022:22 -p 8080:80 image_name
```

Запущен новый контейнер из образа _image\_name_ и сопоставлены порты хоста 22 и 8080 с портами контейнера 22 и 80 соответственно. Контейнер работает в фоновом режиме, что позволяет нам получать доступ к службам SSH и HTTP внутри контейнера, используя указанные порты хоста.

## 7 Docker compose

Docker Compose - это инструмент для определения и запуска многоконтейнерных приложений. Это ключ к упрощению и эффективности разработки и развертывания.

Compose упрощает управление всем стеком приложений, упрощая управление службами, сетями и томами в одном понятном файле конфигурации YAML. Затем с помощью одной команды вы создаете и запускаете все службы из вашего файла конфигурации.

Сочинение работает во всех средах; производство, постановка, разработка, тестирование, а также рабочие процессы CI. Он также имеет команды для управления всем жизненным циклом вашего приложения:

- Запуск, остановка и восстановление служб
- Просмотр состояния запущенных служб
- Потоковая передача данных журнала запущенных служб
- Запуск одноразовой команды для службы

```bash
# Create and start containers defined in a docker-compose.yml file. This command reads the docker-compose.yml file and starts the defined services in the background.
docker compose up

# Stop and remove containers defined in a docker-compose.yml file. This command stops and removes the containers, networks and volumes defined in the .yml file.
docker compose down

# Build or rebuild services. This command builds or rebuilds the Docker images for the services defined in the docker-compose.yml file.
docker compose build

# List containers for a specific Docker Compose project. This command lists the containers for the services defined in the docker-compose.yml file.
docker compose ps

# View logs for services. This command shows the logs for all services defined in the docker-compose.yml file.
docker compose logs

# Scale services to a specific number of containers
docker compose up -d --scale service_name=number_of_containers

# Run a one-time command in a service
docker compose run service_name command

# List all volumes. Docker Compose creates volumes for services. This command shows it
docker volume ls

# Pause a service. This command pauses the specified service
docker volume pause service_name

# Unpause a service
docker volume unpause service_name

# View details of a service
docker compose ps service_name
```

```dockercompose
# Specifies the version of the Docker Compose file format.
version: ‘3.8’

# Defines the services/containers that make up the application
services:
	web:
		image: nginx:latest

# Configures custom networks for the application
networks:
	my_network:
		driver: bridge

# Defines named volumes that the services can use
volumes:
	my_volume:

# Sets environment variables for a service
environment:
	- NODE_ENV=production

# Maps host ports to container ports
ports:
	- “8080:80”

# Specifies dependencies between services, ensuring one service starts before another
depends_on:
	- db

# Configures the build context and Dockerfile for a service
build:
	context: .
	dockerfile: Dockerfile.dev

# Mounts volumes from another service or container
volumes_from:
	- service_name

# Overrides the default command specified in the Docker image.
command: [“npm”, “start”]
```

## 8 Практика

### Основные команды

```bash
# Версия Docker
docker --version

# Очистка всех ресурсов – образы, контейнеры, volumes, networks
docker system prune

# Инициализация Docker внутри приложения
docker init

# Посмотреть сервис/контейнер приложения
docker compose watch
```
- Основные команды

### Docker + Django + PostgreSQL

Dockerfile

```dockerfile
FROM python:3.12.3-alpine3.19

COPY requirements.txt /temp/requirements.txt
COPY service /service
WORKDIR /service
EXPOSE 8000

RUN apk add postgresql-client build-base postgresql-dev
RUN pip install -r /temp/requirements.txt
RUN adduser --disabled-password service-user

USER service-user
```

Docker-compose.yml

```yml
services:
	web-app:
		build:
		context: .
		ports:
			- "8000:8000"
		volumes:
			- ./service:/service
		environment:
			- DB_HOST=database
			- DB_NAME=dbname
			- DB_USER=dbuser
			- DB_PASS=pwd
		command: >
			sh -c "python manage.py runserver 0.0.0.0:8000"
		depends_on:
			- database
	database:
		image: postgres:16.2-alpine
		environment:
			- POSTGRES_DB=dbname
			- POSTGRES_USER=dbuser
			- POSTGRES_PASSWORD=pwd
```

Далее переходим в каталог с докер файлами, создаем там директорию service/ и запускаем контейнер:

```bash
docker-compose build
docker-compose up
docker-compose run --rm sh -c "python manage.py migrate"
```

### MariaDB & Apache

```yml
version: '3'
services:
	web:
		build:
			context: ./html
			dockerfile: Dockerfile
		ports:
			- "8080:80"
		environment:
			- DATABASE_HOST=db
			- DATABASE_PORT=3306
			- DATABASE_NAME=first
			- DATABASE_USER=root
			- DATABASE_PASSWORD=1
		volumes:
			- ./html:/var/www/html
			- db_data:/var/lib/mysql
		depends_on:
			- db
		networks:
			custom_network:
				ipv4_address: 172.20.0.22
	db:
		image: mariadb
		environment:
			MYSQL_DATABASE: first
			MYSQL_USER: root
			MYSQL_PASSWORD: 1
			MYSQL_ROOT_PASSWORD: 1
		volumes:
			- db_data:/var/lib/mysql
		networks:
			custom_network:
				ipv4_address: 172.20.0.23

volumes:
	db_data: {}

networks:
	custom_network:
		driver: bridge
		ipam:
			config:
				- subnet: 172.20.0.0/16
```