# Docker

## 1 Что такое Docker?

**Docker** - это не только средство с открытым исходным кодом для запуска контейнеров, но и набор инструментов и механизмов для сборки, хранения и распространения образов. В Docker удобный интерфейс и CLI для работы с образами и контейнерами.

Две основные технологии - Docker Engine и Docker Desktop.

**Docker Engine** - это основной дистрибутив Docker для создания, запуска и управления контейнерами Docker. Включает Docker daemon и Docker CLI. При установе Docker CE (Community Edition) или Docker EE (Enterprise Edition) на Linux, происходит установка Docker Engine.

**Docker Desktop** - это официальное приложение для упрощения разработки и тестирования контейнеров. Включает виртуальную машину Linux, на которой работает Docker Engine, чтобы поддерживать контейнеры на отличных от Linux платформах. Также включает в себя графический интерфейс. Docker Desktop добавляет к Docker Engine расширенную функциональность.

**УСТАНОВКА DOCKER**

```bash
curl -sSL https://get.docker.com | sh
sudo usermod -aG docker $(whoami)
exit
```
- Установка Docker на Linux.

**ПРИМЕНЕНИЕ**

- Сокращение времени разработки ПО;
- Изоляция приложений;
- Быстрое развертывание ПО на уровне ОС;
- Упрощение настройки инфраструктуры.

## 2 Технологии Docker

- **Union File Systems**

Docker использует «слоистые» файловые системы, такие как AUFS и OverlayFS, чтобы создавать легковесные и эффективные образы контейнеров. Это возможно благодаря тому, что они разделяют общие файлы между собой, экономя дисковое пространство.  
При этом OverlayFS является более современным, простым и быстродействующим решением по сравнению с AUFS. Для работы с OverlayFS Docker поддерживает два драйвера: оригинальный overlay и более современный и стабильный overlay2.

- **Seccomp**

Для повышения безопасности Docker использует seccomp (Secure Computing Mode). Эта технология ограничивает доступ контейнера к системным вызовам, что позволяет уменьшить поверхность атаки и предотвратить выполнение опасных операций.  
Например, из контейнера недоступен системный вызов `reboot`, что не позволяет контейнеру перезагрузить хост. Политики seccomp описываются в json-файлах и могут быть переданы параметром `--security-opt` при запуске docker-контейнера.

- **Capabilities**

Ядро Linux предоставляет разные возможности для выполнения привилегированных действий. Docker позволяет настраивать набор возможностей, доступных контейнеру для более тонкой настройки безопасности.  
Например, можно выдать контейнеру capability `SYS_BOOT`, чтобы он мог перезагрузить хостовую систему. Еще один хороший пример - это capability `NET_BIND_SERVICE`, которая добавляется по умолчанию и позволяет процессу слушать сетевые порты ниже 1024 без предоставления прочих root-прав. Capabilities могут быть разрешены или заблокированы посредством передачи параметров `--cap-add` или `--cap-drop` при запуске контейнера.

## 3 Компоненты

![](materials/images/devops/docker_components.png)
- Docker имеет клиент-серверную архитектуру. За все действия, связанные с контейнерами, отвечает Docker Daemon (dockerd) или сервер.

![](/materials/images/devops/docker_arch.png)
- Архитектура Docker.

### 3.1 Docker Host

**Docker Host** - это физическая или виртуальная машина с установленным Docker Engine, где выполняются контейнеры. Хост служит основой для запуска и управления контейнерами, предоставляя им необходимые ресурсы и среду выполнения.

### 3.2 Docker Daemon

**Dockerd** - это служба, которая отвечает на API-вызовы и управляет Docker-объектами: контейнерами, сетями, хранилищами, образами. 

Демон отправляет запросы в другие службы для отправки и получения образов, используя протокол HTTP. Сервер принимает запросы от клиента командной строки или любого, кто авторизован для подключения.

По умолчанию демон docker прослушивает UNIX-сокет docker.sock. Если есть вариант использования удаленного доступа к API-интерфейсу Docker, необходимо предоставить его через порт хоста. Одним из таких вариантов использования является запуск Docker в качестве агентов Jenkins.

Изначально dockerd был монолитным приложением, отвечающим за весь функционал Docker. Однако компания-разработчик планомерно разделяет Docker на отдельные компоненты, чтобы сформировать модульную платформу с возможностью заменять отдельные её составляющие. На данный момент Docker Engine состоит из трёх компонентов:

1. **dockerd**: демон Docker, интерфейс API и интерфейс командной строки Docker. Демон Docker (dockerd) работает постоянно как служба dockerd systemd. Он отвечает за создание образов докера.
2. **containerd**: среда выполнения контейнеров, но выделенная из Docker немногим позже runC. Она обеспечивает управление жизненным циклом контейнеров: запуском, остановкой и контролем. Containerd работает на основе спецификации OCI Runtime Specification и использует утилиту runC (или альтернативы) для запуска контейнеров.
3. **runC**: легковесная и универсальная среда выполнения контейнеров, разработанная для безопасности, масштабируемости и переносимости контейнерных технологий. В ней содержится весь код инфраструктуры, используемой Docker для взаимодействия с системными функциями, связанными с контейнерами. Поддерживает Linux namespaces, все функции безопасности Linux.

### 3.3 Docker Client

Клиент Docker - самый простой компонент в архитектуре Docker. Это то, что запускается при вводе таких команд, как docker run или docker pull на компьютере. Его задача - взаимодействовать с демоном Docker посредством HTTP-запросов.

Таким образом, Docker-клиент используется для получения информации или передачи инструкций демону.

Клиент Docker может находиться на том же хосте, что и демон, или присутствовать на любом другом хосте.

### 3.4 Docker Image

**Docker Image** - это неизменяемый шаблон для создания контейнеров, который включает код приложения, зависимости, конфигурацию, а также параметры окружения и команду для запуска основного процесса.

Образ можно сравнить со слоёным пирогом: мы накладываем слой файловой системы поверх слоя базового образа и получаем неизменяемый образ. В него можно установить приложение, конфигурации и зависимости. Другие образы могут наследоваться, поэтому если положить сверху слой файлов и закоммитить, то мы получим ещё один неизменяемый образ.

```bash
# Создать образ из Dockerfile
docker build -t image_name path_to_dockerfile

# Список локальных образов
# Или: docker image ls
docker images

# Запулить образ из DockerHub
docker pull image_name:tag

# Удалить локальный образ
# Или: docker rmi container_id
docker rmi image_name:tag

# Тегнуть образ
docker tag source_image:tag new_image:tag

# Закинуть образ в DockerHub
docker push image_name:tag

# Детали образа
docker image inspect image_name:tag

# Сохранить образ в архив
docker save -o image_name.tar image_name:tag

# Загрузить образ из архива
docker load -i image_name.tar

# Удалить не используемые образы
docker image prune

# Загрузка репозитория в tar
docker image load --input ubuntu.tar

# Сохранение образа в tar-архив
docker image save busybox > ubuntu.tar
```
- Управление образами.

### 3.5 Docker Container

**Docker Container** - это запущенный и готовый к использованию экземпляр образа.

Безопасность и стабильность процесса в контейнере обеспечивается изоляцией от остальной системы.

Разница между образом и контейнером в том, что образ предоставляет статический набор файлов, который может быть использован для создания множества контейнеров, тогда как контейнер - это динамическая сущность, которая представляет собой работающий экземпляр образа.

При развёртывании контейнера поверх файловой системы создаётся ещё один изменяемый слой. Приложение внутри контейнера может записывать туда данные или редактировать их. После удаления контейнера данные стираются, но их можно сохранить с помощью volumes.

**ЖИЗНЕННЫЙ ЦИКЛ КОНТЕЙНЕРА**

- Создание контейнера
- Работа контейнера
- Приостановка контейнера
- Возобновление работы контейнера
- Запуск контейнера
- Остановка контейнера
- Перезапуск контейнера
- Принудительная остановка контейнера
- Удаление контейнера

**СОСТОЯНИЯ КОНТЕЙНЕРА**

- CREATED
- RESTARTING
- RUNNING
- PAUSED
- EXISTED
- DEAD

```bash
# Запустить контейнер с именем из образа
docker run --name container_name image_name:tag

# Список всех контейнеров
docker ps -a

# Внутрь контейнера
docker exec -it container_name_or_id /bin/bash

# Статистика контейнера
docker stats container_name_or_id

# Остановить запущенный контейнер
docker stop container_name_or_id

# Запустить остановленный контейнер
docker start container_name_or_id

# Удалить запущенный контейнер
docker rm -f container_name_or_id

# Детали контейнера
docker inspect container_name_or_id

# Логи контейнера
docker logs container_name_or_id

# Поставить на паузу запущенный контейнер
docker pause container_name_or_id

# Поставить на плей запущенный контейнер
docker unpause container_name_or_id

# Создание контейнера
docker container create -t -i eon01/infinite --name infinite

# Переименование контейнера
docker container rename infinite infinity

# Обновление контейнера
docker container update --cpu-shares 512 -m 300M infinite
```

### 3.6 Docker Registy

**Docker Registry** - это централизованное хранилище, или реестр образов. С помощью него можно хранить и распространять образы контейнеров как внутри компании, так и глобально, а также управлять версиями образов.

Реестр Docker позволяет нескольким пользователям размещать и извлекать образы из центрального хранилища, используя RESTful API. Код реестра, как и сам Docker, - это ПО с открытым исходным кодом. Многие компании создают частные реестры для внутреннего хранения и совместного использования своих собственных образов.

Частный реестр Docker - это сервис, который хранит образы Docker. Их можно запросить у любого демона Docker, у которого есть соответствующий доступ. Этот реестр находится во внутренней сети и не является общедоступным, поэтому считается закрытым.

По умолчанию при установке Docker он ищет образы в Docker Hub, если не указать собственный реестр в настройках Docker.

Полное имя образа имеет следующий формат `[HOST[:PORT_NUMBER]/]PATH`.

HOST - это опциональное имя хоста Registry. Оно сообщает, где искать образы. Должно соответствовать стандартному формату DNS-имён, но не должно содержать `_`. Если не указать имя хоста, то по умолчанию будет использовано имя публичного Container Registry - `registry-1.docker.io`.

PATH - это путь, который состоит из разделённых знаком `/` компонентов. Каждый компонент может содержать буквы в нижнем регистре, цифры и разделители. Разделителем может служить:

```bash
# Вход в регистр
docker login localhost:5000

# Выход из реестра
docker logout localhost:5000
```
- Вход/Выход из реестра.

```bash
docker search nginx
docker search --filter stars=3 --no-trunc nginx
```
- Поиск образа в реестре.

```bash
docker run --name my-registry -p 5000:5000 -d --restart always registry:2
```
- Создание контейнера, который будет являться приватным реестром.

```bash
docker image tag image localhost:5000/image
```
- Меняем тег образов, которые будем закидывать в реестр.

```bash
# Загрузка образа в реестр
docker push localhost:5000/image

# Выгрузка образа из реестра
docker pull localhost:5000/nginx
```
- Загрузка/Выгрузка образа из реестра.

```bash
curl -X GET localhost:5000/v2/_catalog
```
- Смотрим какие образы есть в частном реестре.

### 3.7 Docker Hub

Docker Hub - это реестр, поддерживаемый Docker Inc. Он содержит десятки тысяч образов, готовых к загрузке и запуску. Любой пользователь Docker может создать бесплатную учетную запись и хранить там общедоступные образы Docker. В дополнение к предоставленным пользователями официальные образы поддерживаются для справочных целей.

Ваши образы защищены аутентификацией пользователя, и существует звездная система популярности, похожая на ту, что есть в GitHub. Официальные образы могут быть представлениями дистрибутивов Linux, таких как Ubuntu или CentOS, предустановленными пакетами программного обеспечения, такими как Node.js, или целыми программными стеками, такими как WordPress.

Другие пользователи Docker Hub смогут получить доступ ко всем вашим образам, если ваш репозиторий является общедоступным. Вы также можете создать частный реестр в Docker Hub.

### 3.8 Dockerfile

**Dockerfile** - это конфигурационный файл с инструкциями для сборки Docker-образа.

Инструкции `FROM`, `RUN`, `COPY` и `ADD` участвуют в создании слоёв итогового образа. Другие инструкции отвечают за настройку, описание метаданных и указание действий, которые должны выполняться во время работы контейнера. Они создают отдельные слои итогового образа, который содержит изменения файлов относительно предыдущего слоя. Инструкции `EXPOSE` и `CMD` видны в истории изменений образа как слои. Их размер - 0, потому что изменений файлов в таких слоях не происходит, но добавляются метаданные к образу.

Перезаписываемый слой может содержать временные файлы, создаваемые приложением во время работы в контейнере.

Если на базе одного и того же образа будут запущены несколько контейнеров, для каждого будет создан свой отдельный перезаписываемый слой. Базовый образ при этом остаётся в единственном экземпляре.

При удалении контейнера, этот перезаписываемый слой тоже удаляется. Однако исходный образ со всеми его слоями остаётся неизменным.

Финальной инструкцией в любом Dockerfile является `CMD` или `ENTRYPOINT`. `CMD` может быть только одна и она может быть переопределена при старте контейнера командой `docker run`. `CMD` наследует условия установленные инструкцией WORKDIR.

Чтобы создать базовый образ, не основываясь ни на каком другом, то в качестве базового образа следует указать образ `scratch`.

В Dockerfile должна быть указана хотя бы одна из команд `CMD` или `ENTRYPOINT`. Команду `CMD` следует использовать как способ определения аргументов по умолчанию для команды `ENTRYPOINT` или для выполнения специальной команды в контейнере, например, подгрузки и предобработки переменных среды.

Рекомендуется использовать абсолютные пути для исполняемых файлов. Например `/usr/bin/python` вместо `python`, так как переменная `$PATH` в большинстве случаев не подгружается по умолчанию.

```bash
docker run --command python cont_name
docker run cont_name python
```
Переопределить параметр, выполняемый при запуске контейнера, можно двумя способами.

```bash
docker run --env KEY1=VALUE1 -e KEY2=VALUE2 cont_name
```
- Изменение или добавление переменных среды во время запуска контейнера.

```bash
docker build --build-arg KEY=VALUE .
```
- Передача переменной  в инструкцию `ARG KEY` в сборку образа.

```dockerfile
# Базовый образ, с которого начинается сборка.
FROM image_name:tag

# Создает и устанавливает рабочий каталог. Все последующие команды будут выполнены из этого каталога.
WORKDIR /path/to/directory

# Копирует файлы из хоста в контейнер.
COPY host_source_path container_destination_path

# Добавляет локальные или удаленные файлы и каталоги. Может распаковывать .tar-файлы и загружать данные из URL.
ADD source_path destination_path

# Выполняет команды внутри контейнера во время сборки образа.
RUN command1 && command2

# Определение переменных окружения. Эти переменные могут быть использованы в последующих инструкциях Dockerfile, а также в контейнере, запущенном на основе созданного образа.
ENV KEY=VALUE
ENV KEY1=VALUE1 KEY2=VALUE2

# Информирование о том, какие порты могут быть использованы приложением внутри контейнера
EXPOSE port

# Используется в качестве аргументов для ENTRYPOINT. Итоговая команда запуска контейнера складывается из объединения инструкций ENTRYPOINT + CMD.
CMD [“executable”, “param1”, “param2”]

# Указывает команду, которая будет выполнена при запуске контейнера. Отличается от CMD тем, что аргументы не переопределяются. Значение по умолчанию - /bin/sh -c.
ENTRYPOINT [“executable”, “param1”, “param2”]

# Определение переменных на время сборки.
ARG VARIABLE_NAME=default_value

# Создаёт точку монтирования для работы с постоянным хранилищем
VOLUME /path/to/volume

# Метаданные. Например сведения о том, кто создал образ
LABEL key=”value”

# Указание пользователя, под которым будут выполняться команды внутри контейнера
USER user_name

# Команда для проверки работы контейнера во время его работы
HEALTHCHECK options

# Указание контактов. Лучше использовать LABEL
MAINTAINER name

# Команды, которые будут выполнены в дочерних образах, созданных на основе текущего образа
ONBUILD instruction

# Указание командой оболочки, которая будет использоваться для выполнения команд из Dockerfile
SHELL [“/bin/bash”, “-c”]

# Указание сигнала, который будет отправлен контейнеру для его остановки
STOPSIGNAL signal
```
- Инструкции Dockerfile.

```dockerfile
FROM ubuntu:22.04
RUN apt-get update && apt-get install -y nginx
COPY myapp /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"] 
```
- Создаем образ на основе Ubuntu 22.04, устанавливаем веб-сервер Nginx, копируем содержимое каталога `myapp` в каталог `/usr/share/nginx/html`, сообщаем, что процесс в запущенном контейнере будет слушать порт 80 и запускать сам процесс Nginx соответствующей командой.

```bash
docker build -t mynginx:latest
```
- Сборка образа `mynginx:latest`. Команда принимает директорию с набором файлов для сборки образа контейнера. Если явно не указывать расположение Dockerfile, то команда `docker build` будет пытаться найти файл с названием Dockerfile в директории контекста. Чтобы указать другое расположение Dockerfile, можно использовать опцию `-f /path/Dockerfile`.

```bash
docker run --name nginx-container -p 80:80 mynginx:latest
```
- Запуск контейнера `nginx-container` на основе созданного образа `mynginx:latest`. Он будет слушать порт `80` на хостовой системе. При запуске контейнера создаётся ещё один перезаписываемый слой, который будет содержать файлы, изменённые в контейнере относительно образа, на базе которого он запущен.

### 3.9 Docker CLI

**Docker CLI** - это консольная утилита, которая позволяет взаимодействовать с Docker daemon - отправлять ему команды, создавать и управлять Docker-объектами.

## 4 Хранение данных

Одной из основных отличительных черт контейнеров считается эфемерность. Это значит, то что контейнеры могут быть остановлены, перезапущены или ликвидированы в любой период времени. В данном случае вся без исключения собранная в контейнере информация будет утрачена. Таким образом, приложения обязаны быть спроектированы таким способом, чтобы они никак не полагались на сохранение сведений в контейнере, данное зовется принципом без сохранения состояния (Stateless). Это хорошо для приложений или сервисов, которые не сохраняют результаты своей работы. Но не все приложения такие, и нужно сохранять много данных.

Docker использует **Storage drivers** для управления содержимым слоев образов и перезаписываемых слоев контейнеров. Они имеют различную реализацию, однако все используют стекирование слоев и стратегию Copy-on-write.

**Overlay2** - самый популярный Storage Driver, поддерживаемый Docker. Docker-драйвер **overlay2** под капотом использует файловую систему OverlayFS.

**OverlayFS** - это файловая система Linux. Она объединяет несколько слоёв в единую файловую систему, управляет ими и сохраняет историю изменений в виде слоёв. Образ в Docker это упакованный набор слоев.

**Принципы работы OverlayFS**

- Каждый раз, при выполнении инструкции сборки Dockerfile, которая модифицирует файлы создаётся новый слой OverlayFS.
- Каждый слой - это набор различий с предыдущим слоем.
- Если несколько образов используют одни и те же слои, то эти слои переиспользуются, а не дублируются, что позволяет более эффективно использовать дисковое пространство.

Данные Storage Driver хранятся в поддиректории Docker с названием Storage Driver, по умолчанию `/var/lib/docker/overlay2`.

OverlayFS имеет ограничения:

- перезаписываемый слой контейнера удаляется при удалении самого контейнера;
- производительность ниже в сравнении с классическими файловыми системами Linux.

Поэтому для хранения персистентных данных, а так же для работы с часто изменяемыми данными, например директория с данными БД, рекомендуется использовать:

- **bind mounts (точки монтирования)**: Данные могут храниться где угодно в хост-системе. Это могут быть даже важные системные файлы или каталоги. Не-Docker-процессы на хосте Docker или в контейнере Docker могут изменить их в любое время.
- **volumes (тома)**: Тома хранятся в части файловой системы хоста, которая управляется Docker (/var/lib/docker/volumes/ в Linux). Процессы, не относящиеся к Docker, не должны изменять эту часть файловой системы.
- **tmpfs mount**: Данные хранятся только в оперативной памяти хост-системы и никогда не записываются в файловую систему хост-системы.

Точки монтирования и тома более производительны по сравнению с OverlayFS и не удаляются при удалении контейнера.

Независимо от типа монтирования, данные внутри контейнера будут выглядеть одинаково. Он предоставляется либо как каталог, либо как отдельный файл в файловой системе контейнера.

volumes и blind mount можно использовать одновременно. Что выбрать - зависит от решаемой задачи. Если нужно пробросить существующую директорию, то следует использовать bind mounts. Если необходимо создать директорию для хранения персистентных данных, генерируемых внутри Docker Container, то лучше подойдут volumes.

![](/materials/images/devops/docker_data.png)
- Различия между bind mounts, volumes и tmpfs mounts.

### 4.1 Docker volumes

Тома являются предпочтительным способом сохранения данных, созданных и использованных контейнерами docker. Хотя монтирование зависит от структуры каталогов и операционной системы хост-компьютера, тома полностью контролируются docker. У томов есть несколько преимуществ по сравнению с монтированием:

- Тома легче резервировать и мигрировать, чем монтирование.
- Управление томами возможно с помощью команд docker CLI или docker API.
- Тома работают как с контейнерами Linux, так и с Windows.
- Возможность безопасного распределения томов между несколькими контейнерами.
- Драйверы томов позволяют хранить тома на удаленных хостах или у облачных провайдеров, шифровать содержимое и добавлять другие функции.
- Новые тома могут быть предварительно заполнены контейнером.
- Тома на Docker Desktop обладают значительно высокой производительностью по сравнению с монтированием на Mac и Windows.
- Тома часто являются лучшим выбором для сохранения данных, поскольку они не увеличивают размер контейнеров, использующих их, и содержимое тома существует вне жизненного цикла конкретного контейнера.
- При использовании volumes директория с данными будет создана в поддиректории Docker. По умолчанию это `/var/lib/docker/volumes`.
- Создаёт и удаляет volumes Docker Deamon.
- Использование томов предпочтительнее, чем точек монтирования. Bind mounts зависят от структуры директорий на Docker-хосте, а тома полностью управляются Docker.

Если контейнер генерирует непостоянные данные о состоянии, рекомендуется использовать монтирование tmpfs, чтобы избежать постоянного хранения данных и повысить производительность контейнера, избегая записи в доступный для записи слой контейнера.

```bash
docker run -d \
  --name nginx-container \
  --mount source=appdata,target=/app \
  nginx:latest
```
- `type` - можно не указывать, так как по умолчанию он имеет значение `volume`, что означает монтирование тома.
- `source=appdata` - принимает имя создаваемого тома.
- `target=/app` - сообщает, что исходная директория будет смонтирована в директорию `/app` контейнера.
```bash
docker run -d \
  --name nginx-container \
  -v appdata:/app \
  nginx:latest
```
- Идентичный результат с использованием аргумента `-v` или `--volume`.

```bash
# Create a named volume
docker volume create volume_name

# List of all volumes
docker volume ls

# Inspect details of a volume
docker volume inspect volume_name

# Remove a volume
docker volume rm volume_name

# Run a container with a volume (mount)
docker run --name container_name -v volume_name:/path/in/container image_name:tag

# Copy files between a container and a volume
docker cp local_file_or_directory container_name:/path/in/container
```

### 4.2 Bind mount

Монтирование с привязкой существуют с первых дней существования Docker. Этот способ организации файловой системы контейнера имеет ограниченную функциональность по сравнению с томами. При использовании монтирования с привязкой файл или каталог на хост-компьютере монтируется в контейнер. На файл или каталог ссылаются по его абсолютному пути на хост-компьютере. Напротив, когда вы используете том, в каталоге хранилища Docker на хост-компьютере создается новый каталог, и Docker управляет содержимым этого каталога.

Файл или каталог не обязательно должен уже существовать на хосте Docker. Он создается по требованию, если он еще не существует. Монтирование с привязкой очень эффективно, но оно зависит от наличия в файловой системе хост-компьютера определенной структуры каталогов. Если вы разрабатываете новые приложения Docker, рассмотрите возможность использования вместо них именованных томов. Вы не можете использовать команды Docker CLI для прямого управления данными при монтировании с привязкой.

```shell
docker run -d \
  --name nginx-container \
  --mount type=bind,source="$(pwd)"/target,target=/app \
  nginx:latest
```
- `type=bind` - означает, что используется bind mount.
- `source="$(pwd)"/target` - сообщает, что на файловой системе исходной директорией будет подкаталог `target` в текущей директории.
- `target=/app` говорит что исходная директория будет смонтирована в директорию `/app` контейнера.
```bash
docker run -d \
  --name nginx-container \
  -v "$(pwd)"/target:/app \
  nginx:latest
```
- Идентичный результат с использованием аргумента `-v` или `--volume`.

### 4.3 Tmpfs mount

**tmpfs mounts** - это тома, создающиеся не на диске, а в оперативной памяти.

Такие тома можно использовать для данных, которые:

- требуют повышенной производительности файловой системы;
- имеют небольшой размер, так как размеры оперативной памяти, как правило, ограничены по сравнению с размером дисков;
- не требуется сохранять после остановки контейнера - tmpfs mounts удалятся.

Тома tmpfs mounts используются, например, для временных файлов.

Тома и монтирования с привязкой позволяют обмениваться файлами между хост-компьютером и контейнером, чтобы вы могли сохранять данные даже после остановки контейнера.

Если вы используете Docker в Linux, у вас есть третий вариант: монтирование tmpfs. Когда вы создаете контейнер с монтированием tmpfs, контейнер может создавать файлы вне доступного для записи слоя контейнера.

В отличие от томов и монтирования с привязкой, монтирование tmpfs является временным и сохраняется только в оперативной памяти хоста. Когда контейнер останавливается, монтирование tmpfs удаляется, и записанные в него файлы не сохраняются.

Это полезно для временного хранения конфиденциальных файлов, которые вы не хотите сохранять ни на хосте, ни на доступном для записи уровне контейнера.

Ограничения tmpfs монтирования:

- В отличии от томов и монтирования с привязкой, монтирование tmpfs не позволяет установить одну точку крепления для разных контейнеров.
- Доступно только в том случае, если вы используете Docker на Linux.
- Неаккуратная установка прав доступа к tmpfs может привести к очистке информации после перезапуска контейнера.

## 5 Сети

Под сетью контейнеров подразумевается способность контейнеров подключаться и взаимодействовать друг с другом или с рабочими нагрузками, не относящимися к Docker.

В контейнерах по умолчанию включена сеть, и они могут устанавливать исходящие соединения. Контейнер не имеет информации о том, к какому типу сети он подключен, а также о том, являются ли его одноранговые узлы также рабочими нагрузками Docker или нет. Контейнер видит только сетевой интерфейс с IP-адресом, шлюзом, таблицей маршрутизации, службами DNS и другими сетевыми деталями. Только контейнер не использует сетевой драйвер none.

Можно создавать собственные пользовательские сети и подключать несколько контейнеров к одной сети. После подключения к определяемой пользователем сети контейнеры могут взаимодействовать друг с другом, используя IP-адреса контейнеров или имена контейнеров.

```bash
# Run a container with a port mapping
docker run --name container_name -p host_port:container_port image_name
# List all networks
docker network ls
# Inspect details of a network
docker network inspect network_name
# Create a user-defined bridge network
docker network create network_name
# Remove a network
docker network rm network_name
# Connect a container to a network
docker network connect network_name container_name
# Disconnect a container from a network
docker network disconnect network_name container_name
```

### 5.1 Сетевые драйверы

Сетевая подсистема Docker основывается на использовании

⭐ **Bridge network driver**

С точки зрения сети мостовая сеть представляет собой устройство канального уровня, которое перенаправляет трафик между сегментами сети. Мост может быть аппаратным или программным устройством, работающим в ядре хост-машины.

С точки зрения Docker, мостовая сеть использует программный мост, который позволяет контейнерам, подключенным к одной и той же мостовой сети, взаимодействовать, обеспечивая при этом изоляцию от контейнеров, которые не подключены к этой мостовой сети. Драйвер моста Docker автоматически устанавливает правила на хост-компьютере, чтобы контейнеры в разных сетях мостов не могли напрямую взаимодействовать друг с другом.

Сети мостов применяются к контейнерам, работающим на одном хосте демона Docker. Для связи между контейнерами, работающими на разных хостах демона Docker, можно управлять маршрутизацией на уровне ОС или использовать оверлейную сеть.

При запуске Docker, сеть мостов по умолчанию (также называемая мостом) создается автоматически, и вновь запущенные контейнеры подключаются к ней, если не указано иное. Можно создавать пользовательские сети мостов. Мостовые сети, определяемые пользователем, превосходят мостовую сеть по умолчанию.

**Различия между определяемыми пользователем мостами и мостом по умолчанию**

- Пользовательские мосты обеспечивают автоматическое разрешение DNS между контейнерами. Контейнеры в мостовой сети по умолчанию могут обращаться друг к другу только по IP-адресам, если только вы не используете опцию --link, которая считается устаревшей. В определяемой пользователем мостовой сети контейнеры могут разрешать друг друга по имени или псевдониму.
- Пользовательские мосты обеспечивают лучшую изоляцию. Все контейнеры подключаются к мостовой сети по умолчанию. Это может быть рискованно, поскольку несвязанные стеки/сервисы/контейнеры могут взаимодействовать друг с другом.
- Каждая определяемая пользователем сеть создает настраиваемый мост. Если ваши контейнеры используют мостовую сеть по умолчанию, вы можете настроить ее, но все контейнеры будут использовать одни и те же настройки, такие как MTU и правила iptables. Кроме того, настройка мостовой сети по умолчанию происходит вне самого Docker и требует перезапуска Docker.

⭐ **Overlay network driver**

Драйвер оверлейной сети создает распределенную сеть между несколькими хостами демона Docker. Эта сеть располагается поверх (перекрывает) сетей, специфичных для хоста, позволяя контейнерам, подключенным к ней, безопасно взаимодействовать при включенном шифровании. Docker прозрачно обрабатывает маршрутизацию каждого пакета к правильному хосту демона Docker и к правильному контейнеру назначения и обратно.

Вы можете создавать пользовательские оверлейные сети точно так же, как вы можете создавать пользовательские мостовые сети. Сервисы или контейнеры могут быть подключены к более чем одной сети одновременно. Службы или контейнеры могут взаимодействовать только между сетями, к которым каждый из них подключен.

Оверлейные сети часто используются для создания соединения между сервисами Swarm, но вы также можете использовать их для подключения автономных контейнеров, работающих на разных хостах. При использовании автономных контейнеров по-прежнему необходимо использовать режим Swarm для установления соединения между хостами.

⭐ **Host network driver**

Если вы используете режим сети хоста для контейнера, сетевой стек этого контейнера не изолирован от хоста Docker (контейнер использует сетевое пространство имен хоста), и контейнеру не выделяется собственный IP-адрес. Например, если вы запускаете контейнер, который привязывается к порту 80, и используете сеть хоста, приложение контейнера будет доступно через порт 80 по IP-адресу хоста.

⭐ **IPvlan network driver**

Драйвер IPvlan предоставляет пользователям полный контроль над адресацией IPv4 и IPv6. Драйвер VLAN построен на основе этого, предоставляя операторам полный контроль над маркировкой VLAN уровня 2 и даже маршрутизацией IPvlan L3 для пользователей, заинтересованных в базовой сетевой интеграции. Для развертываний наложения, которые абстрагируют физические ограничения, см. драйвер наложения с несколькими хостами.

IPvlan - это новый поворот в проверенной и надежной технике виртуализации сети. Реализации Linux чрезвычайно легки, поскольку вместо использования традиционного моста Linux для изоляции они связаны с интерфейсом или субинтерфейсом Ethernet Linux для обеспечения разделения между сетями и подключения к физической сети.

IPvlan предлагает ряд уникальных функций и много возможностей для дальнейших инноваций в различных режимах. Двумя преимуществами этих подходов являются положительное влияние на производительность при обходе моста Linux и простота использования меньшего количества движущихся частей. Удаление моста, который традиционно находится между сетевым адаптером хоста Docker и интерфейсом контейнера, оставляет простую настройку, состоящую из интерфейсов контейнера, подключенных непосредственно к интерфейсу хоста Docker. К этому результату легко получить доступ для внешних служб, поскольку в этих сценариях нет необходимости в сопоставлении портов.

⭐ **Macvlan network driver**

Некоторые приложения, особенно устаревшие приложения или приложения, отслеживающие сетевой трафик, ожидают прямого подключения к физической сети. В такой ситуации вы можете использовать сетевой драйвер macvlan, чтобы назначить MAC-адрес виртуальному сетевому интерфейсу каждого контейнера, делая его похожим на физический сетевой интерфейс, напрямую подключенный к физической сети. В этом случае вам необходимо назначить физический интерфейс на вашем хосте Docker, который будет использоваться для Macvlan, а также подсеть и шлюз сети. Вы даже можете изолировать свои сети Macvlan, используя разные физические сетевые интерфейсы.

Имейте в виду следующее:

- Вы можете непреднамеренно ухудшить качество своей сети из-за нехватки IP-адресов или «распространения VLAN» - ситуация, которая возникает, когда в вашей сети имеется недопустимо большое количество уникальных MAC-адресов.
- Ваше сетевое оборудование должно поддерживать «неразборчивый режим», когда одному физическому интерфейсу может быть назначено несколько MAC-адресов.
- Если ваше приложение может работать с использованием моста (на одном хосте Docker) или оверлея (для взаимодействия между несколькими хостами Docker), эти решения могут быть лучше в долгосрочной перспективе.
- None network driver.

Если вы хотите полностью изолировать сетевой стек контейнера, вы можете использовать флаг `--network none` при запуске контейнера. Внутри контейнера создается только устройство обратной связи (loopback interface).


⭐⭐ **Сравнение сетевых драйверов**

- Мостовая сеть по умолчанию хороша для запуска контейнеров, которым не требуются специальные сетевые возможности.
- Пользовательские мостовые сети позволяют контейнерам на одном хосте Docker взаимодействовать друг с другом. Пользовательская сеть обычно определяет изолированную сеть для нескольких контейнеров, принадлежащих общему проекту или компоненту.
- Хост-сеть разделяет сеть хоста с контейнером. Когда вы используете этот драйвер, сеть контейнера не изолирована от хоста.
- Оверлейные сети лучше всего подходят, когда вам нужны контейнеры, работающие на разных хостах Docker, для связи или когда несколько приложений работают вместе с помощью сервисов Swarm.
- Сети Macvlan лучше всего подходят, когда вы переходите с установки виртуальной машины или хотите, чтобы ваши контейнеры выглядели как физические хосты в вашей сети, каждый из которых имеет уникальный MAC-адрес.
- IPvlan похож на Macvlan, но не назначает контейнерам уникальные MAC-адреса. Рассмотрите возможность использования IPvlan, когда существует ограничение на количество MAC-адресов, которые можно назначить сетевому интерфейсу или порту.

### 5.2 Проброс портов

Под публикацией портов стоит понимать тот случай, когда необходимо позволить к приложению, запущенному в контейнере Docker, подключаться извне.

По умолчанию, когда вы создаете или запускаете контейнер с помощью `docker create` или `docker run`, контейнер не раскрывает ни один из своих портов внешнему миру. Флаг `--publish` или `-p` позволяет сделать порт доступным для служб за пределами Docker. Это создает правило брандмауэра на хосте, сопоставляющее порт контейнера порту хоста Docker с внешним миром.

Публикация портов контейнеров по умолчанию небезопасна. Это означает, что когда вы публикуете порты контейнера, он становится доступен не только хосту Docker, но и внешнему миру.

Вот некоторые примеры:

```
-p 8080:80
```
- Сопоставление порта 8080 на хосте Docker с TCP-портом 80 в контейнере.
```
-p 192.168.1.100:8080:80
```
- Сопоставление порта 8080 на IP-адресе хоста Docker 192.168.1.100 с TCP-портом 80 в контейнере.
```
-p 8080:80/udp
```
- Сопоставление порта 8080 на хосте Docker с портом UDP 80 в контейнере.
```
-p 8080:80/tcp -p 8080:80/udp
```
- Сопоставление порта TCP 8080 на хосте Docker с портом TCP 80 в контейнере и сопоставление порта UDP 8080 на хосте Docker с портом UDP 80 в контейнере.

```bash
docker run -p 127.0.0.1:8080:80 nginx
```
- Если включить IP-адрес локального хоста (127.0.0.1) в флаг публикации, только хост Docker сможет получить доступ к порту опубликованного контейнера.

### 5.3 Сервисы DNS

По умолчанию контейнеры наследуют настройки DNS, определенные в файле конфигурации /etc/resolv.conf. Контейнеры, подключающиеся к мостовой сети по умолчанию, получают копию этого файла. Контейнеры, подключаемые к пользовательской сети, используют встроенный DNS-сервер Docker. Встроенный DNS-сервер перенаправляет внешние запросы DNS на DNS-серверы, настроенные на хосте.

Вы можете настроить разрешение DNS для каждого контейнера, используя флаги для команды `docker run` или `docker create`, используемой для запуска контейнера.

| Флаг         | Описание                                                                                                                                                                                                                                                                                         |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| --dns        | IP-адрес DNS-сервера. Чтобы указать несколько DNS-серверов, используйте несколько флагов --dns. Если контейнер не может связаться ни с одним из указанных вами IP-адресов, он использует общедоступный DNS-сервер Google по адресу 8.8.8.8. Это позволяет контейнерам разрешать интернет-домены. |
| --dns-search | Домен поиска DNS для поиска неполных имен хостов. Чтобы указать несколько префиксов поиска DNS, используйте несколько флагов --dns-search.                                                                                                                                                       |
| --dns-opt    | Пара ключ-значение, представляющая параметр DNS и его значение. Допустимые параметры смотрите в документации вашей операционной системы для resolv.conf.                                                                                                                                         |
| --hostname   | Имя хоста, которое контейнер использует для себя. По умолчанию используется идентификатор контейнера, если он не указан.                                                                                                                                                                         |

### 5.4 Фильтрация пакетов и межсетевые экраны

В Linux Docker манипулирует правилами iptables для обеспечения сетевой изоляции. Хотя это деталь реализации, и вам не следует изменять правила, которые Docker вставляет в ваши политики iptables, это имеет некоторые последствия для того, что вам нужно делать, если вы хотите иметь свои собственные политики в дополнение к тем, которые управляются Docker.

Если вы используете Docker на хосте, подключенном к Интернету, вам, вероятно, понадобится политика iptables, предотвращающая несанкционированный доступ к контейнерам или другим службам, работающим на вашем хосте.

Docker устанавливает две собственные цепочки iptables с именами DOCKER-USER и DOCKER и гарантирует, что входящие пакеты всегда сначала проверяются этими двумя цепочками. Эти сети являются частью сети FORWARD.

Все правила iptables Docker добавляются в цепочку DOCKER. Не изменяйте эту цепочку вручную. Если вам нужно добавить правила, которые загружаются раньше правил Docker, добавьте их в цепочку DOCKER-USER. Эти правила применяются до того, как Docker автоматически создаст какие-либо правила.

Другие правила, добавленные в цепочку FORWARD вручную или с помощью другого брандмауэра на основе iptables, оцениваются после цепочек DOCKER-USER и DOCKER. Это означает, что если вы публикуете порт через Docker, этот порт будет проброшен независимо от того, какие правила настроены в вашем брандмауэре. Если вы хотите, чтобы правила применялись даже при публикации порта через Docker, вам необходимо добавить эти правила в цепочку DOCKER-USER.

Когда пакеты поступают в цепочку DOCKER-USER, они уже прошли фильтр трансляции сетевых адресов назначения (DNAT). Это означает, что используемые вами флаги iptables могут соответствовать только внутренним IP-адресам и портам контейнеров.

## 6 Мониторинг

```bash
docker stats
```
- Вывод статистики использования ресурсов хоста контейнером в реальном времени.

```bash
docker events
```
- Список событий в процессе работы сервисов Docker.

```bash
docker logs
```
- Список логов контейнера.

## 7 Docker compose

- [Подробнее про Docker Compose](/materials/devops/docker_compose.md)

## 8 Docker Swarm

- [Подробнее про Docker Swarm](/materials/devops/docker_swarm.md)

## 9 Практика

### Основные команды

```bash
# Версия Docker
docker --version

# Очистка всех ресурсов – образы, контейнеры, volumes, networks
docker system prune

# Инициализация Docker внутри приложения
docker init

# Посмотреть сервис/контейнер приложения
docker compose watch

# Создать контейнер, но не запускать его
docker create nginx

# Создать контейнер и запустить его
docker run nginx
```
- Основные команды

### Docker + Django + PostgreSQL

Dockerfile

```dockerfile
FROM python:3.12.3-alpine3.19

COPY requirements.txt /temp/requirements.txt
COPY service /service
WORKDIR /service
EXPOSE 8000

RUN apk add postgresql-client build-base postgresql-dev
RUN pip install -r /temp/requirements.txt
RUN adduser --disabled-password service-user

USER service-user
```

Docker-compose.yml

```yml
services:
	web-app:
		build:
		context: .
		ports:
			- "8000:8000"
		volumes:
			- ./service:/service
		environment:
			- DB_HOST=database
			- DB_NAME=dbname
			- DB_USER=dbuser
			- DB_PASS=pwd
		command: >
			sh -c "python manage.py runserver 0.0.0.0:8000"
		depends_on:
			- database
	database:
		image: postgres:16.2-alpine
		environment:
			- POSTGRES_DB=dbname
			- POSTGRES_USER=dbuser
			- POSTGRES_PASSWORD=pwd
```

Далее переходим в каталог с докер файлами, создаем там директорию service/ и запускаем контейнер:

```bash
docker-compose build
docker-compose up
docker-compose run --rm sh -c "python manage.py migrate"
```

### MariaDB & Apache

```yml
version: '3'
services:
	web:
		build:
			context: ./html
			dockerfile: Dockerfile
		ports:
			- "8080:80"
		environment:
			- DATABASE_HOST=db
			- DATABASE_PORT=3306
			- DATABASE_NAME=first
			- DATABASE_USER=root
			- DATABASE_PASSWORD=1
		volumes:
			- ./html:/var/www/html
			- db_data:/var/lib/mysql
		depends_on:
			- db
		networks:
			custom_network:
				ipv4_address: 172.20.0.22
	db:
		image: mariadb
		environment:
			MYSQL_DATABASE: first
			MYSQL_USER: root
			MYSQL_PASSWORD: 1
			MYSQL_ROOT_PASSWORD: 1
		volumes:
			- db_data:/var/lib/mysql
		networks:
			custom_network:
				ipv4_address: 172.20.0.23

volumes:
	db_data: {}

networks:
	custom_network:
		driver: bridge
		ipam:
			config:
				- subnet: 172.20.0.0/16
```

### Dockerfile no root

```dockerfile
FROM python

RUN addgroup --system app && adduser --system --group app && chown -R app:app /app/
USER app
```
- Добавление пользователя и назначение его на каталог приложения.

# 10 Вопросы

1. Что такое контейнер Docker?
2. Какие составные части архитектуры Docker?
3. Какой жизненный цикл контейнера Docker?
4. Что такое пространства имен Docker?
5. Что такое Docker Swarm?
6. Как определить состояние контейнера?
7. Что такое образ Docker?
8. Для чего применяется Docker?
9. Что такое Dockerfile?
10. Какие сети по умолчанию доступны в Docker?
11. Удалятся ли данные, если остановить контейнер?
12. Как мониторить контейнеры Docker?
13. В чем разница между `docker run` и `docker create`?
14. Можно ли использовать JSON вместо YAML для манифеста compose?
15. В чем разница между инструкциями `CMD` и `ENTRYPOINT`?
16. В чем разница между контейнеризацией и виртуализацией?
17. Какие основные команды Docker?
18. Возможен ли автоматический перезапуск контейнера?
19. Какие состояния бывают у контейнера Docker?
20. Где хранятся тома Docker?
21. Как масштабировать контейнеры Docker с помощью compose?
22. Какие типы монтирования доступны в Docker?