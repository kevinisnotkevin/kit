# Контейнеризация

## Что такое контейнеризация?

**Контейнеризация** - это метод виртуализации в UNIX, при котором ядро ОС поддерживает несколько изолированных пространств пользователя без резервирования ресурсов. Количество пространств при контейнеризации может быть сильно больше, чем при использовании виртуальных машин, но контейнеры в UNIX не изолируются на уровне потребляемых ресурсов.

Контейнеры упрощают разработку и доставку распределенных приложений. Они становятся все более популярными по мере того, как организации переходят на облачную разработку и гибридные мультиоблачные среды. Разработчики могут создавать контейнеры без Docker, работая напрямую с возможностями, встроенными в Linux и другие операционные системы. Но Docker делает контейнеризацию быстрее, проще и безопаснее.

**CP/CMS**

**CP/CMS (Control Panel / Console Monitor System)** - это ОС, разработанная IBM, которая положила основу технологиям виртуализации и является первым гипервизором. CP - это ПО, которое создает виртуальные машины для каждого пользователя. CMS - это однопользовательская интерактивная ОС. CP/CMS выделяла ресурсы для пользователя, даже если они не использовались на полную.

**CHROOT**

В 1979 году вышла 7-я версия UNIX. Появилась команда **chroot**, которая позволяет заменить корневую директорию процесса и его потомков. Это заложило основу технологии изоляции процессов и разделения доступа к файлам для каждого процесса в UNIX. Но и с chroot ОС UNIX имела единое пространство процессов для всех пользователей - одно приложение по-прежнему могло захватить все ресурсы.

chroot был единственным способом контейнеризации процессов до 2000 года, пока не появился jail.

**FREEBSD JAIL**

**FreeBSD Jail** - это механизм виртуализации на уровне ОС. Jail позволяет запускать на одной физической машине FreeBSD несколько виртуальных экземпляров ОС, использующих общее ядро хостовой системы, но с уникальным набором настроек и приложений. Процессы внутри такой локальной среды имеют доступ только с локальным файлам, процессам и учетным записям пользователя, не затрагивая остальные части системы.

Jail изолирует процессы и сетевые сервисы, создавая файловое пространство, пользовательские идентификаторы и сетевые адреса. Такой метод более легковесен по сравнению с полной виртуализацией, использующей гипервизоры, так как работает на одном ядре ОС.

**LINUX-VSERVER**

В 2001 году появился аналог FreeBSD Jail для Linux - Linux-VServer. Каждая изолированная копия системы называлась контекстом безопасности, а работающая в нем система - VPS. Построенные на основе Linux-VServer виртуальные серверы могли использовать общую файловую систему и общие наборы файлов с помощью жестких ссылок, что экономило дисковое пространство.

Процессы на виртуальном сервере выполнялись как обычные процессы в хост-системе. Это более эффективно с точки зрения использования памяти и операций ввода-вывода, чем эмуляция всей ОС.

В отличие от полной виртуализации, которая эмулирует виртуальные машины целиком с их собственными ядрами, Linux-VServer делится одним ядром между всеми виртуальными серверами или контейнерами.

**CGROUPS**

В 2006 году компания Google разработала систему разделения ресурсов Process Containers. Позже она была переименована в **control groups** (cgroups), а затем её включили в ядро Linux. Также они использовали механизм namespaces.

**LXC, WARDEN**

Спустя год выпустили Linux Containers (LXC) - у него было много общего с OpenVZ и Linux-VServer, но вместо сторонних механизмов из патчей ядра использовались стандартные для Linux механизмы namespaces и cgroups.

В 2013 году компания Cloud Foundry создала Warden. Новая утилита предназначалась для запуска приложений, которые получают все свои зависимости от частей ПО, называемых `buildpacks`. Контейнеры Warden обычно имеют два слоя: слой только для чтения с корневой файловой системой ОС и неперсистентный слой чтения/записи самого приложения и его зависимостей. В 2013 году на рынке появился и Docker.

**DOCKER**

Docker придумали в инкубаторе стартапов Y Combinator и выпустили 2011 году программисты Камель Фунади, Соломон Хайкс и Себастьян Пал. Docker использовал LXC как бэкенд для управления контейнерами, но добавил уровень абстракции и упростил процесс создания и управления контейнерами.

Удобство и эффективность Docker помогли контейнеризации завоевать широкую аудиторию и сделали его стандартом среди разработчиков и системных администраторов. Контрибьюторы Docker - Cisco, Google, Huawei, IBM, Microsoft и Red Hat.

## CGROUPS

Для запуска контейнеров и изоляции в Docker используются два основных механизма ядра Linux: cgroups и namespaces. Первый изолирует системные ресурсы, такие как процессорное время и память, а второй изолирует процессы на уровне ОС: идентификаторы процессов, идентификаторы пользователей, имена сетевых интерфейсов.

**cgroups** - это технология управления ресурсами системы. Состоит из **core** (реализует иерархическую организацию процессов) и **controllers** (отвечает за распространение ресурсов системы). 

Контрольные группы - это древовидная структура. Треды процесса принадлежат той же группе, что и процесс, а новым процессам назначается та же группа, что и у родительского. Процесс может мигрировать в другую контрольную группу, при этом у дочерних процессов контрольная группа не меняется.

Контроллеры могут быть включены или выключены выборочно для контрольных групп. Поведение всех контроллеров иерархичное. Если контроллер включен для контрольной группы, он автоматически влияет на все процессы, которым назначена данная или дочерние контрольные группы. Также он автоматически ограничивает ресурсы для всех дочерних контрольных групп. Ограничения родительских контрольных групп не могут быть переопределены дочерними контрольными группами.

- **CPU**: Контроллер регулирует распределение циклов процессора. Этот контроллер позволяет задать вес и лимит абсолютной пропускной способности при нормальной политике планировщика, а также лимит абсолютной пропускной способности при планировщике реального времени. В случае достижения лимита по CPU процесс подвергается тротлингу.
- **Memory**: Контроллер регулирует распределение памяти. В случае превышения лимита потребления памяти процесс может быть остановлен ядром ОС - подсистемой Out of memory killer.

## NAMESPACES

**namespaces** - это механизм ядра Linux для разделения ресурсов. Он отвечает за то, чтобы каждый набор процессов видел только отведенный ему набор ресурсов ядра. Такие наборы процессов располагаются в разных пространствах имен.

- **user namespace**: Подразумевает независимые наборы идентификаторов пользователей uid, или групп gid, которые могут быть назначены процессу для каждого пространства имен.
- **PID namespace**: Связывает с процессом набор идентификаторов процессов, независимый от наборов идентификаторов процессов в другом пространстве имён. Первый процесс, созданный в новом пространстве, получает идентификатор 1. Все его дочерние процессы получают последующие идентификаторы. При этом процесс с идентификатором 1 будет иметь отличный идентификатор в пространстве родительского процесса.
- **network namespace**: Независимый сетевой стек: собственная приватная таблица маршрутизации, наборы IP-адресов, слушающие сокеты - порты, таблица соединений conntrack-table, фаервол и прочие связанные с сетью ресурсы.
- **mount namespace**: Независимый набор точек монтирования, который видят процессы в этом пространстве имён. Это означает, что вы можете монтировать и размонтировать файловые системы без влияния на хостовую операционную систему.
- **IPC (interprocess communication) namespace**: Имеет собственный набор IPC-ресурсов. Например, вы не сможете послать сигнал завершения (SIGTERM/SIGKILL) процессу в хостовой ОС изнутри IPC namespace.
- **UTS (UNIX Time-Sharing) namespace**: Позволяет на одной системе иметь независимые имена хоста и домена для различных процессов.

> В основном namespaces применяются в контейнеризации, но вы можете использовать эту технологию самостоятельно с помощью, например, утилиты unshare. Чтобы запустить один процесс в неймспейсе или неймспейсах другого процесса, можно воспользоваться утилитой nsenter. Это пригодится для запуска утилиты curl с хостовой системы в сетевом неймспейсе контейнера, если в контейнере этой утилиты нет и добавить её туда нет возможности.

## Преимущества контейнеров

**Портативность**: Контейнеры могут быть легко перенесены между различными средами, такими как локальный компьютер, облачные платформы или виртуальные машины, без изменения кода или настроек.

**Изолированность:** Каждый контейнер запускается в своей собственной изолированной среде, что предотвращает конфликты между приложениями и обеспечивает безопасность. Настройки и зависимости, противоречащие конфигурации основной ОС, не повлияют на работу приложения в контейнере.

**Независимость**: Контейнеры не зависят друг от друга. В случае поломки в контейнере А это не повлияет на работу контейнера Б. Однако независимость не мешает им передавать данные друг другу.

**Масштабируемость:** Контейнеры легко масштабируются вверх (повышение производительности на одном сервере) и вниз (увеличение или уменьшение количества контейнеров) в зависимости от нагрузки. Такой подход дает возможность быстро адаптироваться к текущему уровню пользовательского трафика.

**Гибкость и скорость развертывания:** Это дает возможность разбить монолитную структуру предприятия и набор гибких микросервисов в контейнерах, что позволяет быстро развертывать и обновлять приложения, сокращая время, необходимое для установки и настройки.

**Стандартизация:** Контейнеры способствуют стандартизации окружений разработки и развертывания, что упрощает управление приложениями и уменьшает вероятность ошибок.

**Эффективное использование ресурсов:** Использование контейнеров позволяет сэкономить ресурсы за счет общего ядра операционной системы, в отличие от традиционных виртуальных машин.

**Легковесность**: Контейнеры имеют простую структуру, которая потребляет только те ресурсы, которые необходимы для работы приложения внутри них.

## Чем контейнеризация отличается от виртуализации?

![](/materials/images/devops/cont_vs_virt.png)

- **У контейнеров короткий жизненный цикл**: Любой контейнер можно остановить, перезапустить или уничтожить, если это необходимо. Данные, которые содержатся в контейнере, при этом тоже пропадут. Так выработалось правило проектирования приложений: не хранить важные данные в контейнере. Такой подход называют stateless.
- **Объём контейнеров измеряется в мегабайтах**: В них упаковывают лишь исполняемые файлы и зависимости ОС, необходимые для выполнения кода. Легковесные контейнеры быстро запускаются и экономят место на диске.
- **Один контейнер соответствует одному запускаемому процессу**: Отключение отдельного контейнера для отладки или обновления не помешает работе приложения.
- **Надёжная изоляция процессов и высокий уровень безопасности систем**: Приложения, которые работают внутри контейнера, не имеют доступа к основной ОС и не могут на неё влиять.
- **Переход с монолита на микросервисную архитектуру**: Микросервисная архитектура ускоряет разработку новой функциональности, поскольку нет опасений, что изменения в одном компоненте затронут всю остальную систему.
- **Контейнеры эффективнее виртуальных машин**: Контейнеризация изолирует процессы в контейнере, используя механизмы ядра ОС хоста. Виртуализация же эмулирует оборудование, поверх которого запускается полноценная ОС со своим ядром. Как следствие, виртуализация требует больше ресурсов системы для запуска приложения, так как они расходуются на эмуляцию оборудования и работу гостевой ОС. В случае контейнеризации, ресурсы системы расходуются только на само приложение и обеспечение работы механизмов изоляции, которые требуют заметно меньше ресурсов.

## Для чего используют контейнеры?

Контейнеры решают критически важную проблему переносимости кода. Они устраняют потенциальные конфликты между вашей локальной средой разработки и рабочей средой приложения.

Упаковка в контейнеры позволяет отделить код от базовой инфраструктуры, в которой он выполняется. В рабочей среде этот контейнер может быть запущен на любом компьютере, имеющем платформу контейнеризации. В продакшене код будет работать так же хорошо, как и на машине программиста.
