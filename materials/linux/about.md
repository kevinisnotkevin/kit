# Linux

Исходный код ядра Linux: https://www.kernel.org

Имеется три основных типа ядер - монолитные (monolithic), микроядра (microkernel) и гибридные (hybrid).
К примеру Linux является монолитным ядром, тогда как OS X и Windows используют гибридные ядра.

Микроядра занимаются управлением только CPU, памятью и IPC. Практически все остальное в компьютере может рассматриваться как дополнительное оборудование и может обслуживаться в пользовательском режиме. Микроядра имеют большую переносимость, т.к. вам не приходиться беспокоиться если вы задумали сменить видеокарту или даже всю операционную систему – если новая ОС работает с оборудованием так же, как и предыдущее.

Монолитные ядра являются противоположностью микроядрам, так как охватывают не только управление процессором, памятью и IPC – но так же включают в себя драйвера устройств, управление файловыми системами и системными вызовами. Монолитные ядра имеют преимущество в скорости доступа к оборудованию и работе в многозадачном режиме.

Монолитные ядра являются противоположностью микроядрам, так как охватывают не только управление процессором, памятью и IPC – но так же включают в себя драйвера устройств, управление файловыми системами и системными вызовами. Монолитные ядра имеют преимущество в скорости доступа к оборудованию и работе в многозадачном режиме.

Гибридные ядра могут сами определять – какую часть выполнять в режиме пользователя, а какую – в режиме ядра. Как правило – в режиме пользователя работают драйвера устройств и системы ввода-вывода, тогда как системные вызовы обслуживаются в режиме ядра. Этот подход сочетает в себе преимущества как монолитных, так и микроядер – однако и требует больше внимания со стороны производителей оборудования, так как работа драйверов зависят от них.

История Linux начинается в 1991 году, когда финский программист Линус Торвальдс стал разрабатывать ядро операционной системы для своего компьютера.

# Ядро

Ядро - это один из самых важных компонентов системы, именно здесь реализуется поддержка оборудования, выполняются основные действия по управлению процессами, памятью, сетью и другие действия. Новые версии ядра имеют максимальную поддержку современного оборудования, содержат исправления
уязвимостей и многое другое. Поэтому очень важно, чтобы система использовала самые новые версии ядра.

Модули ядра - это фрагменты кода, которые могут быть загружены и выгружены в ядро по требованию. Они расширяют функциональность ядра без необходимости перезагрузки системы. Модуль может быть настроен как встроенный в ядро или загружаемый во время работы операционной системы.

# Подсистемы ядра

Уровень системных вызовов - это наиболее близкая к прикладному программисту часть ядра Linux.

Ядро Linux использует в качестве минимальной единицы памяти страницу. Для хранения информации о странице физической памяти (её физический адрес, принадлежность, режим использования и пр) используется специальная структура page размером в 40 байт.

Ядро Linux было многозадачным буквально с первого дня. К настоящему моменту оно имеет довольно хорошую поддержку вытесняющей многозадачности.

Сетевая подсистема ядра ОС, теоретически, почти вся может выполняться в пространстве пользователя: для таких операций, как формирование пакетов TCP/IP.

# Пространство ядра и пространство пользователя

Для 32-разрядной операционной системы ее адресное пространство (виртуальное адресное пространство или линейное адресное пространство) составляет 4G (2 в 32-й степени). Другими словами, максимальное адресное пространство процесса составляет 4G.

Чтобы обеспечить безопасность ядра, современные операционные системы обычно вынуждают пользовательские процессы не работать с ядром напрямую. Конкретная реализация заключается в том, что операционная система делит виртуальное адресное пространство на две части, одна часть - это пространство ядра, а другая часть - пользовательское пространство.

# Почему нужно различать пространство ядра и пространство пользователя

Среди всех инструкций поцессора некоторые инструкции очень опасны: их неправильное использование приведет к сбою системы, например очистка памяти и установка часов. Если всем программам разрешить использовать эти инструкции, вероятность сбоев системы значительно возрастет.

Таким образом, поцессор делит инструкции на привилегированные и непривилегированные инструкции. Для этих опасных инструкций их разрешено использовать только операционной системе и связанным с ней модулям, а обычные приложения могут использовать только инструкции, которые не вызовут катастрофы. Например, процессор Intel делит уровень привилегий на 4 уровня: Ring0 ~ Ring3.

Фактически, система Linux использует только два уровня выполнения, Ring0 и Ring3 (то же самое верно и для систем Windows). Когда процесс выполняется на уровне Ring3, он называется запущенным в пользовательском режиме, а когда он выполняется на уровне Ring0, он называется запущенным в режиме ядра.

# Режим ядра и пользовательский режим

Когда процесс выполняется в пространстве ядра, он находится в режиме ядра, а когда процесс выполняется в пользовательском пространстве, он находится в пользовательском режиме.

В режиме ядра процесс выполняется в адресном пространстве ядра, и в это время ЦП может выполнять любые инструкции. Работающий код также не подлежит никаким ограничениям, может свободно обращаться к любому действующему адресу, а также может напрямую обращаться к порту.

В пользовательском режиме процесс выполняется в адресном пространстве пользователя, а исполняемый код подвергается множеству проверок со стороны ЦП.

# Системные вызовы Linux

В настоящее время в Linux есть около 200 системных вызовов. Их список находится в файле /usr/include/asm/unistd.h. Некоторые из них используются только внутри системы, а некоторые предназначены лишь для реализации специализированных библиотечных функций.

# Начальная загрузка

![](unix__boot.png)
- Шаги загрузки Linux

Под начальной загрузкой подразумевается самозапуск компьютера при включении питания. Поскольку средства операционной системы на данном этапе недоступны, компьютер должен в буквальном смысле «обслужить себя сам». Процесс включает загрузку системного ядра в память и его последующую активизацию. Затем выполняется ряд инициализационных задач, после чего система готова к обслуживанию пользователей.

Начальная загрузка - это период особой уязвимости в жизни системы. Ошибки в конфигурационных файлах, сбои в работе оборудования, повреждения файловых систем могут помешать компьютеру нормально начать работу. Настройка режимов загрузки во многих случаях является одной из первых задач, которую приходится решать администратору в новой системе.

Когда происходит включение питания, запускается на выполнение загрузочный код, хранящийся в ПЗУ. В его обязанность входит запуск ядра. Ядро опрашивает состояние оборудования, а затем запускает системный процесс init, идентификатор которого всегда равен 1.

Прежде чем на экране появляется регистрационное приглашение, происходит целый ряд событий. Файловые системы должны быть проверены и смонтированы, а системные демоны – запущены. Соответствующие процедуры реализуются с помощью сценариев интерпретатора shell, которые один за другим запускаются процессом init.

Стартовые сценарии часто называют rc-файлами, поскольку они имеют префикс rc. Он расшифровывается как run command - «команда запуска» - и является пережитком, доставшимся UNIX в наследство от операционной системы CTSS. Конкретная структура стартовых сценариев и способ их выполнения зависят от системы.

В наиболее общем смысле запуск ОС UNIX и загрузка - это упорядоченный метод выполнения предопределенного набора задач. К таким задачам обычно относятся:
- Выполнение ограниченной процедуры самотестирования основных компонентов машины
- Обнаружение загрузочного устройства
- Считывание ядра системы с загрузочного устройства
- Использование ядра для обнаружения и инициализации периферийного оборудования
- Запуск основных задач системы
- Выполнение сценариев, которые запускают программы для предоставления сервиса
- Выполнение других приложений

При нормальной работе системы сами выполняют начальную загрузку в автономном режиме, после чего к ним могут получить удаленный доступ администраторы и пользователи. Однако администраторам необходимо иметь инструмент восстановления системы в случае, если неожиданный отказ дисковода или какая-нибудь проблема конфигурации помешает системе нормально выполнить процесс начальной загрузки.

Системы UNIX (вместо загрузки “по полной программе”) могут ограничиться только самым необходимым, а именно активизацией командной оболочки на системной консоли. Этот вариант называют входом системы в так называемый “однопользовательский режим”, режим восстановления или профилактический режим — все эти термины взаимозаменяемы. Однопользовательский режим не позволяет выполнять сетевые операции, а для использования системной консоли вам нужно иметь физический доступ к ней.

В большинстве систем для входа в однопользовательский режим во время начальной загрузки необходимо передать ядру в командной строке определенный параметр. Если система уже загружена и работает, вы можете перевести ее в однопользовательский режим с помощью команды shutdown или telinit.

# Главное - активизировать командную оболочку

При нормальной работе системы сами выполняют начальную загрузку в автономном режиме, после чего к ним могут получить удаленный доступ администраторы и пользователи. Однако администраторам необходимо иметь инструмент восстановления системы в случае, если неожиданный отказ дисковода или какая-нибудь проблема конфигурации помешает системе нормально выполнить процесс начальной загрузки. Системы UNIX (вместо загрузки "по полной программе") могут ограничиться только самым необходимым, а именно активизацией командной оболочки на системной консоли. Этот вариант называют входом системы в "однопользовательский режим", режим восстановления или профилактический режим — все эти термины взаимозаменяемы. Однопользовательский режим не позволяет выполнять сетевые операции, а для использования системной консоли вам нужно иметь физический доступ к ней.

В большинстве систем для входа в однопользовательский режим во время начальной загрузки необходимо передать ядру в командной строке определенный параметр. Если система уже загружена и работает, вы можете перевести ее в однопользовательский режим с помощью команды shutdown или telinit.

# Этапы загрузки

Типичная процедура начальной загрузки состоит из шести отдельных этапов:
- Считывание начального загрузчика с главной загрузочной записи;
- Загрузка и инициализация ядра;
- Обнаружение и конфигурирование устройств;
- Создание процессов ядра;
- Вмешательство администратора (только в однопользовательском режиме);
- Выполнение системных сценариев запуска.

Почти все этапы проходят без контроля со стороны администратора. Можно управлять процессом загрузки, редактируя стартовые сценарии.

# Инициализация ядра

Ядро UNIX само по себе является программой, и первый этап начальной загрузки заключается в считывании этой программы в память для последующего выполнения. Имя файла ядра определяется разработчиком конкретной системы, но традиционное его название /unix или /vmunix. В настоящее время разработчики не придерживаются строго этого соглашения.

В большинстве систем загрузк ядра осуществляется в два этапа. Сначала в память машины с диска или магнитной ленты считывается (с помощью кода, записанного в ПЗУ) небольшая программа начальной загрузки, которая затем выполняет собственно загрузку ядра. Весь процесс происходит еще вне UNIX, поэтому в разных системах он реализован по-разному.

Ядро выполняет тестовые программы, позволяющие определить, сколько памяти имеется в наличии. Большинство внутренних структур ядра обладают фиксированным размером, поэтому ядро точно знает, сколько памяти нужно зарезервировать для самого себя. Эта память будет недоступной пользовательским процессам. В большинстве систем ядро выдает на консоль сообщение об общем объеме физической памяти и объеме памяти, не занятой ядром.

**Упрощенно процесс загрузки выглядит следующим образом:**

1. BIOS или загрузочная программа компьютера загружается и запускает загрузчик.
2. Загрузчик находит образ ядра на диске, загружает его в память и запускает.
3. Ядро инициализирует устройства и их драйверы.
4. Ядро монтирует корневую файловую систему.
5. Ядро запускает программу под названием init с идентификатором процесса 1. Эта точка является началом пользовательского пространства.
6. Программа init приводит в действие остальные системные процессы.
7. В какой-то момент запускается процесс, позволяющий пользователю войти в систему, обычно в конце или ближе к концу процесса загрузки.

**При запуске ядро Linux инициализируется в таком порядке:**

1. Проверка процессора.
2. Проверка памяти.
3. Обнаружение шины устройства.
4. Обнаружение устройств.
5. Настройка вспомогательной подсистемы ядра (сеть и т. п.).
6. Монтирование корневой файловой системы.
7. Запуск пользовательского пространства.

**Аварийная загрузка системы и однопользовательский режим**

Когда что-то не так с системой, пользователи обычно первым делом загружают систему с помощью «живого» образа дистрибутива или специального образа восстановления, например SystemRescueCD, который можно поместить на съемный носитель. «Живой» образ — это просто система Linux, которая может загружаться и запускаться без процесса установки, установочные образы большинства дистрибутивов дублируются как «живые» образы.

**Настройка работы системы после сбоя включает в себя следующие действия:**

- проверку файловых систем;
- сброс забытого пароля;
- исправление проблем в критически важных файлах, таких как /etc/fstab и /etc/passwd;
- восстановление резервных копий.

Еще одним вариантом быстрой загрузки является однопользовательский режим **(single-user mode)**. Суть его заключается в том, что система быстро загружается в корневую оболочку, вместо того чтобы проходить через все множество служб. В System V init однопользовательский режим обычно выполняется на уровне 1. В systemd он представлен как rescue.target. Для загрузчика применяется параметр -s. Возможно, вам потребуется ввести пароль суперпользователя, чтобы войти в однопользовательский режим.

_Самая большая проблема с однопользовательским режимом заключается в том, что он не особо удобен. Сеть почти наверняка будет недоступна (а если и будет доступна, то ее окажется сложно использовать), нет графического интерфейса, и даже терминал может работать неправильно. По этой причине загрузка с «живых» образов более предпочтительна и эффективна._

_Примеры модулей ядра — это драйверы различных устройств._

### 1 Получение информации о модулях

Модули хранятся в директории /usr/lib/modules/ВЫПУСК_ЯДРА. Текущую папку с модулями можно узнать командой:

Имена модулей часто содержат символы подчёркивания (\_) или дефисы (\-); при этом данные символы являются взаимозаменяемыми в командах modprobe и в конфигурационных файлах в директории /etc/modprobe.d/.

Команда lsmod показывает драйверы и другие модули, которые загружены в данный момент.

```bash
lsmod
kmod list
```
- Какие модули загружены в данный момент. Информация считывается из /proc/modules и данные команды только выводят её в более понятном для восприятия виде
```bash
modinfo module_name
```
- Показ информации о модуле
- Строка «filename» показывает полный путь до файла модуля;
- В строке «author» содержится информация о создателе модуля
- В строке «description» описание модуля.
- firmware - многим устройствам для правильной работы нужны две вещи: драйвер и прошивка. Драйвер запрашивает прошивку из файловой системы в /lib/firmware. Это специальный файл, необходимый для аппаратного обеспечения, это не бинарный файл. Затем дайвер делает всё, что нужно для загрузки прошивки в устройство. Прошивка выполняет программирование оборудования внутри устройства.
- alias - модель устройства (бывают следующие параметры - pci: тип устройства, pci или usb, v обозначает идентификатор поставщика, он идентифицирует производителя оборудования, d обозначает идентификатор устройства, выбранный производителем, sv*, sd*: версия поставщика подсистемы и версия устройства подсистемы для дальнейшей идентификации устройства (* указывает, что оно будет соответствовать чему угодно, bc03: базовый класс. Это определяет, что это за устройство; Интерфейс IDE, контроллер Ethernet, контроллер USB, … bc03 означает контроллер дисплея. Вы можете заметить их из вывода lspci, потому что lspci сопоставляет число и класс устройства).
- intree: Y - Все модули ядра начинают свои разработки как вне дерева. Как только модуль принимается для включения, он становится модулем внутри дерева. Модули без этого флага (установленного в N) могут испортить ядро.
- vermagic - при загрузке модуля строка vermagic проверяются на совпадение с текущей версией ядра. Если они не совпадают, вы получите ошибку, и ядро откажется загружать модуль. Вы можете преодолеть это, используя в modprobe флаг --force. Естественно, эти проверки существуют для вашей защиты, поэтому использование этой опции опасно.
```bash
systool -v -m module_name
```
- Вывод списка опций, установленных для загруженного модуля
```bash
modprobe -c | less
```
- Отображение полной конфигурации всех модулей
```bash
modprobe -c | grep module_name
```
- Отобразить конфигурацию определённого модуля
```bash
modprobe --show-depends module_name
```
- Перечислить зависимости модуля (или псевдонима), включая сам модуль

### 2 Автоматическая загрузка модуля с помощью systemd

Сегодня загрузка всех необходимых модулей выполняется udev автоматически, поэтому нет необходимости помещать модули в какой-либо файл конфигурации. Однако в некоторых случаях вам может потребоваться загрузить дополнительный модуль во время процесса загрузки компьютера или добавить в чёрный список другой модуль для правильной работы компьютера.

Модули ядра могут быть явно перечислены в файлах в `/etc/modules-load.d/` для systemd, чтобы загрузить их во время включения компьютера. Каждый файл конфигурации имеет имя в стиле `/etc/modules-load.d/<program>.conf`. Файлы конфигурации просто содержат список имён модулей ядра для загрузки, разделённых символами новой строки. Пустые строки и строки, чей первый непробельный символ - # (решётка) или ; (точка с запятой) игнорируются. Кроме указанной директории, также считываются файлы конфигурации из `/run/modules-load.d/*.conf и /usr/lib/modules-load.d/*.conf`.

Обратите внимание, что обычно лучше полагаться на автоматическую загрузку модулей с помощью идентификаторов PCI, USB-идентификаторов, идентификаторов DMI или аналогичных триггеров, закодированных в самих модулях ядра, вместо статической конфигурации, подобной этой. Фактически, большинство современных модулей ядра уже подготовлены для автоматической загрузки.

### 3 Ручная обработка модуля (включение и отключение модулей и драйверов)

Модули ядра обрабатываются инструментами, предоставляемыми пакетом kmod. Вы можете использовать эти инструменты вручную.

Примечание. Если вы обновили ядро, но ещё не перезагрузили компьютер, modprobe завершится с ошибкой без сообщения об ошибке и выйдет с кодом 1, поскольку путь `/usr/lib/modules/$(uname -r)`/ больше не существует.

```bash
modprobe module_name
```
- Загрузить модуль
```bash
insmod file_name [АРГУМЕНТЫ]
```
- Чтобы загрузить модуль по имени файла (то есть, тот, который не установлен в /usr/lib/modules/$(uname -r)/)
```bash
modprobe -r module_name
# или
rmmod module_name
```
- Для выгрузки (выключения) модуля

### 4 Как задействовать драйвер без его установки

Рассмотрим реальный пример, когда может пригодиться запуск драйвера из файла.

Возьмём в качестве примера репозиторий драйверов для чипсета RTL8812AU/21AU и RTL8814AU.

**Эти драйвера предназначены для работы таких современных карт с поддержкой стандарта Wi-Fi AC как:**

- Alfa AWUS1900 (чипсет: Realtek RTL8814AU)
- TRENDnet TEW-809UB (чипсет: Realtek RTL8814AU)
- ASUS USB-AC68 (чипсет: Realtek RTL8814AU)
- Alfa AWUS036ACH (чипсет: Realtek RTL8812AU)
- Alfa AWUS036AC (чипсет: Realtek RTL8812AU)
- ASUS USB-AC56 (чипсет: Realtek RTL8812AU)

Эти драйвера поддерживают режим монитора и беспроводную инъекцию, то есть подходят для аудита безопасности Wi-Fi сетей на 2.4 и 5 Ghz, в том числе с поддержкой Wi-Fi стандарта AC.

```bash
apt show realtek-rtl88xxau-dkms
```
В принципе, в репозиториях Kali Linux уже имеется данный драйвер
```bash
git clone -b v5.6.4.2 https://github.com/aircrack-ng/rtl8812au.git
```
- Клонируем репозиторий - обратите внимание на использование опции -b с которой указана интересующая нас ветка (в данном случае название ветки совпадает с версией драйвера)

Компилируем его. У нас есть два способа загрузить (включить) модуль - с помощью insmod или с помощью команды modprobe. Команда insmod удобнее, т. к. можно указать скомпилированный файл драйвера, а команда modprobe лучше обрабатывает зависимости, поэтому рассмотрим оба варианта.

### 4.1 Загрузка модуля без установки (используя insmod)

**Для установки последней версии ядра достаточно выполнить следующие команды:**

`echo 'deb <http://deb.xanmod.org> releases main' | sudo tee /etc/apt/sources.list.d/xanmod-kernel.list`

```
wget -qO - <https://dl.xanmod.org/gpg.key> | sudo apt-key --keyring /etc/apt/trusted.gpg.d/xanmod-kernel.gpg add -
sudo apt update && sudo apt install linux-xanmod

```
```bash
insmod file_name args
```
- Включение модуля из файла. Файлы модулей имеют расширение .ko, в нашем случае имя файла 88XXau.ko
```bash
insmod ./88XXau.ko
```
```bash
lsmod | grep 88XXau
```
- Проверяем, был ли загружен модуль

если будет ошибка `modprobe: FATAL: Module 88XXau not found in directory /lib/modules/4.19.0-22-amd64`, то есть, неизвестный символ в модуле. Суть такая же - модуль не найден, но ранее существовал, поэтому от него остались упоминания в списках зависимостей.
```bash
sudo apt install build-essential bc libelf-dev
```
- Установим зависимости, необходимые для компиляции данного драйвера

Второй вариант чуть более сложный в настройке, но для загрузки модуля не нужно указывать полный путь до файла драйвера.
```bash
rmmod 88XXau
lsmod | grep 88XXau
```
- Выгрузим модуль, если он был загружен ранее

### 5 Запрет на включение модулей (чёрный список модулей)

Чёрный список в контексте модулей ядра - это механизм, предотвращающий загрузку модуля ядра. Это может быть полезно, если, например, связанное оборудование не требуется или если загрузка этого модуля вызывает проблемы: например, могут быть два модуля ядра, которые пытаются управлять одним и тем же компонентом оборудования, и загрузка их вместе приведёт к конфликту.

Использование файлов в `/etc/modprobe.d/`

Создайте файл .conf внутри `/etc/modprobe.d/` и добавьте строку для каждого модуля, который вы хотите добавить в черный список, используя ключевое слово `blacklist`. Например, если вы хотите запретить загрузку модуля `pcspkr`, создайте файл `/etc/modprobe.d/nobeep.conf` и **добавьте в него строку:** `blacklist pcspkr`

**Некоторые модули загружаются как часть initramfs. То есть можно выделить модули, которые:**

- загружаются из файлов .ko
- загружаются как часть initramfs (initial ramdisk)

Для запрета загрузки модулей первого типа (загружаемые из файлов .ko) достаточно внести запись об этом модуле в файл `/etc/modprobe.d/*.conf` с директивой `blacklist`. Для модулей второго типа (загружаемые как часть initramfs), кроме создания конфигурационного файла, также необходимо пересоздать initramfs.

Примечание: initramfs (initial ramdisk) — это начальная среда ramdisk для загрузки ядра Linux. Начальный ramdisk — это, по сути, очень маленькая среда (раннее пользовательское пространство), которая загружает различные модули ядра и настраивает необходимые вещи перед передачей управления init. Это позволяет, например, иметь зашифрованные корневые файловые системы и корневые файловые системы на программном массиве RAID.

Примечание. Команда blacklist внесёт модуль в чёрный список, чтобы он не загружался автоматически. Но при этом модуль может быть загружен, если от него зависит другой модуль, не включенный в чёрный список, а также по прежнему можно загрузить модуль вручную. Тем не менее есть обходной путь для этого поведения; Команда `install` указывает `modprobe` запускать пользовательскую команду вместо того, чтобы как обычно вставлять модуль в ядро, поэтому вы можете принудительно заставить модуль всегда не загружаться с помощью рассмотренной далее конструкции. Допустим, вы создали файл `/etc/modprobe.d/blacklist.conf` чтобы заблокировать загрузку модуля ИМЯ_МОДУЛЯ.

**Чтобы это сделать надёжно, добавьте в этот файл:**

- blacklist ИМЯ_МОДУЛЯ
- install ИМЯ_МОДУЛЯ /bin/true

**Это надёжно заблокирует загрузку указанного модуля, а также любого другого, зависящего от него.**

Если вы блокируете модули, которые загружаются из initramfs, то после их добавления в файл `/etc/modprobe.d/*.conf`, необходимо пересоздать `initramfs`.

### 6 Блокировка модулей в начале загрузки Linux (отключение модулей в командной строке ядра)

Это может быть очень полезно, если неисправный модуль делает невозможным загрузку вашей системы. Вы можете занести в чёрный список модули в меню загрузчика.

Просто добавьте в строку с параметрами загрузки ядра:

`module_blacklist=ИМЯ-МОДУЛЯ1,ИМЯ-МОДУЛЯ2,ИМЯ-МОДУЛЯ3`

### 7 Как заблокировать все сетевые интерфейсы на компьютере

Предположим, необходимо, чтобы на компьютере была заблокирована любая сетевая активность, то есть и проводные, и беспроводные сети. Существует команда rfkill, но она предназначена для блокировки только беспроводных сетей. Поэтому найдём другой способ.

**Алгоритм действий следующий:**

**Мы определим, какие драйверы используются сетевыми устройствами Заблокируем эти драйверы**

**Чтобы узнать, какие драйверы задействованы в Linux для работы сетевых карт, выполните команду:**

`sudo apt install lshw`

`sudo lshw -C network`

Строки «**configuration:**» содержат информацию о драйверах. Для беспроводной карты это «**если есть wi-fi: driver=iwlwifi**», а для проводного сетевого интерфейса это «**driver=e1000**».
```bash
blacklist e1000
install e1000 /bin/true
```
Создаём файл `/etc/modprobe.d/block-network.conf` и добавляем в него

```
blacklist iwlwifi
install iwlwifi /bin/true

blacklist e1000
install e1000 /bin/true

sudo update-initramfs -u

sudo reboot

```


После перезагрузки невозможно будет включить сеть, поскольку компьютер не сможет использовать сетевые интерфейсы без драйверов

Вы не сможете включить любую сеть вплоть до удаления файла `/etc/modprobe.d/block-network.conf` и перезагрузки. Тем не менее при подключении других сетевых адаптеров, они будут использоваться. Данный способ надёжно защитит от случайного использования сети при условии, что вы контролируете подключение новых физических устройств к компьютеру.

### 8 Как надёжно выключить веб камеру

На некоторых новых моделях ноутбуков веб-камеру можно закрыть шторкой — на тот случай, если вы опасаетесь, что хакер может взломать ваш компьютер и следить за вами.

Сейчас мы научимся отключать драйвер веб-камеры, чтобы её невозможно было использовать.

Даже если у вас ноутбук, скорее всего, веб-камера подключена внутри корпуса к USB хабу, то есть это USB устройство. Вывести список USB устройств в системе можно командой: `lsusb`

### 8.1 Как узнать, какие модули (драйверы) используются USB и PCI устройствами

### 8.1.1 Какие драйверы использует USB-устройство

Пакет usbutils включает скрипт, называемый usb-devices. Если вы запустите его, он выведет информацию об устройствах в системе, включая используемый драйвер: `usb-devices`

### 8.1.2 Используемые драйверы в lsusb

С помощью lsusb также можно увидеть используемые USB-устройством драйверы: `lsusb -t -v -v`

Но может возникнуть трудность с идентификацией устройства. В комбинации с lsusb без опций можно сопоставить устройства и драйверы: `lsusb`

### 8.1.3 lshw

Программа lshw показывает подробную информацию о железе (аппаратной составляющей) компьютера. В том числе выводит информацию о задействованных каждым устройством драйверах: `sudo lshw`

### 8.1.4 Драйверы, используемые PCI устройством

Если вас интересует, какой модуль ядра и какой драйвер использует PCI устройство, то выполните следующую команду: `sudo lspci -k`

### 8.1 usb-devices

Чтобы определить драйверы, которые нужны для работы любого USB или с PCI устройства в вашей системе, воспользуемся следующей командой: `sudo usb-devices`

Создаём файл `/etc/modprobe.d/block-webcam.conf` и блокируем в нём запуск модуля ядра `uvcvideo`:
```
blacklist uvcvideo
install uvcvideo /bin/true

sudo update-initramfs -u
sudo reboot

```

После перезагрузки система не сможет использовать веб-камеру, пока не будет удалён файл `block-webcam.conf` и выполнена перезагрузка.

### 9 Как отключить Bluetooth без возможности подключения

Модуль ядра bluetooth включён в ядро, поэтому удалением каких-то пакетов вроде bluez и blueman задачу отключения Bluetooth не решить — если удалить указанные пакеты у нас не будет инструментов и графических апплетов для наблюдением за Bluetooth, но это не означает, что на уровне ядра не будет выполнятся подключение Bluetooth устройств (например, USB адаптера Bluetooth), либо периферийные устройства не будут сопрягаться.

Реализовать на примере предедущих действий!

# Конфигурирование аппаратных средств

Одна из первых задач, стоящих перед ядром, - выявление компонентов аппаратного обеспечения. Создавая ядро для своей системы, вы можете указать, какие устройства оно должно проверять. Когда ядро начинает выполняться, оно пытается найти и инициализировать все устройства, о которых ему было сообщено. Большинство ядер выводят на консоль краткую информацию о каждом обнаруженном устройстве.

Информация об устройствах, задаваемая при конфигурировании ядра, зачастую является неполной. В таких случаях ядро пытается получить необходимые сведения, опрашивая системную шину на предмет наличия устройств и запрашивая нужную информацию у соответствующих драйверов. Драйверы отсутствующих или не отвечающих на контрольный сигнал устройств отключаются. Даже если позже устройство подключить к системе, оно будет недоступно для UNIX-процессов до тех пор, пока вы не перезагрузите машину.

# Создание процессов ядра

После завершения этапа базовой инициализации ядро создает в области памяти, выделенной для пользовательских программ, несколько «самовыполняющихся» процессов. Это происходит «в обход» стандартного системного механизма fork.

Количество таких процессов зависит от операционной системы, хотя демон init всегда имеет идентификатор процесса (PID), равный 1. Большинство систем UNIX использует sched в качестве процесса с идентификатором 0. В Linux процесс с идентификатором PID, равным 0, отсутствует. Демон init работает в сопровождении с различными обработчиками памяти и сигналов ядра. Все эти процессы имеют идентификаторы с низкими номерами, а их имена в листингах команды ps заключены в квадратные скобки (например, `kacpid`). Иногда имена процессов могут содержать в конце символ косой черты и цифру, как, например, `kblockd/0`.

Число указывает процессор, на котором выполняется данный процесс. Эта информация может быть полезна при настройке многопроцессорной системы.

Некоторые наиболее часто встречающиеся процессы ядра в Linux-системах

|Процесс|Назначение|
|---|---|
|kjournald|Записывает обновления журнала на диска|
|kswapd|Выполняет подкачку процессов при недостаточном объеме физической памяти|
|ksoftirqd|Обрабатывает мягкие прерывания, если ими нельзя заняться во время переключения контекста|
|khubd|Выполняет конфигурирование USB-устройств|

Для каждой смонтированной файловой системы ext3 или ext4 существует один процесс kjoumald.

Из этих процессов только init является полноценным пользовательским процессом; остальные фактически представляют собой части ядра, которые были сделаны процессами из концептуальных соображений.

После создания этих процессов ядро больше не принимает участия в процедуре начальной загрузки системы. К этому моменту, однако, еще не создан ни один из процессов, управляющих базовыми операциями (например, регистрацией пользователей в системе), и большинство демонов не запущено. Обо всем этом позаботится (в некоторых случаях косвенно) демон init.

# Действия оператора (только в режиме восстановления)

Если систему нужно запустить в режиме восстановления, оператор устанавливает в командной строке специальный флаг, а ядро передает эту информацию демону init в качестве уведомления о запуске. Во время однопользовательской загрузки вы должны получить приглашение ввести пароль пользователя root. Если он введен правильно, запускается интерпретатор команд с правами суперпользователя. Можно не задавать пароль, а просто нажать комбинацию клавиш `Ctrl+D`, после чего загрузка продолжится в многопользовательском режиме

В однопользовательском режиме команды выполняются почти так же, как и в полностью загруженной системе. Однако иногда монтируется только корневой раздел. Для того чтобы можно было использовать программы, находящиеся вне каталогов /bin, /sbin или /etc, необходимо вручную смонтировать остальные файловые системы.

Во многих однопользовательских средах корневой каталог файловой системы монтируется в режиме только для чтения. Если каталог /etc является частью корневой файловой системы (обычная ситуация), редактирование многих файлов конфигурации будет невозможно. Чтобы выйти из положения, придется начать однопользовательский сеанс с повторного монтирования каталога / в режиме чтения/записи. Нужное действие в Linux-системах выполняет следующая команда: `mount -о rw, remount /`

В большинстве других систем вы можете выполнить команду `mount /`, чтобы реализовать обращение к файлу fstab или vfstab и выяснить, как должна быть смонтирована файловая система.

Команда fsck, которая проверяет и восстанавливает поврежденные файловые системы, обычно выполняется в ходе автоматической загрузки. Если система запускается в однопользовательском режиме, команду `fsck` придется вводить вручную.

Когда интерпретатор команд однопользовательского режима завершит свою работу, система продолжит загрузку в нормальном режиме.

# Выполнение сценариев запуска системы

В тот момент, когда система сможет выполнять сценарии запуска, ее уже можно назвать UNIX. Это еще не полностью загруженная система, но «загадочных» этапов процесса загрузки больше не осталось. Файлы сценариев представляют собой обычные командные файлы, которые выбираются и запускаются демоном init по сложному, но, в общем-то, понятному алгоритму.

Точное местонахождение, содержимое и организация сценариев запуска заслуживают отдельного изучения.

# Завершение процесса загрузки

После выполнения сценариев инициализации система полностью готова к работе. Такие системные демоны, как DNS- и SMTP-серверы, принимают и обслуживают подключения. Не забывайте о том, что демон init продолжает играть важную роль даже по завершении начальной загрузки.

У демона init есть один однопользовательский и несколько многопользовательских «уровней выполнения», определяющих, какие ресурсы системы будут доступны пользователю.

# Компоненты

## 1 Ядро

Яд­ро, хоть и кри­тичес­ки важ­но для работы сис­темы, осо­бо не инте­рес­но с точ­ки зре­ния поль­зовате­ля - вза­имо­дей­ство­вать с ним нап­рямую вряд ли при­дет­ся.

Воз­можно, ты час­то слы­шал про «сбор­ку ядра» и можешь даже самос­тоятель­но поп­робовать сде­лать это. Пос­коль­ку ядро Linux монолит­ное, в него дол­жна вхо­дить под­дер­жка мно­жес­тва вещей, которые каса­ются всех аспектов работы компь­юте­ра. Соот­ветс­твен­но, перед сбор­кой мож­но и нуж­но задать кучу вся­ких нас­тро­ек, но ничего осо­бен­но увле­катель­ного в этом нет, хотя про­цесс край­не поз­наватель­ный.

В сис­теме может одновре­мен­но при­сутс­тво­вать сколь­ко угод­но ядер, а какое имен­но будет исполь­зовать­ся, ты можешь выб­рать в заг­рузчи­ке. Апгрейд ядра до более новой вер­сии - совер­шенно рутин­ное дело в Linux и обыч­но про­исхо­дит авто­мати­чес­ки.

## 2 Пакетный менеджер

Лю­бой Linux сос­тоит из тысяч мел­ких ком­понен­тов - прог­рамм, биб­лиотек и ресур­сов (нап­ример, фай­лов кон­фигура­ции, наборов ико­нок и так далее). Рас­простра­няют­ся они в виде пакетов (package).

Па­кет­ный менед­жер - это спе­циаль­ная прог­рамма, которая выпол­няет уста­нов­ку, нас­трой­ку, уда­ление, а так­же обновле­ние как отдель­ных при­ложе­ний, так и всей сис­темы в целом или ее ком­понен­тов.

Очень час­то один пакет тре­бует для работы наличия дру­гих, и сле­дить за эти­ми зависи­мос­тями вруч­ную на сов­ремен­ной сис­теме невоз­можно. Поэто­му осно­ва каж­дого дис­три­бути­ва - это пакет­ный менед­жер, который рулит уста­нов­кой и обновле­нием соф­та. В дис­три­бути­вах, осно­ван­ных на Debian, он называ­ется APT, в Red Hat - DNF, а в Arch - pacman.

Па­кеты менед­жер берет из репози­тория - боль­шого скла­да, куда соз­датели дис­три­бути­ва заг­ружа­ют их. Репози­тори­ев зачас­тую мож­но под­клю­чить сра­зу нес­коль­ко. Нап­ример, в Ubuntu есть четыре основных: Main (под­держи­ваемый раз­работ­чиками), Universe (под­держи­ваемый сооб­щес­твом), Restricted (с проп­риетар­ным ПО) и Multiverse (с ПО, на которое дей­ству­ют нес­вобод­ные лицен­зии).

Пос­коль­ку вско­ре пос­ле уста­нов­ки Linux ты обна­ружишь необ­ходимость в драй­верах для железа, допол­нитель­ных шриф­тах, кодеках и тому подоб­ных вещах, ско­рее все­го, понадо­бит­ся раз­решить сис­теме дос­туп к запят­нанным ком­мерци­ей репози­тори­ям. В Ubuntu это дела­ется в меню «Прог­раммы и обновле­ния».

## 3 Графическая система

Да­леко не каж­дый Linux снаб­жен гра­фичес­кой сис­темой или вооб­ще нуж­дает­ся в ней - очень мно­гие дей­ствия здесь мож­но делать и из коман­дной стро­ки. Одна­ко сов­ремен­ный рабочий стол - это все же икон­ки и окош­ки.

Что­бы работать с гра­фикой, в Linux дол­жны при­сутс­тво­вать сер­вер дис­плея X.Org (тра­дици­онный вари­ант) либо новомод­ный ком­позитор Wayland, на который сей­час перехо­дят наибо­лее передо­вые дис­три­бути­вы. Плюс тре­бует­ся окон­ный менед­жер - прог­рамма, которая отве­чает за то, как выг­лядят и работа­ют эле­мен­ты интерфей­са.

Впро­чем, это всё доволь­но низ­коуров­невые под­робнос­ти, нырять в которые с ходу не обя­затель­но. Куда ско­рее тебе при­дет­ся задумать­ся о выборе рабочей сре­ды (Desktop Environment, DE). Это совокуп­ность окон­ного менед­жера и раз­ного рода прог­рамм, мел­ких (нап­ример, рису­ющих раз­ные панели, рабочий стол, вид­жеты) и круп­ных - вро­де фай­лового менед­жера. Сюда же обыч­но вхо­дит и набор базово­го соф­та: кален­дарь, поч­товик и про­чее в таком духе.

Са­мые извес­тные окон­ные сре­ды - это GNOME и KDE. Но в реаль­нос­ти их спи­сок гораз­до длин­нее. Любите­ли минима­лиз­ма могут прис­мотреть­ся к Xfce или LXDE, а Ratpoison, dwm, i3 и xmonad пре­дос­тавля­ют сре­ду с неперек­рыва­ющи­мися окна­ми, что некото­рые находят удоб­ным.

А еще от GNOME отва­лились про­екты MATE и Cinnamon - их раз­работ­чикам не пон­равил­ся интерфейс GNOME 3, и они про­дол­жили раз­вивать вто­рую вет­ку. А в elementary OS исполь­зует­ся своя сре­да под наз­вани­ем Pantheon, которую не встре­тишь боль­ше ниг­де.

Соз­датели дис­три­бути­вов, в которые вхо­дит гра­фичес­кая сре­да, обыч­но выбира­ют одну или нес­коль­ко сред, которые будут под­держи­вать офи­циаль­но. Но при этом тебе нич­то не меша­ет поменять DE или уста­новить одновре­мен­но боль­ше одной, что­бы перек­лючать­ся меж­ду ними или исполь­зовать прог­раммы одной сре­ды из дру­гой. Про­буй, экспе­римен­тируй, и сам пой­мешь, что тебе бли­же.

## 4 Командный интерпретатор

Поль­зовате­ли Windows при­вык­ли к тому, что в этой опе­раци­онной сис­теме име­ется стан­дар­тный интер­пре­татор команд cmd.exe, который при­нято называть коман­дной стро­кой. В пос­ледних вер­сиях вин­ды его орга­нич­но допол­нил PowerShell, одна­ко эти­ми дву­мя сре­дами ассорти­мент коман­дных интер­пре­тато­ров в Windows исчерпы­вает­ся.

В Linux коман­дных интер­пре­тато­ров сущес­тву­ет мно­жес­тво, и, если для Windows они лишь вспо­мога­тель­ное средс­тво адми­нис­три­рова­ния, здесь это один из основных и очень мощ­ных инс­тру­мен­тов работы с сис­темой.

Собс­твен­но, сама исто­рия Linux началась имен­но с коман­дной стро­ки, точ­нее тер­минала или даже телетай­па. Гра­фичес­кий интерфейс к нему при­дела­ли уже зна­читель­но поз­же. Имен­но поэто­му коман­дную стро­ку в Linux час­то называ­ют «эму­лятор тер­минала», а про­цес­сы с ними носят пре­фикс tty (teletype).

Как ты зна­ешь, с исполь­зовани­ем команд в Windows мож­но писать скрип­ты, авто­мати­зиру­ющие какие‑либо дей­ствия: пакет­ные фай­лы (batch files) были в ходу еще со вре­мен MS-DOS, а PowerShell замет­но рас­ширил и углу­бил эту тех­нологию. В Linux мож­но делать то же самое: соб­ранный в файл набор команд интер­пре­тато­ра может работать как слож­ная прог­рамма, а сами коман­ды явля­ются по боль­шому сче­ту язы­ком прог­рамми­рова­ния.

На­боры команд, сох­ранен­ные одним фай­лом, при­нято называть сце­нари­ями или скрип­тами. Все скрип­ты в Linux начина­ются с сим­волов #! (это сочета­ние называ­ется «шебанг») и пути к интер­пре­тато­ру - коман­де, которая будет исполнять скрипт.

Стан­дар­тным коман­дным интер­пре­тато­ром в Linux явля­ется bash - обновлен­ная и модер­низиро­ван­ная вер­сия коман­дной обо­лоч­ки Bourne shell, которая была изоб­ретена Сти­веном Бор­ном в 1978 году и исполь­зовалась еще в клас­сичес­ком Unix.

Прож­женные линук­соиды пред­почита­ют ста­вить вмес­то bash более прод­винутый интер­пре­татор - Z shell (ZSH), обратно сов­мести­мый с bash, но име­ющий по срав­нению с ним мно­жес­тво улуч­шений. Для этой обо­лоч­ки сооб­щес­твом был раз­работан спе­циаль­ный откры­тый и бес­плат­ный фрей­мворк Oh My ZSH, который содер­жит мно­жес­тво пла­гинов для авто­мати­зации работы с коман­дами и скрип­тами. Как минимум Oh My ZSH поз­воля­ет исполь­зовать кра­сивые темы офор­мле­ния окна коман­дной стро­ки, бла­года­ря которым окру­жающие точ­но соч­тут тебя гени­аль­ным хакером. Пре­дуп­редим о проб­леме, с которой момен­таль­но стал­кива­ется каж­дый новый поль­зователь Linux. Если ты зай­дешь в какой‑то каталог и попыта­ешь­ся написать наз­вание исполня­емо­го фай­ла, что­бы запус­тить его, то ничего не получит­ся.

При­чина в том, что интер­пре­татор ищет фай­лы толь­ко в катало­гах, которые ука­заны в перемен­ной окру­жения $PATH. То есть тебе нуж­но либо задать пол­ный путь к исполня­емо­му фай­лу, либо явно ука­зать на текущий каталог. Как ты зна­ешь, родитель­ский каталог отме­чает­ся дву­мя точ­ками (../), а что­бы ука­зать на текущий, нуж­но писать ./. То есть вмес­то program пиши ./program, и все получит­ся!

И еще один очень важ­ный момент. В Windows тип фай­ла опре­деля­ется его рас­ширени­ем - в зависи­мос­ти от него коман­дный интер­пре­татор и обо­лоч­ка реша­ют, как они будут обра­баты­вать файл. В Linux все устро­ено нем­ного по‑дру­гому: у bash пол­ностью отсутс­тву­ет какое‑либо ува­жение к рас­ширени­ям фай­лов. Исполня­емый файл отли­чает­ся от обыч­ного не рас­ширени­ем, а наличи­ем пра­ва на его исполне­ние: если оно есть, сис­тема счи­тает такой файл прог­раммой (или скрип­том) и пыта­ется выпол­нить. О пра­вах на фай­лы мы под­робнее погово­рим чуть даль­ше в соот­ветс­тву­ющем раз­деле.

## 5 Домашние каталоги и скрытые файлы

Пос­коль­ку Linux изна­чаль­но задумы­вал­ся как мно­гополь­зователь­ская опе­раци­онная сис­тема, все пути к «домаш­ним» пап­кам, перемен­ные окру­жения, прог­раммы, которые запус­кают­ся при откры­тии тер­минала, и дру­гие нас­трой­ки зада­ются в про­филе поль­зовате­ля. У раз­ных юзе­ров они, соот­ветс­твен­но, раз­ные. Бла­года­ря это­му ты можешь, нап­ример, нас­тро­ить сис­темное окру­жение так, как ком­фор­тно имен­но тебе.

Что­бы ука­зывать на домаш­ний каталог, очень удоб­но исполь­зовать сим­вол ~. Так, вмес­то /home/vasya/ мож­но писать прос­то ~/, если ты залоги­нен как vasya.

В Linux час­то встре­чает­ся то, что в Windows поп­росту невоз­можно: фай­лы, имя которых начина­ется с точ­ки (поль­зовате­ли вин­ды с неп­ривыч­ки дума­ют, буд­то это фай­лы без име­ни, име­ющие одно толь­ко рас­ширение). На самом деле в Linux так обоз­нача­ют скры­тые фай­лы. Нап­ример, имя .htacess говорит нам о том, что этот файл скры­тый, - бла­года­ря наличию точ­ки перед име­нем его лег­ко отли­чить от дру­гих фай­ловых объ­ектов.

В домаш­нем катало­ге поль­зовате­ля хра­нит­ся нес­коль­ко скры­тых фай­лов, которые могут быть очень полез­ны при работе в Linux. Что­бы прос­мотреть скры­тые фай­лы в текущем катало­ге, исполь­зуй кон­соль­ную коман­ду ls -a или поковы­ряй­ся в меню фай­лового менед­жера: нап­ример, в Nautilus пункт «Показать скры­тые фай­лы» пря­чет­ся в меню «Вид». Обра­ти вни­мание на сле­дующие скры­тые фай­лы:

- .bash_profile - содер­жит информа­цию о поль­зователь­ском окру­жении и запус­каемых при авто­риза­ции поль­зовате­ля прог­раммах. В некото­рых дис­три­бути­вах, осно­ван­ных на Debian, дан­ного фай­ла по умол­чанию не сущес­тву­ет, но ты можешь соз­дать его самос­тоятель­но;
- .bash_login - этот файл исполня­ется, если отсутс­тву­ет .bash_profile, и выпол­няет схо­жую фун­кцию. Это­го фай­ла не сущес­тву­ет по умол­чанию ни в дис­три­бути­ве Debian, ни в дис­три­бути­ве Red Hat;
- .profile - выпол­няет­ся при отсутс­твии .bash_profile и .bash_login;
- .bash_logout - сце­нарий, который выпол­няет­ся авто­мати­чес­ки при завер­шении работы коман­дной обо­лоч­ки;
- .bash_history - хра­нит информа­цию обо всех коман­дах, наб­ранных в bash;
- .ssh - каталог, в котором хра­нят­ся клю­чи шиф­рования для под­клю­чения по SSH;
- .bashrc - сце­нарий, который обыч­но нас­тра­ивает­ся дру­гими сце­нари­ями для сво­их собс­твен­ных нужд - нап­ример, запус­ка демонов или обра­бот­ки каких‑либо команд.

## 6 Ввод-вывод и пайпы

Боль­шинс­тво прог­рамм, работа­ющих из коман­дной стро­ки, при­нима­ют дан­ные на вход и что‑то выда­ют на выходе. При этом вывод одной прог­раммы мож­но нап­равить на ввод дру­гой и таким обра­зом дос­тичь какой‑то более слож­ной цели или авто­мати­зиро­вать какой‑то про­цесс. Давай раз­берем­ся под­робнее.

Стан­дар­тный поток вво­да, к которо­му по умол­чанию «при­вяза­на» кла­виату­ра, называ­ется standard input (stdin). Стан­дар­тный поток вывода носит наз­вание standard output (stdout). Сущес­тву­ет и отдель­ный поток вывода, пред­назна­чен­ный исклю­читель­но для сооб­щений об ошиб­ках. Он называ­ется standard error, или stderr. По умол­чанию с эти­ми дву­мя потока­ми вывода свя­зан монитор.

По­токи при­ложе­ний и команд мож­но перенап­равлять в фай­лы или в дру­гие коман­ды. Пос­коль­ку стан­дар­тные потоки вво­да‑вывода пред­назна­чены в основном для обме­на тек­сто­вой информа­цией, такое перенап­равле­ние поз­воля­ет наладить «обще­ние» прог­рамм меж­ду собой.

Са­мый прос­той при­мер подоб­ного обще­ния — это ког­да мы переда­ем стан­дар­тный вывод (stdout) одной прог­раммы на стан­дар­тный ввод (stdin) дру­гой. Такой вари­ант перенап­равле­ния обоз­нача­ется в Linux сим­волом | и называ­ется тер­мином «кон­вей­ер» или «пайп» (pipe). Нап­ример, если мы исполь­зуем запись вида команда 1 | команда 2, это будет озна­чать, что весь стан­дар­тный вывод коман­ды 1, который по умол­чанию был бы нап­равлен на дис­плей (stdout), будет передан на стан­дар­тный ввод (stdin) коман­ды 2. Это и есть реали­зация прос­тей­шего пай­па или кон­вей­ера.

Воз­можно, ты уже натыкал­ся на исполь­зование пай­пов в сочета­нии с коман­дой grep, пред­назна­чен­ной для филь­тра­ции тек­сто­вых дан­ных. Работа­ет она так:

$ команда | grep [опции] шаблон где команда - это коман­да, стан­дар­тный вывод которой перенап­равля­ется коман­де grep; опции - это раз­личные парамет­ры поис­ка; шаблон - стро­ка или зна­чение, которые мы ищем.

Нап­ример, коман­да ls | grep string озна­чает, что мы, получив спи­сок содер­жимого текущей дирек­тории c помощью кон­соль­ной коман­ды ls, ищем в нем файл или пап­ку, в име­ни которых содер­жится стро­ка string.

Еще вывод коман­ды быва­ет удоб­но перенап­равить в файл. Напиши ls -lha > list.txt, и получишь файл list.txt с под­робным перечис­лени­ем все­го, что содер­жится в текущем катало­ге.

## 7 Файловые системы

В Linux есть под­дер­жка раз­ных фай­ловых сис­тем. Любой сов­ремен­ный Linux по умол­чанию уста­нав­лива­ется на ext4 и тре­бует соз­дания отдель­ного раз­дела типа Swap (ана­лог фай­ла под­качки в Windows). Помимо это­го, обыч­но под­держи­вают­ся дис­ки ext2 и ext3, XFS и FAT раз­ных вер­сий. В Ubuntu и некото­рых дру­гих дис­три­бути­вах из короб­ки дос­тупна работа с раз­делами NTFS на чте­ние и запись. Что до маков­ских HFS+ и APFS, то для них обыч­но тре­бует­ся отдель­ный драй­вер.

Что­бы работать с какой‑то ФС (рас­положен­ной на жес­тком дис­ке или на внеш­нем носите­ле), ее нуж­но при­мон­тировать, а перед завер­шени­ем работы — демон­тировать. За это отве­чают коман­ды mount и umount. В фай­ле /etc/fstab ука­зыва­ются сис­темы, которые Linux будет мон­тировать авто­мати­чес­ки при заг­рузке.

От­дель­ного упо­мина­ния зас­лужива­ет сис­тема FUSE — Filesystem in Userspace (в про­тиво­вес под­дер­жке на уров­не ядра). Через эту шту­ку мож­но под­клю­чать непод­держи­ваемые по умол­чанию фай­ловые сис­темы или даже сде­лать подобие фай­ловой сис­темы из API облачно­го сер­виса. Под­робнее об этом читай в статье «Все есть файл! Мон­тиру­ем Git-репози­тории, FTP- и SSH-ресур­сы, ZIP-архи­вы, тор­ренты, маг­нитные ссыл­ки и мно­гое дру­гое».

Последним связующим звеном между ядром и пользовательским пространством для дисков обычно является файловая система — то, с чем вы взаимодействуете при выполнении таких команд, как **ls и cd**.

В свое время все файловые системы располагались на дисках и других физических носителях, предназначенных исключительно для хранения данных. Однако древовидная структура каталогов и интерфейс ввода-вывода файловых систем довольно универсальны, поэтому файловые системы теперь выполняют множество задач, к примеру, роль системных интерфейсов, которые отображаются в каталогах в `/sys` и `/proc`. Файловые системы традиционно реализуются в ядре, но инновационный протокол 9P из системы Plan9 `(en.wikipedia.org/wiki/9P_(protocol))` вдохновил разработчиков на создание файловых систем пользовательского пространства. Функция файловой системы в пользовательском пространстве **(File System in User Space, FUSE)** позволяет создавать файловые системы в пользовательском пространстве в Linux.

Уровень абстракции виртуальной файловой системы **(Virtual File System, VFS)** завершает реализацию файловой системы. Подобно тому как подсистема SCSI стандартизирует связь между различными типами устройств и командами управления ядром, VFS гарантирует, что все реализации файловой системы поддерживают стандартный интерфейс, чтобы приложения пользовательского пространства могли одинаково обращаться к файлам и каталогам. Поддержка VFS позволила Linux поддерживать чрезвычайно большое количество файловых систем.

- **Типы файловых систем**
    
    Поддержка файловой системы Linux включает в себя собственные проекты, оптимизированные для Linux, а также внешние типы файловых систем, **например Windows FAT**, универсальные файловые системы, такие как **ISO 9660**, и многие другие. Далее перечислены наиболее распространенные типы файловых систем для хранения данных. Имена типов, распознанные Linux, заключены в круглые скобки рядом с именами файловых систем.
    
    1. _**Четвертая расширенная файловая система**_ **(Fourth Extended filesystem, ext4)** — это текущая итерация линейки файловых систем, родных для Linux._Вторая расширенная файловая система_ (ext2) долго использовалась по умолчанию для систем Linux, вдохновленных традиционными файловыми системами Unix, такими как файловая система Unix (Unix File System,UFS) и быстрая файловая система (Fast File System, FFS)._Третья расширенная файловая система_ (ext3) добавила функцию журналирования (небольшой кэш вне обычной структуры данных файловой системы) для повышения целостности данных и ускорения загрузки. Файловая система ext4 является дальнейшим улучшением и поддерживает файлы большего размера, чем ext2 или ext3, а также большее количество подкаталогов.
    2. _**В расширенной серии файловых систем**_ существует определенная обратная совместимость. Например, вы можете монтировать файловые системы: ext2 и ext3 взаимозаменяемо и монтировать файловые системы ext2 и ext3 как ext4, но не можете монтировать ext4 как ext2 или ext3.
    3. _**Файловая система Btrfs (B-tree filesystem)**_ — это новейшая файловая система, родная для Linux и расширяющая возможности файловой системы ext4.
    4. _**Файловые системы FAT (msdos, vfat, exfat)**_ относятся к системам Microsoft. Простой тип msdos поддерживает очень примитивное однообразное множество систем MS-DOS. Большинство съемных флеш-носителей, таких как SD-карты и USB-накопители, по умолчанию содержат разделы vfat (до 4 Гбайт) или exfat (4 Гбайт и более). Системы Windows могут использовать либо файловую систему на основе FAT, либо более продвинутую файловую систему NT (ntfs).
    5. _**XFS**_ — это высокопроизводительная файловая система, применяемая по умолчанию некоторыми дистрибутивами, такими как Red Hat Enterprise Linux 7.0 и более высоких версий.
    6. _**HFS+ (hfsplus)**_ — это стандарт файловой системы Apple, используемый в большинстве систем Macintosh.
    7. _**Файловая система ISO9660 (iso9660)**_ — это стандарт CD-ROM. Большинство CD-приводов применяют разновидности стандарта ISO 9660.

**Эволюция файловой системы Linux**

Большинство пользователей давно применяют серию расширенных файловых систем **(Extended filesystem)**, и тот факт, что она так долго оставалась стандартом, свидетельствует не только о ее эффективности, но и об адаптивности. Сообщество разработчиков Linux имеет тенденцию полностью заменять компоненты, которые не отвечают сиюминутным потребностям, но каждый раз, когда расширенной файловой системе чего-то не хватает, кто-то ее обновляет. Тем не менее в технологии файловых систем есть много того, что даже **ext4** не может использовать из-за требований обратной совместимости. Это связано в первую очередь с улучшением масштабируемости, относящимся к очень большому количеству файлов, большим файлам и аналогичным сценариям.На момент написания этого текста система **Btrfs** является стандартом по умолчанию для одного основного дистрибутива Linux. Если этот выбор окажется успешным, вполне вероятно, что **Btrfs** заменит серию расширенных файловых систем.

**В системах Unix** процесс присоединения файловой системы к работающей системе называется монтированием. Когда система загружается, ядро считывает некоторые данные конфигурации и на их основе монтирует корневой каталог (/).

**Чтобы примонтировать файловую систему, необходимо знать:**

- устройство, местоположение или идентификатор файловой системы (например, раздел диска, в котором хранятся ее фактические данные). Некоторые файловые системы специального назначения, такие как proc и sysfs, не имеют местоположения;
- тип файловой системы;
- точку монтирования (mountpoint) — место в иерархии каталогов текущей системы, к которому будет присоединена файловая система. Точка монтирования всегда является обычным каталогом. Например, вы можете использовать каталог /music в качестве точки монтирования для файловой системы, содержащей музыку. Точка монтирования не обязательно должна находиться непосредственно под корневым каталогом / — она может располагаться в любом месте системы.

```
mkfs -t ext4 /dev/sdb1
```
- Форматирование созданного раздела

### Управление файловой системой

- Управление файловой системой - процесс создания и поддержки хранилищ данных на диске или других устройствах хранения данных. Линукс поддерживает различные файловые системы (ext2, ext3, ext4, XFS, Btrfs, NTFS), которые используются в различных ситуациях в зависимости от требований приложения или пользователя.
- Файловая система Линукс основана на файловой системе Unix, которая представляет собой иерархическую структуру, состоящую из различных компонентов. Наверху этой структуры находится таблица inode, основа всей файловой системы. Таблица inode — это таблица информации, связанной с каждым файлом и каталогом в системе Линукс. inodes содержат метаданные о файле или каталоге, такие как его разрешения, размер, тип, владелец и т. д. Таблица inode похожа на БД с информацией о каждом файле и каталоге в системе Линукс, что позволяет ОС быстро получать доступ к файлам и управлять ими. Файлы могут храниться в файловой системе Линукс одним из двух способов: файлы, каталоги и ссылки на другие файлы/каталоги. Каталоги используются для хранения набора файлов. Символические ссылки используются для быстрого доступа к файлам, расположенным в разных частях файловой системы. 

### Файловая система Linux

- __/__: Директория верхнего уровня является корневой файловой системой и содержит все файлы, необходимые для загрузки ОС до монтирования других файловых систем, а также файлы, необходимые для загрузки других файловых систем. После загрузки все остальные файловые системы монтируются в стандартные точки монтирования как подкатологи корня
- __/bin__: Двоичные файлы многих основных программ, которые должны присутствовать при монтировании системы (Например, cat, ls cp)
- __/sbin__: Исполняемые файлы, используемые для системного администрирования
- __/boot__: Файлы для загрузки системы (Статический загрузчик, исполняемый файл ядра и файлы, необходимые для загрузки ОС)
- __/dev__: Файлы устройств для облегчения доступа к каждому аппаратному устройству, подключенному к системе
- __/etc__: Файлы конфигурации локальной системы и установленных приложений (Например, файл паролей или файлы настроек сетей)
- __/home__: Домашний каталог пользователей
- __/lib__: Файлы библиотек, необходимые двоичным файлам в каталогах bin, sbin для загрузки системы
- __/media__: Место монитрования внешних съемных носителей (Например, USB drives)
- __/mnt__: Временная точка монтирования для обычных файловых систем. Используется администратором системы для ручного монтирования файловых систем
- __/opt__: Используется проприентарным ПО для хранения дополнительных пакетов ПО
- __/proc__: Автоматически сгенерированные файлы системы, которые содержат информацию о запущенных процессах и состоянии ядра
	- __/proc/cpuinfo__: Информация о процессоре
	- __/proc/interrupts__: Информация о прерываниях
	- __/proc/swaps__: Информация о файлах подкачки
	- __/proc/version__: Информация о версии ядра
	- __/proc/meminfo__: Информация об использовании памяти
	- __/proc/netdev__: Информация о сетевых интерфейсах и их статистики
	- __/proc/mounts__: Информация о смонтированных файловых системах
- __/root__: Домашняя директория для пользователя root
- __/run__: Данные программ во время выполнения (Например, сокеты, ID процессов)
- __/srv__: Специфичные данные, обслуживаемые этой системой (Например, файлы Apache)
- __/sys__: Виртуальный диалог, представляющий информацию о системе
- __/tmp__: Временные файлы, которые удаляются при перезагрузке системы
- __/usr__: Исполняемые файлы пользовательских программ
- __/var__: Файлы переменных данных (Например, файлы журналов, кэш программ, cron)
	- **/var/cache**: Данные кэша приложений. Сюда скачиваются пакеты перед их установкой в систему
	- **/var/lib**: Информация о состоянии. Постоянные данные, изменяемые программами в процессе работы
	- **/var/lock**: Lock-файлы, указывающие на занятость некоторого ресурса
	- **/var/log**: Файлы событий
	- **/var/mail**: Почтовые ящики пользователей
	- **/var/run**: Информация о запущенных программах
	- **/var/spool**: Задачи, ожидающие обработки (Например, очередь печати, непрочитанные или неотправленные письма)
	- **/var/tmp**: Временные файлы, которые должны быть сохранены между перезагрузками
	- **/var/www**: Директорий веб-сервера Apache

### Управление дисками

- Управление дисками включает управление физическими устройствами хранения данных (SSD, HDD, сьемные устройства хранения данных).
- __fdisk__ - основная утилита для управления дисками, которая позволяет создавать, удалять и управлять разделами диска. Также отображает информацию о таблице разделов, их размеры и типы. Разделение диска позволяет разделить физическое пространство на отдельные разделы для форматирования в различные файловые системы.
- Монтирование (mounting) - подключение диска к определенному каталогу, что делает его доступным для иерархии файловой системы. После монтирования диска, к нему можно получить доступ и управлять также, как и любым другим каталогом в системе. 
- Нельзя отключить монтированную файловую систему, если она имеет запущенный процесс. Посмотреть список открытых файлов lsof.
- Файл __/etc/fstab__ содержит информацию обо всех файловых системах, смонтированных в системе, включая параметры автоматического монтирования во время загрузки и другие параметры монтирования. Чтобы автоматически размонтировать файловую систему при завершении работы, необходимо добавить запись с параметром __noauto__ в файл __/etc/fstab__.

### SWAP

- __Swapping__ - ​процесс ​переноса ядром неактивных страниц памяти в _swap space_, освобождая физическую память для использования активными процессами, когда в системе заканчивается физическая память.
- __Swap space__ можно создать либо во время установки ОС, либо в любое время после нее с помощью команд __mkswap__ и __swapon__.
- Команда __mkswap__ используется для настройки _swap space_ Линукс на устройстве или в файле, а команда __swapon__ используется для активации _swap space_. Размер _swap space_ зависит от личных предпочтений и зависит от объема физической памяти, установленной в системе, и типа использования, которому будет подвергаться система. При создании _swap space_ важно убедиться, что оно размещено в выделенном разделе или файле, отдельном от остальной файловой системы. Это помогает предотвратить фрагментацию _swap space_ и гарантирует, что в системе будет достаточно _swap space_, когда это необходимо. Также важно убедиться, что _swap space_ зашифровано, поскольку конфиденциальные данные могут временно храниться в _swap space_.
- Помимо использования в качестве расширения физической памяти, _swap space_ также можно использовать для спящего режима, который представляет собой функцию управления питанием, которая позволяет системе сохранять свое состояние на диск, а затем выключаться вместо полного выключения. При последующем включении системы она может восстановить свое состояние из _swap space_, вернувшись в состояние, в котором она находилась до выключения.

## 8 Пользователи, права на файлы

Linux изна­чаль­но задумы­вал­ся как мно­гополь­зователь­ская сис­тема, а потому раз­деление фай­лов и про­филей поль­зовате­лей здесь орга­низо­вано на высочай­шем уров­не. Поль­зователь с огра­ничен­ными пра­вами в сис­теме может вза­имо­дей­ство­вать с теми или ины­ми фай­лами и катало­гами.

Важ­но пом­нить, что в Linux сущес­тву­ет супер­поль­зователь с име­нем root, обла­дающий пол­ными адми­нис­тра­тор­ски­ми при­виле­гиями в опе­раци­онной сис­теме, — так ска­зать, самый глав­ный босс всех бос­сов. Он может соз­давать и уда­лять учет­ки дру­гих юзе­ров и вооб­ще менять гло­баль­ные нас­трой­ки ОС. Любой юзер может вре­мен­но побывать в роли root с помощью коман­ды sudo (Substitute User and do, дос­ловно «под­менить поль­зовате­ля и выпол­нить»). Но сра­бота­ет этот sudo, толь­ко если ты зна­ешь пароль от учет­ной записи супер­поль­зовате­ля.

Каж­дому фай­лу в Linux наз­нача­ется набор раз­решений, опре­деля­ющих, кто и что может делать с этим фай­лом. Эти раз­решения обоз­нача­ются спе­циаль­ными бук­вами:

- r (read) — раз­решение на чте­ние фай­ла;
- w (write) — раз­решение на запись в файл;
- x (execute) — раз­решение на запуск фай­ла;
- - (про­черк) — раз­решение не уста­нов­лено.

Важ­но пом­нить, что катало­ги Linux тоже счи­тает фай­лами, поэто­му для них дей­стви­тель­ны все те же раз­решения и огра­ниче­ния. Одна­ко ука­зан­ные раз­решения не име­ли бы боль­шого смыс­ла, если бы они рас­простра­нялись на всех поль­зовате­лей опе­раци­онной сис­темы. К счастью, это не так: в Linux име­ется три катего­рии поль­зовате­лей, для каж­дой из которых мож­но уста­нав­ливать свои собс­твен­ные раз­решения дос­тупа к фай­лам:

- вла­делец — поль­зователь, который соз­дал этот файл или наз­начен его вла­дель­цем. Вла­дель­цем фай­ла может быть не толь­ко учет­ная запись, но и сама опе­раци­онная сис­тема или при­ложе­ние, которое соз­дало файл;
- груп­па — груп­па поль­зовате­лей, «при­вязан­ная» к дан­ному фай­лу. Ты можешь узнать, к какой груп­пе поль­зовате­лей отно­сит­ся твоя учет­ная запись, с помощью кон­соль­ной коман­ды groups username. Спи­сок всех зарегис­три­рован­ных в сис­теме групп обыч­но хра­нит­ся в пап­ке /etc/group;
- дру­гие — все, кто не отно­сит­ся к вла­дель­цу фай­лового объ­екта или груп­пам поль­зовате­лей.

**Та­ким обра­зом, раз­решения дос­тупа к любому фай­лу или пап­ке мож­но записать в виде стро­ки, сос­тоящей из девяти сим­волов и име­ющей сле­дующий вид:**

**rwxrwxrwx**

Пер­вые три сим­вола здесь опре­деля­ют раз­решения для вла­дель­ца фай­лового объ­екта, вто­рые — для груп­пы, к которой отно­сит­ся вла­делец фай­ла или пап­ки, пос­ледние три — для всех осталь­ных. Раз­решения всег­да сле­дуют имен­но в таком поряд­ке: «чте­ние, запись, запуск», то есть rwx. Нап­ример, обоз­начение вида rwxrw-r-- озна­чает, что вла­делец это­го фай­ла может делать с ним что угод­но, чле­ны его груп­пы — толь­ко читать и писать в файл, но не запус­кать его (раз­решение x не уста­нов­лено), а всем осталь­ным поль­зовате­лям сис­темы файл дос­тупен толь­ко на чте­ние.

Ес­ли эти раз­решения уста­нов­лены для пап­ки, это озна­чает, что поль­зовате­ли груп­пы так­же не смо­гут запус­кать хра­нящи­еся в ней фай­лы, а про­чим поль­зовате­лям открыт дос­туп к содер­жимому пап­ки исклю­читель­но в режиме read only.

Прос­мотреть пра­ва и раз­решения фай­лов и папок мож­но с помощью кон­соль­ной коман­ды ls, снаб­женной клю­чом -l.

Что­бы изме­нить пра­ва дос­тупа, сущес­тву­ет коман­да chmod (Change Mode). При помощи этой коман­ды мож­но даже не про­писы­вать все тре­буемые раз­решения вруч­ную: для лен­тяев в Linux пре­дус­мотре­ны циф­ровые обоз­начения стан­дар­тных наборов раз­решений. Нап­ример, коман­да chmod 755 filename прис­воит фай­лу filename раз­решения rwxr-xr-x (каж­дый поль­зователь име­ет пра­во читать и запус­кать на выпол­нение; вла­делец может редак­тировать), chmod 777 filename даст на выходе rwxrwxrwx (все могут делать все, что захотят), а «дьяволь­ская» коман­да chmod 666 filename — вер­нет rw-rw-rw- (все поль­зовате­ли могут читать и редак­тировать файл).

В сов­ремен­ном Linux сущес­тву­ют еще так называ­емые спе­циаль­ные раз­решения, но их мы рас­смат­ривать не будем: для начала информа­ции впол­не дос­таточ­но, что­бы чувс­тво­вать себя в сис­теме более‑менее уве­рен­но.

## 9 Ссылки

В Windows сущес­тву­ют ярлы­ки — что это такое, объ­яснять, дума­ем, никому не нуж­но. В Linux вмес­то них ссыл­ки, при­чем двух видов — жес­ткие и сим­воличес­кие.

Жес­ткая ссыл­ка — это, счи­тай, наз­вание фай­ла. Прос­то в Linux их у фай­ла может быть нес­коль­ко, при­чем находить­ся они могут в раз­ных катало­гах. Сле­дова­тель­но, если ты соз­дашь жес­ткую ссыл­ку, а потом уда­лишь исходный файл, то он по‑преж­нему будет дос­тупен по ссыл­ке — ведь она ничем не хуже исходно­го наз­вания, которое ты стер!

Ес­ли же ты уда­лишь пос­леднюю жес­ткую ссыл­ку, фай­ловая сис­тема боль­ше не будет счи­тать, что файл сущес­тву­ет, и приз­нает мес­то, где он рас­положен, при­год­ным для записи дру­гой информа­ции.

Сим­воличес­кие ссыл­ки боль­ше похожи на стан­дар­тные ярлы­ки Windows. Они содер­жат адрес целево­го фай­ла или катало­га (жес­тких ссы­лок на каталог не быва­ет), и если он исчезнет, то ссыл­ка будет вес­ти «в никуда».

Жес­ткие ссыл­ки соз­дают­ся коман­дой ln файл ссылка, а если нуж­но сде­лать сим­воличес­кую ссыл­ку, добавь ключ -s.

## 10 Установка софта

Те­бе, конеч­но, ник­то не меша­ет заг­рузить прог­рамму в виде одно­го бинар­ного фай­ла и запус­тить. Глав­ное — не забыть дать ему пра­ва на исполне­ние! Но такие отдель­но сто­ящие фай­лы — ред­кость. Обыч­но, что­бы прог­рамма работа­ла, в сис­тему нуж­но уста­новить сра­зу мно­го все­го. Имен­но поэто­му прог­раммы рас­простра­няют­ся в виде пакетов через репози­торий.

Нап­ример, в Ubuntu для уста­нов­ки пакета дос­таточ­но написать sudo apt install пакет. Одна­ко рекомен­дует­ся сна­чала сде­лать sudo apt update, что­бы ОС обно­вила свой спи­сок пакетов и узна­ла о выходе новых вер­сий.

Важ­ное отли­чие Linux зак­люча­ется в том, что прог­рамма пос­ле уста­нов­ки будет раз­бро­сана по раз­ным катало­гам. Исполня­емые фай­лы — в свой каталог, гра­фичес­кие ресур­сы — в свой, нас­трой­ки — в свой, и так далее. При этом прог­раммы обыч­но исполь­зуют общие биб­лиоте­ки, что нем­ного эко­номит мес­то на дис­ке, но иног­да соз­дает неудоб­ные ситу­ации с вер­сиями биб­лиотек.

При исполь­зовании такой сис­темы уста­нов­ки прак­тичес­ки бес­полез­но пытать­ся выяс­нить, куда же уста­нови­лась прог­рамма. Если тебе вдруг понадо­бит­ся уда­лить ее, пиши apt remove пакет, и его содер­жимое покинет твой диск, а вмес­те с ним уйдут и все ком­понен­ты, которые ник­то, кро­ме него, не исполь­зовал.

Но Linux — это стра­на сво­бод­ных исходных кодов, а потому сбор­ка прог­раммы из исходни­ков — обыч­ное дело. Счи­тай, что вмес­то крес­ла ты купил «конс­трук­тор» из IKEA. Важ­ное отли­чие от нее зак­люча­ется в том, что вмес­то инс­трук­ции со смеш­ными человеч­ками ты получа­ешь Makefile — сце­нарий для прог­раммы make, который соберет все сам на авто­пило­те. А по дороге он изу­чит и учтет все осо­бен­ности тво­ей сис­темы либо наруга­ется на тебя из‑за отсутс­твия каких‑то ком­понен­тов (в отли­чие от пакет­ного менед­жера, который уста­новил бы их сам).

Итак, пред­положим, ты нашел на гит­хабе ути­литу nnn (это такой минима­лис­тичный фай­ловый менед­жер, работа­ющий в тер­минале) и хочешь ее уста­новить из исходни­ков. Тебе понадо­бит­ся сде­лать сле­дующее.

**Удос­товерить­ся, что у тебя в сис­теме есть сам Git. Если его нет — уста­нови:**

- sudo apt install git Ус­тановить зависи­мос­ти для nnn. Все их собирать из исходни­ков — нем­ного слиш­ком, поэто­му прос­то пиши
- sudo apt install pkg-config libncursesw5-dev libreadline-dev Те­перь пора дос­тать nnn с GitHub. Это дела­ется такой коман­дой:
- git clone [https://github.com/jarun/nnn.git](https://github.com/jarun/nnn.git) За­ходи в ска­чан­ный каталог: cd nnn.

Пи­ши make и жми Enter. Эта коман­да най­дет Makefile и выпол­нит инс­трук­ции по ком­пиляции.

Пи­ши sudo make install — эта коман­да раз­ложит соз­данные бинар­ные фай­лы по катало­гам.

Го­тово! Можешь писать nnn, находясь в любом катало­ге, и фай­ловый менед­жер запус­тится.

Об­рати вни­мание, это была лишь демонс­тра­ция. В реаль­нос­ти про­ще и луч­ше будет уста­новить вер­сию nnn из репози­тория. В таком слу­чае пакет­ный менед­жер смо­жет обновлять уста­нов­ленную прог­рамму и уда­лить под­чистую, если понадо­бит­ся. Сбор­ка из исходных кодов может понадо­бить­ся, если софт ред­кий или нуж­на самая‑самая новая вер­сия.

Кста­ти, помимо бинар­ных пакетов, в репози­тори­ях быва­ют и пакеты с исходни­ками. Их сбор­ка прой­дет на авто­мате и поз­волит не морочить­ся с уста­нов­кой зависи­мос­тей.

В пос­леднее вре­мя набира­ют популяр­ность новые сис­темы уста­нов­ки, в которых прог­раммы рас­простра­няют­ся вмес­те со все­ми зависи­мос­тями и биб­лиоте­ками: AppImage, Flatpak и Snap. Это менее эко­ном­ный метод, но более удоб­ный и надеж­ный. Так­же некото­рые прог­раммы удоб­но уста­нав­ливать через Docker — то есть вмес­те с мини­атюр­ным обра­зом Linux. Но раз­говор обо всем этом выходит за рам­ки сегод­няшней статьи.

## 11 Init и systemd

В Unix и Linux боль­шую роль игра­ет про­цесс ини­циали­зации сис­темы, за который отве­чает ути­лита init. Древ­ние юник­сы до пятой вер­сии прос­то исполня­ли скрипт при вклю­чении — счи­тай, ана­лог autoexec.bat. Ког­да соф­та ста­ло слиш­ком мно­го, приш­лось добавить такое понятие, как runlevel.

Сис­тема при заг­рузке перехо­дит из одной ста­дии в дру­гую и при каж­дом перехо­де запус­кает скрип­ты из опре­делен­ной пап­ки /etc/rcX.d/, где X — один из уров­ней заг­рузки:

- 0 — сис­тема вык­лючена;
- 1 — одно­поль­зователь­ский режим;
- 2 — мно­гополь­зователь­ский;
- 3 — с под­дер­жкой сети;
- 5 — пол­ная заг­рузка;
- 6 — перезаг­рузка.

Так, если добавить ссыл­ку на скрипт в пап­ку rc0.d, то он будет исполнять­ся каж­дый раз перед вык­лючени­ем.

Имен­но так сис­тема дела­ет все, что ей положе­но делать, — нап­ример, запус­кает про­вер­ку дис­ка пос­ле вне­зап­ного вык­лючения, ротиру­ет логи, запус­кает и оста­нав­лива­ет работа­ющие в фоне служ­бы (в Unix и Linux они называ­ются демона­ми).

В сов­ремен­ном Linux на сме­ну этой сис­теме приш­ла еще более изощ­ренная — systemd. Она может заод­но рулить устрой­ства­ми и сетевы­ми соеди­нени­ями и делать дру­гие вещи. В systemd для каж­дого дей­ствия или служ­бы соз­дают­ся кон­фигура­цион­ные фай­лы, в которых ука­зано, ког­да и при каких усло­виях нуж­но что‑то запус­кать или оста­нав­ливать. Най­ти их спи­сок ты можешь в /lib/systemd/, а работа­ют с ними при помощи коман­ды service.

При этом сис­тема с уров­нями заг­рузки пока что тоже под­держи­вает­ся в популяр­ных дис­три­бути­вах, нес­мотря на при­сутс­твие systemd. Ина­че были бы проб­лемы с сов­мести­мостью.
