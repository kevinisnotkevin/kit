# Основы Bash-скриптов

bash - это командная оболочка (или «интерпретатор командной строки»), используемая по умолчанию в операционных системах на базе Unix и Linux, созданная в 1989 году Брайаном Фоксом с целью усовершенствования командной оболочки sh.

bash позволяет автоматизировать различные задачи, устанавливать ПО, настраивать конфигурации для своего рабочего окружения и многое другое.

### 1 База

```bash
#!/bin/bash
```
- Первая строка файла говорит о том, что это скипт на языке bash. Есть этому файлу дать права на исполнение и запустить, то он будет выполняться от bash. Если изменить расширение этого файла, то это ничего не изменит, так как linux определяет типы файлов именно по его содержимому
```bash
#!/bin/bash

whoami # Comment
```
- в bash есть поддержка комментариев
```bash
./script.sh
# или (если нет прав)
bash script.sh
```
Для запуска скрипта нужны права на исполнение (chmod +x), если прав нет, то можно запустить скрипт напрямую, используя bash
```bash
#!/bin/bash

echo "Current dir"; pwd
echo "Current user"; whoami
```
- Скрипт, который выводит текущего пользователя и текущую директорию. Оператор `;` уменьшает кол-во строк кода
```bash
#!/bin/bash

echo "Var from env: $HOME"

grade=5
person="Adam"
echo "$person has grade $grade"

```

При этом bash позволяет использовать несколько типов переменных. Для того, чтобы обратиться к переменной мы используем доллар $ и соответственно саму переменную - это значит что мы можем обратиться к самой переменной, что в свою очередь подставит условия в переменной. Когда мы просто обращаемся к переменной мы подставляем значение переменной $HOME вместо её обозначения - это значение мы берём из переменного окружения. Когда мы задаём переменную, необходимо соблюдать строго следующий синтаксис.тут пробелы важны (пробелы это делители). Если сделать так: `grade = 5`, то bash воспримет это как выполни команду grade потом “=” и затем “5”

Правила с кавычками:
‘’ - внутри одинархных ковычек ничего не имеет специального значения. Имена переменных теряют значение
“” - в двойных ковычках имена переменных имеют особое значение

```bash
#!/bin/bash

mydir=`pwd`
echo $mydir1

mydir2=$(pwd)
echo $mydir2
```
- Переменные могут создаваться ещё и выводом команд т.е. результат вывода какой-то команды. Мы берем команду pwd и её результат подставляем к переменной $mydir1 при этом он будет одинаковы в обоих случаях
```bash
#!/bin/bash

var1=$(( 5 + 5 ))
echo $var1

var2=$(( $var1 * 2 ))
echo $var2
```
- Мы не только можем подставлять, како-то ввод, но также ещё производить математические операции. Тут происходит специализированный синтаксис, в котором указывается (()) в свою очередь они указывают на то, что в них производится некое математическое выражение с различными числами, тут мы видим что 5+5 пойдёт в переменную var1 и соответственно вывод переменной var1 умножится на 2 и результат пойдёт в переменную var2
```bash
echo $((2+2*2))
echo $(((2+2)*2))
person=Adam
echo "$person"
echo "$person:aaa"
echo "${person}aaa"
```
- Ввод в терминале. Мы можем назначить переменную и обращаться к переменной и если нам необходимо изменить вывод переменной. Можем напечатать Adam а затем aaa не используя разделитель

### 2 Управляющая конструкция if-then

```bash
#!/bin/bash
if pwd
then
echo "It works"
fi
```
- В некоторых сценариях требуется управлять потоком исполнения команд. Например, если некое значение больше пяти, нужно выполнить одно действие (логическое 0 когда всё ок и логическое 1 когда ошибка), в противном случае — другое. Подобное применимо в очень многих ситуациях, и здесь нам поможет управляющая конструкция if-then. В наиболее простом виде она выглядит так:
```
#!/bin/bash
user=likegeeks
if grep $user /etc/passwd
then
echo "The user $user exists"
fi

```
- Скрипт выполняет поиск пользователя в файле /etc/passwd. Если пользователь найден, скрипт выведет соответствующее сообщение

### 3 Управляющая конструкция if-then-else

```bash
if команда
then
команды
else
команды
fi

```
- Для того, чтобы программа смогла сообщить и о результатах успешного поиска, и о неудаче, воспользуемся конструкцией if-then-else. Если первая команда возвратит ноль, что означает её успешное выполнение, условие окажется истинным и выполнение не пойдёт по ветке else. В противном случае, если будет возвращено что-то, отличающееся от нуля, что будет означать неудачу, или ложный результат, будут выполнены команды, расположенные после else
```bash
if команда1
then
команды
elif команда2
then
команды
fi

```
- Если первая команда вернёт ноль, что говорит о её успешном выполнении, выполнятся команды в первом блоке then, иначе, если первое условие окажется ложным, и если вторая команда вернёт ноль, выполнится второй блок кода then

### 4 Сравнение чисел

Операторы сравнения числовых значений:
- **`n1 -eq n2`**: Возвращает истинное значение, если n1 равно n2
- **`n1 -ge n2`**: Возвращает истинное значение, если n1больше или равно n2
- **`n1 -gt n2`**: Возвращает истинное значение, если n1 больше n2
- **`n1 -le n2`**: Возвращает истинное значение, если n1меньше или равно n2
- **`n1 -lt n2`**: Возвращает истинное значение, если n1 меньше n2
- **`n1 -ne n2`**: Возвращает истинное значение, если n1не равно n2

```bash
#!/bin/bash

val1=6
if [ $val1 -gt 5 ]
then
echo "The test value $val1 is greater than 5"
else
echo "The test value $val1 is not greater than 5"
fi
```
- Пример использования оператора сравнения

### 5 Сравнение строк

Операторы сравнения строк:
- str1 = str2 Проверяет строки на равенство, возвращает истину, если строки идентичны.
- str1 != str2Возвращает истину, если строки не идентичны.
- str1 < str2Возвращает истину, если str1меньше, чем str2.
- str1 > str2 Возвращает истину, если str1больше, чем str2.
- n str1 Возвращает истину, если длина str1больше нуля.
- z str1Возвращает истину, если длина str1равна нулю.

```bash
#!/bin/bash

user="likegeeks"
if [ $user = $USER ]
then
echo "The user $user  is the current logged in user"
fi
```
- Скрипт, который сравнивает строковые значения

Вот одна особенность сравнения строк, о которой стоит упомянуть. А именно, операторы «>» и «<» необходимо экранировать с помощью обратной косой черты, иначе скрипт будет работать неправильно, хотя сообщений об ошибках и не появится. Скрипт интерпретирует знак «>» как команду перенаправления вывода.

```bash
#!/bin/bash

val1=text
val2="another text"
if [ $val1 \\> "$val2" ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```
- Скрипт, который сравнивает строки

### 6 Циклы for

```bash
for var in list
do
команды
done

```
- Оболочка bash поддерживает циклы for, которые позволяют организовывать перебор последовательностей значений. В каждой итерации цикла в переменную var будет записываться следующее значение из списка list

```bash
#!/bin/bash

for var in first second third fourth fifth
do
echo The  $var item
done
```
- Скрипт использует цикл для перебора списка простых значений
```bash
#!/bin/bash

for var in first "the second" "the third" "I’ll do it"
do
echo "This is: $var"
done
```
- В списке, использованном при инициализации цикла for, могут содержаться не только простые строки, состоящие из одного слова, но и целые фразы, в которые входят несколько слов и знаков препинания
### 7 Обход файлов, содержащихся в директории

Один из самых распространённых вариантов использования циклов for в bash-скриптах заключается в обходе файлов, находящихся в некоей директории, и в обработке этих файлов.

```bash
#!/bin/bash

for file in ~/*
do
if [ -d "$file" ]
then
echo "$file is a directory"
elif [ -f "$file" ]
then
echo "$file is a file"
fi
done
```
- Вывод списка файлов и папок

```bash
#!/bin/bash

for file in /etc/*/*
do
if [ -d "$file" ]
then
echo "$file is a directory"
elif [ -f "$file" ]
then
echo "$file is a file"
fi
done
```
- Вывод содержимого папки будет включать ещё две директории. `*` можно воспринимать как шаблон, означающий: «все файлы с любыми именами». Он позволяет организовать автоматическую подстановку имён файлов, которые соответствуют шаблону. При проверке условия в операторе if, мы заключаем имя переменной в кавычки. Сделано это потому что имя файла или папки может содержать пробелы

```bash
#!/bin/bash

file="/etc/passwd"
for var in $(cat $file)
do
echo "$var"
done
```
- Ещё один способ инициализации цикла for заключается в передаче ему списка, который является результатом работы некоей команды. Тут используется подстановка команд для их исполнения и получения результатов их работы

### 8 Циклы for в стиле C

```bash
#!/bin/bash

for (( i=1; i <= 10; i++ ))
do
echo "number is $i"
done
```
- Использование цикла for, описание которого похоже на циклы в С

### 9 Цикл while

Конструкция for — не единственный способ организации циклов в bash-скриптах. Здесь можно пользоваться и циклами while. В таком цикле можно задать команду проверки некоего условия и выполнять тело цикла до тех пор, пока проверяемое условие возвращает ноль, или сигнал успешного завершения некоей операции. Когда условие цикла вернёт ненулевое значение, что означает ошибку, цикл остановится.

```bash
#!/bin/bash

var1=5
while [ $var1 -gt 0 ]
do
echo $var1
var1=$[ $var1 - 1 ]
done
```
- Скрипт использует цикл while. На входе в цикл проверяется, больше ли нуля переменная $var1. Если это так, выполняется тело цикла, в котором из значения переменной вычитается единица. Так происходит в каждой итерации, при этом мы выводим в консоль значение переменной до его модификации. Как только $var1 примет значение 0, цикл прекращается

### 10 Вложенные циклы

```bash
#!/bin/bash

for (( a = 1; a <= 3; a++ ))
do
echo "Start $a:"
for (( b = 1; b <= 3; b++ ))
do
echo " Inner loop: $b"
done
done
```
- Скрипт содержит вложенный цикл. Сначала выполняется первая итерация внешнего цикла, потом три итерации внутреннего, после его завершения снова в дело вступает внешний цикл, потом опять внутренний

```bash
#!/bin/bash

IFS=$'\\n'
for entry in $(cat /etc/passwd)
do
echo "Values in $entry –"
IFS=:
for value in $entry
do
echo " $value"
done
done
```
- Чаще всего вложенные циклы используют для обработки файлов. Так, внешний цикл занимается перебором строк файла, а внутренний уже работает с каждой строкой. Пример с обработкой файла /etc/passwd. Такой подход можно использовать при обработке файлов формата CSV, или любых подобных файлов, записывая, по мере надобности, в переменную окружения IFS символ-разделитель

### 11 Управление циклами

Возможно, после входа в цикл, нужно будет остановить цикл при достижении переменной цикла определённого значения, которое не соответствует изначально заданному условию окончания цикла можно воспользоваться командами break или continue.

**Команда break**

```bash
#!/bin/bash

for var1 in 1 2 3 4 5 6 7 8 9 10
do
if [ $var1 -eq 5 ]
then
break
fi
echo "Number: $var1"
done
```
- Скрипт использует команду break внутри цикла for, чтобы прервать выполнение цикла, когда переменная $var1 будет равна 5

```bash
#!/bin/bash

var1=1
while [ $var1 -lt 10 ]
do
if [ $var1 -eq 5 ]
then
break
fi
echo "Iteration: $var1"
var1=$(( $var1 + 1 ))
done
```
- Аналогичный скрипт, но в цикле while


**Команда continue**

Когда в теле цикла встречается эта команда, текущая итерация завершается досрочно и начинается следующая, при этом выхода из цикла не происходит. Посмотрим на команду continue в цикле for:

```bash
#!/bin/bash

for (( var1 = 1; var1 < 15; var1++ ))
do
if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]
then
continue
fi
echo "Iteration number: $var1"
done
```
- Скрипт использует команду continue внутри цикла for, чтобы пропустить оставшиеся в теле цикла команды и перейти к следующей итерации
```bash
#!/bin/bash

for (( a = 1; a < 10; a++ ))
do
echo "Number is $a"
done > myfile.txt
echo "finished."
```
- Скрипт использует перенаправление вывода в файл. Скрипт создаст файл myfile.txt и перенаправит в этот файл вывод конструкции for

```bash
#!/bin/bash

IFS=:
for folder in $PATH
do
echo "$folder:"
for file in $folder/*
do
if [ -x $file ]
then
echo " $file"
fi
done
done
```
- Скрипт создает список исполяемых файлов, хранящихся в директориях из PATH
