
## Introduction

- Все есть файл
- Содержит множество небольших программ
- Возможность объединения программ для выполнения сложных задач
- Не привязан к GUI
- Данные конфигураций хранятся в текстовых файлах

## Components

- __Bootloader__: Загрузчик управляет процессом загрузки ОС (Например, GRUB);
- __OS Kernel__: Код ядра управляет ресурсами системных устройств ввода-вывода на аппаратном уровне;
- __Daemons__: Фоновые службы обеспечивают правильную работу функций (Например, печать, планирование, мультимедиа);
- __OS Shell__: Интерфейс между пользователем и ОС (Например, Bash, Tcsh/Csh, Ksh, Zsh, Fish);
- __Graphics server__: Обеспечивает графическую подсистему X-server, которая позволяет графическим программам запускаться локально или удаленно в системе X-windowing;
- __Window manager__: GUI позволяет пользователю получать доступ к основным функциям и службам ОС (Например, GNOME, KDE, Mate, Unity, Cinnamon);
- __Utilities__: Программы выполняют определенные функции для пользователей или других программ.

## Architecture

- __Hardware__: Аппаратное обеспечение, периферийные устройства (Например, CPU, RAM, жесткий диск);
- __Kernel__: Ядро предоставляет каждому процессу собственные виртуальные ресурсы и предотвращает конфликты между различными процессами;
- __Shell__: Интерфейс командной строки (Command-line interface, CLI) позволяет пользователю вводить команды для выполнения функций ядра;
- __System utility__: Предоставляет пользователю все функциональные возможности ОС.

## Terminal Hotkeys

- __CTRL+C__: Прерывает выполнение текущей команды;
- __CTRL+D__: Завершает текущий процесс;
- __CTRL+Z__: Приостанавливает выполнение процесса (Продолжить - `fg`);
- __CTRL+A__: Перемещает курсор в начало строки;
- __CTRL+E__: Перемещает курсор в конец строки;
- __CTRL+U__: Удаляет текст от курсора до начала строки;
- __CTRL+K__: Удаляет текст от курсора до конца строки;
- __CTRL+L__: Очищает экран;
- __CTRL+R__: Ищет вводимую строку в истории команд;
- __CTRL+W__: Удаляет слово перед курсором;
- __CTRL+Y__: Вставляет удаленный текст;
- __CTRL+P__: Перемещает курсор на одну строку вверх в истории команд;
- __CTRL+N__: Перемещает курсор на одну строку вниз в истории команд;
- __CTRL+T__: Меняет местами символы до и после курсора;
- __CTRL+F__: Перемещает курсор на одно слово вперед;
- __CTRL+B__: Перемещает курсор на одно слово назад;
- __CTRL+D__: Удаляет слово после курсора;
- __Alt+.__: Вставляет поледний аргумент предыдущей команды;
- __Tab__: Автодополнение имен файлов и команд;
- __CTRL+Alt+Del__: Перезагрузка системы.

## File descriptor and redirections

**stdin, stdout, stderr**

Оболочка bash имеет три основных потока; она принимает входные данные из stdin (поток 0), отправляет выходные данные в stdout (поток 1) и отправляет сообщения об ошибках в stderr (поток 2). Клавиатура часто служит в качестве stdin, тогда как stdout и stderr выводятся на дисплей. Отделение выходных данных от ошибок может быть очень полезным.

**Cтандартный вывод stdout** может быть перенаправлен со знаком больше, чем. При сканировании строки оболочка увидит знак > и очистит файл. Обозначение > на самом деле является аббревиатурой 1> (стандартный вывод упоминается как поток 1). 1> - это то же самое, что >.

**Используйте >> для добавления выходных данных в файл.**

**Перенаправление ошибок stderr**. Перенаправление stderr выполняется с помощью 2>. Это может быть очень полезно для предотвращения загромождения экрана сообщениями об ошибках.

По умолчанию вы не можете выполнять grep внутри stderr при использовании каналов в командной строке, поскольку передается только стандартный вывод. С помощью 2>&1 вы можете принудительно перевести stderr в стандартный вывод. Это позволяет команде в канале воздействовать на оба потока.

Файловый дескриптор — натуральное число (идентификатор), закреплённое за определённым потоком ввода-вывода. В Linux библиотека libc открывает для каждого запущенного приложения (процесса) 3 файл дескриптора, с номерами 0, 1, 2:
- Файл дескриптор 0 называется STDIN и ассоциируется с вводом данных у приложения;
- Файл дескриптор 1 называется STDOUT и используется приложениями для вывода данных, например командами print;
- Файл дескриптор 2 называется STDERR и используется приложениями для вывода данных, сообщающих об ошибке.

```bash
# Перенаправление стандартного ввода
cat < stdout.txt

# Перенаправление результата работы функции find в функцию grep, а затем перенаправление в функцию wc
find /etc/ -name *.conf 2>/dev/null | grep systemd | wc -l

# Перенаправление файлового дескриптора ошибок на нулевое устройство, которое отбрасывает все данные и перенаправление файлового дескриптора вывода в файл results.txt. `>` создает или перезаписывает файл, `>>` добавляет в файл
find /etc/ -name shadow 2>/dev/null > results.txt
# Явное перенаправление стандартного вывода:
find /etc/ -name shadow 2> stderr.txt 1> stdout.txt

# Перенаправление stdout и stderr в один и тот же файл
find / > allfiles_and_errors.txt 2>&1

# Нельзя использовать как 1>&2, так и 2>&1 для переключения stdout и stderr. Нужен третий поток для переключения stdout и stderr после символа канала
rm file1 3>&1 1>&2 2>&3 | sed 's/file1/FILE1/'

# Конструкция &> поместит как stdout, так и stderr в один поток (в файл)
rm file1 &> out_and_err
```


## Permission Management

![](materials/images/permissions.png)

- Разрешения назначаются пользователям и группам. Каждый пользователь может быть членом различных групп, и членство в этих группах дает пользователю особые дополнительные разрешения. 
- Каждый файл и каталог принадлежит определенному пользователю и определенной группе. 
- При создании новых файлов или каталогов, они принадлежат группе, к которой принадлежит пользователь, и пользователю.
- Для перемещения по каталогу необходимы разрешения на выполнение, независимо от уровня доступа пользователя. Разрешения на выполнение каталога не позволяют пользователю выполнять или изменять какие-либо файлы или содержимое в каталоге, а только просматривать и получать доступ к содержимому каталога.
- Чтобы изменить содержимое каталога (создать, удалить или переименовать файлы и подкаталоги), пользователю необходимы права на запись в каталоге.
- Вся система разрешений основана на восьмеричной системе счисления, и файлу или каталогу можно назначить три различных типа разрешений (`r` - Read, `w` - Write, `x` - Execute).
- Команда [chmod](#chmod) позволяет изменить разрешения (u — владелец, g — группа, o — другие, a — все пользователи), `+` или `-` для добавления и удаления назначенных разрешений.

### SUID & SGID

Set User Identifier (SUID) - На время выполнения файла (запущенного им процесса) непривилегированному пользователю получить права владельца файла

Set Group Identifier (SGID) Аналогичен SUID, но устанавливаются права группы — владельца файла. Также все файлы, создаваемые в каталогк с установленным SGID, будут получать идентификатор группы — владельца каталога, а не файла

Помимо назначения прямых разрешений для пользователей и групп, также можно настроить специальные разрешения для файлов, установив биты Set User ID (SUID) и Set Group ID (SGID). Эти биты SUID/SGID позволяют, например, пользователям запускать программы с правами другого пользователя. Администраторы часто используют это, чтобы предоставить своим пользователям особые права для определенных приложений или файлов. Вместо буквы «x» используется буква «s». При выполнении такой программы используется SUID/SGID владельца файла.

Если администратор установит бит SUID для «journalctl», любой пользователь сможет запустить оболочку от имени пользователя root.

### Sticky Bit

Sticky Bit — это тип прав доступа к файлам, которые можно установить для каталогов. Этот тип разрешений обеспечивает дополнительный уровень безопасности при контроле удаления и переименования файлов в каталоге. Обычно он используется в каталогах, которые используются несколькими пользователями, чтобы предотвратить случайное удаление или переименование одним пользователем файлов, которые важны для других. 

При использовании пользователь сможет удалить файл, только если будет являться владельцем этого файла или владельцем катаога, в котором содержится файл

Например, в общем домашнем каталоге, где несколько пользователей имеют доступ к одному и тому же каталогу, системный администратор может установить Sticky Bit для каталога, чтобы гарантировать, что только владелец файла, владелец каталога или пользователь root может удалять или переименовывать файлы в каталоге. Это означает, что другие пользователи не могут удалять или переименовывать файлы в каталоге, поскольку у них нет необходимых разрешений. Это обеспечивает дополнительный уровень безопасности для защиты важных файлов, поскольку только те, у кого есть необходимый доступ, могут удалять или переименовывать файлы. Установка Sticky Bit для каталога гарантирует, что только владелец, владелец каталога или пользователь root смогут изменять файлы в каталоге.

Когда для каталога установлен Sticky Bit, он обозначается буквой «t» в разрешении на выполнение разрешений каталога. Например, если каталог имеет разрешения «rwxrwxrwt», это означает, что установлен Sticky Bit, что дает дополнительный уровень безопасности, чтобы никто, кроме владельца или пользователя root, не мог удалять или переименовывать файлы или папки в каталоге.

Если Sticky Bit написан с заглавной буквы (T), то это означает, что все остальные пользователи не имеют разрешений на выполнение (x) и, следовательно, не могут видеть содержимое папки и запускать из нее какие-либо программы. Sticky Bit в нижнем регистре (t) — это Sticky Bit, в котором установлены разрешения на выполнение (x).

## Service and Process Management

Существует два типа служб: __внутренние__, которые требуются при запуске системы и которые, например, выполняют задачи, связанные с оборудованием, и __пользовательские__, которые обычно включают в себя все серверные службы. Такие службы работают в фоновом режиме без какого-либо взаимодействия с пользователем. Их также называют демонами и обозначают буквой «d» в конце имени программы, например, sshd или systemd.

Большинство дистрибутивов Linux перешли на systemd. Этот демон представляет собой инициализирующий процесс, запускаемый первым, и поэтому имеет PID 1. Этот демон контролирует и обеспечивает упорядоченный запуск и остановку других служб. Всем процессам присвоен PID, который можно просмотреть в /proc/ с соответствующим номером. Такой процесс может иметь идентификатор родительского процесса (PPID), и если имеет, то он называется дочерним процессом.

Процесс может находиться в следующих состояниях:
- Running;
- Waiting (ожидание события или системного ресурса);
- Stopped;
- Zombie (остановлен, но запись в таблице процессов все еще есть).

Чтобы взаимодействовать с процессом, мы должны послать ему сигнал. Мы можем просмотреть все сигналы с помощью `kill -l`. Из них часто используемые:
- __1 SIGHUP__: Отправляется процессу, когда терминал, который им управляет, закрывается;
- __2 SIGINT__: Отправляется, когда пользователь нажимает `Ctrl+C` в управляющем терминале, чтобы прервать процесс;
- __3 SIGQUIT__: Отправляется, когда пользователь нажимает `Ctrl+D` для выхода;
- __9 SIGKILL__: Немедленное завершение процесса без операций очистки;
- __15 SIGTERM__: Завершение программы;
- __19 SIGSTOP__: Остановить программу. С этим уже невозможно справиться;
- __20 SIGTSTP__: Отправляется, когда пользователь нажимает `Ctrl+Z`, чтобы запросить приостановку службы. Пользователь может справиться с этим позже.

### Background processes

Иногда необходимо перевести процесс в фоновый режим, чтобы продолжить использование текущего сеанса для взаимодействия с системой или запуска других процессов. Перевести процесс в фоновый режим можно с помощью `CTRL+Z`, указания `&` в конце командной строки. `bg` отображает все фоновые процессы. `fg <id>` позволяет вывести фоновый процесс в основной поток. Фоновые процессы позволяют использовать тот же сеанс оболочки, не дожидаясь, пока процесс сначала завершится. Как только сканирование или процесс завершат свою работу, терминал уведомит нас о завершении процесса.

### Executing multiple commands

Способы запуска нескольких команд разделителями:
- __;__: Игнорирует код возврата предыдущей команды;
- __&&__: Если код возврата предыдущей команды не 0, то выполнение команд прерывается;
- __|__: Зависит не только от корректной и безошибочной работы предыдущих процессов, но и от результатов предыдущих процессов.

## PTY

- Псевдотерминалы (PTY) - это абстрактные устройства в операционной системе Linux, предназначенные для обеспечения взаимодействия между процессами и терминалами. PTY используются для обеспечения доступа к текстовому вводу/выводу, такому как командная оболочка, через различные уровни абстракции
- Виртуальные терминалы используют псевдотерминалы (PTY), чтобы обеспечить взаимодействие пользователя с текстовой оболочкой
- В Linux каждый псевдотерминал имеет пару: мастер и слейв. Мастер является "внешним" интерфейсом, через который пользователь взаимодействует с псевдотерминалом, а слейв - "внутренним" интерфейсом, используемым программами
- VT создаются при загрузке системы и могут быть управляемыми с помощью утилит, таких как chvt и openvt. Пользователь может переключаться между VT с помощью клавиш Ctrl+Alt+F1, Ctrl+Alt+F2 и так далее
- Пользователь может войти в VT, введя логин и пароль. Для выхода из VT можно использовать команду exit. VT можно завершить, нажав Ctrl+Alt+Del (важно отметить, что это не то же самое, что перезагрузка системы). Управление VT можно выполнять с помощью утилиты chvt для переключения между VT
- PTY может быть создан с помощью системных вызовов, таких как openpty(), forkpty(), posix_openpt(), и других
- Процесс, создающий PTY, становится мастером, а второй процесс (обычно оболочка) становится слейвом

Один из наиболее распространенных способов использования PTY - это выполнение удаленных команд через SSH. При подключении к удаленному хосту, SSH использует PTY для обеспечения интерактивного текстового ввода/вывода между клиентом и сервером

## Bonding

**Бондинг (объединение сетевых интерфейсов, агрегирование каналов)** - это технология, позволяющая объединять несколько сетевых интерфейсов в одну виртуальную сетевую карту для увеличения пропускной способности и/или обеспечения отказоустойчивости.

Поведение связанных интерфейсов зависит от режима; режимы предоставляют либо услуги горячего резерва, либо услуги балансировки нагрузки. Кроме того, может выполняться мониторинг целостности канала.

Крайне важно указать параметры miimon или arp_interval и arp_ip_target , в противном случае во время сбоев канала произойдет серьезная деградация сети. Очень немногие устройства не поддерживают хотя бы miimon, поэтому нет причин не использовать его.

```bash
/etc/netplan/_____.yaml
cat /proc/net/bonding/bond0
```
- Конфигурационные файлы, отвечающие за конфигурирование Bond
```bash
ip a
ethtool
bmon
```
- Утилиты для проверки работоспособности Bond
```jsx
network:
	bonds:
		bond0:
			dhcp4: true
			interfaces: [ens38, ens33]
			parameters:
				mode: balance-rr
				transmit-hash-policy: layer3+4
				mii-monitor-interval: 1
	ethernets:
		ens38:
				dhcp4: false
				dhvp6: false
		ens33:
				dhcp4: false
				dhcp6: false
	version: 2
```
- Пример конфигурирования файлов для корректной работы Bond

## UMASK

**UMASK (user file-creation mode mask (маска режима создания файлов пользователя))** - маска доступа определяет, какие разрешения не будут установлены при создании новых файлов и каталогов.

**022** - это значение маски доступа, выраженное в восьмеричной системе счисления. В Linux права доступа к файлам и каталогам обычно представлены в восьмеричной нотации. Здесь каждая цифра представляет собой бит прав доступа.
- Права доступа для владельца файла: 0666 (восьмеричное) - 022 (маска) = 0644 (восьмеричное)
- Права доступа для владельца каталога: 0777 (восьмеричное) - 022 (маска) = 0755 (восьмеричное)

**UMASK 022**: При создании нового файла или каталога, права доступа к нему будут установлены так, чтобы владелец имел полные права (**`rw-`**), а группа и другие пользователи имели только права на чтение (**`r--`**) для файлов и на чтение и выполнение (**`r-x`**) для каталогов.

 **UMASK 077**: При создании новой учетной записи сам пользователь будет иметь полный доступ к своему домашнему каталогу и его содержимому, а все остальные пользователи не будут иметь никаких прав доступа к этим файлам и каталогам. Подробно:
1. **Создание новой учетной записи**:
    - При создании нового пользователя в системе учетная запись будет создана с указанным именем пользователя и UID (идентификатором пользователя).
    - Команда **`useradd`** или **`adduser`** используется для этой цели.
    - **Например: `sudo adduser igor`**
2. **Назначение домашнего каталога**:
    - По умолчанию новому пользователю будет назначен домашний каталог, обычно расположенный в **`/home/igor`**.
3. **Установка прав доступа к домашнему каталогу**:
    - Поскольку значение маски доступа (umask) установлено на **`077`**, права доступа к домашнему каталогу будут установлены таким образом, что только сам пользователь будет иметь доступ к своему домашнему каталогу, а остальные пользователи системы не будут иметь никаких прав доступа к этому каталогу.
    - Права доступа к домашнему каталогу будут: **`rwx------`** (чтение, запись и выполнение только для владельца).
4. **Назначение владельца и группы**:
    - Владельцем домашнего каталога будет новый пользователь, а группой будет также установлена группа с тем же именем, что и пользователь.
    - Например, если имя пользователя - **`igor`**, то владельцем и группой будет также **`igor`**.
5. **Ограничения доступа к файлам и каталогам**:
    - При создании файлов или каталогов в домашнем каталоге нового пользователя, права доступа будут ограничены по маске доступа (umask), установленной на **`077`**.
    - Для файлов права доступа будут: **`rw-------`** (чтение и запись только для владельца).
    - Для каталогов права доступа будут: **`drwx------`** (чтение, запись и выполнение только для владельца).

## CLI

- **CLI (Command Line Interface)** - текстовый интерфейс для работы с ОС
- **Терминал:** это окно или приложение, в котором пользователь взаимодействует с CLI. В Linux есть множество терминалов, включая виртуальные терминалы (VT) и терминалы в графической среде
- **Виртуальные терминалы (или VT)** - это механизм в операционной системе Linux, который предоставляет текстовые консоли, позволяющие пользователям взаимодействовать с системой в текстовом режиме. **Локальные VT** доступны напрямую с физической консоли, обычно через клавиши Ctrl+Alt+F1, Ctrl+Alt+F2 и так далее. **Удаленные VT** могут быть доступны посредством SSH или других удаленных протоколов
- **Оболочка (Shell):** оболочка - это программа, которая обрабатывает команды, введенные пользователем, и выполняет их. Примеры оболочек включают Bash, Zsh, Fish и другие
- **Команда:** это текст, введенный пользователем, который указывает системе, какое действие выполнить
- **Аргументы:** это дополнительные параметры, передаваемые команде, чтобы уточнить ее действие
- **Путь (Path):** это указание на файл или каталог в файловой системе
- **Псевдоним (Alias):** это короткое имя, которое может быть связано с длинной командой для удобства
