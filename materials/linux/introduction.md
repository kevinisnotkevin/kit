
## Introduction

- Все есть файл
- Содержит множество небольших программ
- Возможность объединения программ для выполнения сложных задач
- Не привязан к GUI
- Данные конфигураций хранятся в текстовых файлах

## Components

- __Bootloader__: Загрузчик управляет процессом загрузки ОС (Например, GRUB);
- __OS Kernel__: Код ядра управляет ресурсами системных устройств ввода-вывода на аппаратном уровне;
- __Daemons__: Фоновые службы обеспечивают правильную работу функций (Например, печать, планирование, мультимедиа);
- __OS Shell__: Интерфейс между пользователем и ОС (Например, Bash, Tcsh/Csh, Ksh, Zsh, Fish);
- __Graphics server__: Обеспечивает графическую подсистему X-server, которая позволяет графическим программам запускаться локально или удаленно в системе X-windowing;
- __Window manager__: GUI позволяет пользователю получать доступ к основным функциям и службам ОС (Например, GNOME, KDE, Mate, Unity, Cinnamon);
- __Utilities__: Программы выполняют определенные функции для пользователей или других программ.

## Architecture

- __Hardware__: Аппаратное обеспечение, периферийные устройства (Например, CPU, RAM, жесткий диск);
- __Kernel__: Ядро предоставляет каждому процессу собственные виртуальные ресурсы и предотвращает конфликты между различными процессами;
- __Shell__: Интерфейс командной строки (Command-line interface, CLI) позволяет пользователю вводить команды для выполнения функций ядра;
- __System utility__: Предоставляет пользователю все функциональные возможности ОС.

## Hotkeys

- __CTRL+C__: Прервать выполнение текущей команды;
- __CTRL+D__: Завершить текущий процесс;
- __CTRL+Z__: Переместить процесс на фон (Продолжить - `fg`);
- __CTRL+A__: Переместить курсор в начало строки;
- __CTRL+E__: Переместить курсор в конец строки;
- __CTRL+U__: Удалить текст от курсора до начала строки;
- __CTRL+K__: Удалить текст от курсора до конца строки;
- __CTRL+L__: Очистить экран;
- __CTRL+R__: Поиск в истории команд;
- __CTRL+W__: Удалить слово перед курсором;
- __CTRL+Y__: Вставить удаленный текст;
- __CTRL+P__: Переместить курсор на одну строку вверх в истории команд;
- __CTRL+N__: Переместить курсор на одну строку вниз в истории команд;
- __CTRL+T__: Поменять местами символы до и после курсора;
- __CTRL+F__: Переместить курсор на одно слово вперед;
- __CTRL+B__: Переместить курсор на одно слово назад;
- __CTRL+D__: Удалить слово после курсора;
- __Alt+.__: Вставитьsdfsdf поледний аргумент предыдущей команды;
- __Tab__: Автодополнение имен файлов и команд;
- __CTRL+Alt+Del__: Перезагрузить систему.

## File descriptor and redirections

**stdin, stdout, stderr**

Оболочка bash имеет три основных потока; она принимает входные данные из stdin (поток 0), отправляет выходные данные в stdout (поток 1) и отправляет сообщения об ошибках в stderr (поток 2). Клавиатура часто служит в качестве stdin, тогда как stdout и stderr выводятся на дисплей. Отделение выходных данных от ошибок может быть очень полезным.

**Cтандартный вывод stdout** может быть перенаправлен со знаком больше, чем. При сканировании строки оболочка увидит знак > и очистит файл. Обозначение > на самом деле является аббревиатурой 1> (стандартный вывод упоминается как поток 1). 1> - это то же самое, что >.

**Используйте >> для добавления выходных данных в файл.**
sys 1c
**Перенаправление ошибок stderr**. Перенаправление stderr выполняется с помощью 2>. Это может быть очень полезно для предотвращения загромождения экрана сообщениями об ошибках.

По умолчанию вы не можете выполнять grep внутри stderr при использовании каналов в командной строке, поскольку передается только стандартный вывод. С помощью 2>&1 вы можете принудительно перевести stderr в стандартный вывод. Это позволяет команде в канале воздействовать на оба потока.

**Файловый дескриптор** - это натуральное число (идентификатор), закреплённое за определённым потоком ввода-вывода. В Linux библиотека libc открывает для каждого запущенного процесса 3 файл дескриптора, с номерами 0, 1, 2:

- Файл дескриптор 0 называется STDIN и ассоциируется с вводом данных у приложения;
- Файл дескриптор 1 называется STDOUT и используется приложениями для вывода данных, например командами print;
- Файл дескриптор 2 называется STDERR и используется приложениями для вывода данных, сообщающих об ошибке.

```bash
# Перенаправление стандартного ввода
cat < stdout.txt

# Перенаправление результата работы функции find в функцию grep, а затем перенаправление в функцию wc
find /etc/ -name *.conf 2>/dev/null | grep systemd | wc -l

# Перенаправление файлового дескриптора ошибок на нулевое устройство, которое отбрасывает все данные и перенаправление файлового дескриптора вывода в файл results.txt. `>` создает или перезаписывает файл, `>>` добавляет в файл
find /etc/ -name shadow 2>/dev/null > results.txt
# Явное перенаправление стандартного вывода:
find /etc/ -name shadow 2> stderr.txt 1> stdout.txt

# Перенаправление stdout и stderr в один и тот же файл
find / > allfiles_and_errors.txt 2>&1

# Нельзя использовать как 1>&2, так и 2>&1 для переключения stdout и stderr. Нужен третий поток для переключения stdout и stderr после символа канала
rm file1 3>&1 1>&2 2>&3 | sed 's/file1/FILE1/'

# Конструкция &> поместит как stdout, так и stderr в один поток (в файл)
rm file1 &> out_and_err
```

## Service and Process Management

Существует два типа служб: __внутренние__, которые требуются при запуске системы и которые, например, выполняют задачи, связанные с оборудованием, и __пользовательские__, которые обычно включают в себя все серверные службы. Такие службы работают в фоновом режиме без какого-либо взаимодействия с пользователем. Их также называют демонами и обозначают буквой «d» в конце имени программы, например, sshd или systemd.

Большинство дистрибутивов Linux перешли на systemd. Этот демон представляет собой инициализирующий процесс, запускаемый первым, и поэтому имеет PID 1. Этот демон контролирует и обеспечивает упорядоченный запуск и остановку других служб. Всем процессам присвоен PID, который можно просмотреть в /proc/ с соответствующим номером. Такой процесс может иметь идентификатор родительского процесса (PPID), и если имеет, то он называется дочерним процессом.

Процесс может находиться в следующих состояниях:
- Running;
- Waiting (ожидание события или системного ресурса);
- Stopped;
- Zombie (остановлен, но запись в таблице процессов все еще есть).

**ЧАСТОИСПОЛЬЗУЕМЫЕ СИГНАЛЫ ПРОЦЕССОВ**

- __1 SIGHUP__: Отправляется процессу, когда терминал, который им управляет, закрывается;
- __2 SIGINT__: Отправляется, когда пользователь нажимает `Ctrl+C` в управляющем терминале, чтобы прервать процесс;
- __3 SIGQUIT__: Отправляется, когда пользователь нажимает `Ctrl+D` для выхода;
- __9 SIGKILL__: Немедленное завершение процесса без операций очистки;
- __15 SIGTERM__: Завершение программы;
- __19 SIGSTOP__: Остановить программу;
- __20 SIGTSTP__: Отправляется, когда пользователь нажимает `Ctrl+Z`, чтобы запросить приостановку службы.

### Background processes

Иногда необходимо перевести процесс в фоновый режим, чтобы продолжить использование текущего сеанса для взаимодействия с системой или запуска других процессов. Перевести процесс в фоновый режим можно с помощью `CTRL+Z`, указания `&` в конце командной строки. `bg` отображает все фоновые процессы. `fg <id>` позволяет вывести фоновый процесс в основной поток. Фоновые процессы позволяют использовать тот же сеанс оболочки, не дожидаясь, пока процесс сначала завершится. Как только сканирование или процесс завершат свою работу, терминал уведомит нас о завершении процесса.

### Executing multiple commands

Способы запуска нескольких команд разделителями:
- __;__: Игнорирует код возврата предыдущей команды;
- __&&__: Если код возврата предыдущей команды не 0, то выполнение команд прерывается;
- __|__: Зависит не только от корректной и безошибочной работы предыдущих процессов, но и от результатов предыдущих процессов.

## PTY

- Псевдотерминалы (PTY) - это абстрактные устройства в операционной системе Linux, предназначенные для обеспечения взаимодействия между процессами и терминалами. PTY используются для обеспечения доступа к текстовому вводу/выводу, такому как командная оболочка, через различные уровни абстракции
- Виртуальные терминалы используют псевдотерминалы (PTY), чтобы обеспечить взаимодействие пользователя с текстовой оболочкой
- В Linux каждый псевдотерминал имеет пару: мастер и слейв. Мастер является "внешним" интерфейсом, через который пользователь взаимодействует с псевдотерминалом, а слейв - "внутренним" интерфейсом, используемым программами
- VT создаются при загрузке системы и могут быть управляемыми с помощью утилит, таких как chvt и openvt. Пользователь может переключаться между VT с помощью клавиш Ctrl+Alt+F1, Ctrl+Alt+F2 и так далее
- Пользователь может войти в VT, введя логин и пароль. Для выхода из VT можно использовать команду exit. VT можно завершить, нажав Ctrl+Alt+Del (важно отметить, что это не то же самое, что перезагрузка системы). Управление VT можно выполнять с помощью утилиты chvt для переключения между VT
- PTY может быть создан с помощью системных вызовов, таких как openpty(), forkpty(), posix_openpt(), и других
- Процесс, создающий PTY, становится мастером, а второй процесс (обычно оболочка) становится слейвом

Один из наиболее распространенных способов использования PTY - это выполнение удаленных команд через SSH. При подключении к удаленному хосту, SSH использует PTY для обеспечения интерактивного текстового ввода/вывода между клиентом и сервером

## Bonding

**Бондинг (объединение сетевых интерфейсов, агрегирование каналов)** - это технология, позволяющая объединять несколько сетевых интерфейсов в одну виртуальную сетевую карту для увеличения пропускной способности и/или обеспечения отказоустойчивости.

Поведение связанных интерфейсов зависит от режима; режимы предоставляют либо услуги горячего резерва, либо услуги балансировки нагрузки. Кроме того, может выполняться мониторинг целостности канала.

Крайне важно указать параметры miimon или arp_interval и arp_ip_target , в противном случае во время сбоев канала произойдет серьезная деградация сети. Очень немногие устройства не поддерживают хотя бы miimon, поэтому нет причин не использовать его.

```bash
/etc/netplan/_____.yaml
cat /proc/net/bonding/bond0
```
- Конфигурационные файлы, отвечающие за конфигурирование Bond
```bash
ip a
ethtool
bmon
```
- Утилиты для проверки работоспособности Bond
```yml
network:
	bonds:
		bond0:
			dhcp4: true
			interfaces: [ens38, ens33]
			parameters:
				mode: balance-rr
				transmit-hash-policy: layer3+4
				mii-monitor-interval: 1
	ethernets:
		ens38:
				dhcp4: false
				dhvp6: false
		ens33:
				dhcp4: false
				dhcp6: false
	version: 2
```
- Пример конфигурирования файлов для корректной работы Bond

## CLI

- **CLI (Command Line Interface)** - текстовый интерфейс для работы с ОС
- **Терминал:** это окно или приложение, в котором пользователь взаимодействует с CLI. В Linux есть множество терминалов, включая виртуальные терминалы (VT) и терминалы в графической среде
- **Виртуальные терминалы (или VT)** - это механизм в операционной системе Linux, который предоставляет текстовые консоли, позволяющие пользователям взаимодействовать с системой в текстовом режиме. **Локальные VT** доступны напрямую с физической консоли, обычно через клавиши Ctrl+Alt+F1, Ctrl+Alt+F2 и так далее. **Удаленные VT** могут быть доступны посредством SSH или других удаленных протоколов
- **Оболочка (Shell):** оболочка - это программа, которая обрабатывает команды, введенные пользователем, и выполняет их. Примеры оболочек включают Bash, Zsh, Fish и другие
- **Команда:** это текст, введенный пользователем, который указывает системе, какое действие выполнить
- **Аргументы:** это дополнительные параметры, передаваемые команде, чтобы уточнить ее действие
- **Путь (Path):** это указание на файл или каталог в файловой системе
- **Псевдоним (Alias):** это короткое имя, которое может быть связано с длинной командой для удобства
