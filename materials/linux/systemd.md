# systemd

```bash
# Запустить сервис
systemctl start application

# Перезапустить сервис
systemctl restart application

# Остановить сервис
systemctl stop application

# Перезагрузить файлы конфигурации
systemctl reload application

# Автоматический запуск службы при загрузке
systemctl enable application

# Убрать из автозагрузки
systemctl disable application

# Вывод списка всех сервисов
systemctl list-units

# Вывод информации о процессе
systemctl status ssh

# Список всех запущенных сервисов
service --status-all
```


Сервисы или службы - это программы, которые работают в системе Linux в фоновом режиме. Большинство сервисов необходимы для полноценной работы системы, они следят за состоянием системы, обеспечивают автоматическое подключение внешних устройств и сети, позволяют процессам взаимодействовать с оборудованием, а также в виде служб реализованы различные веб-серверы и серверы баз данных.

При запуске системы загружается целый ряд сервисов, которые включены для автозагрузки, то есть пользователь еще не вошел в систему, а основные службы уже запущенны и работают. Сервисы работают пока система запущена, и выгружаются при выключении системы.

Чаще всего в Linux дистрибутивах для инициализации сервисов используется демон **Systemd**. К Systemd-дистрибутивам относятся Ubuntu, Debian, Linux Mint, Fedora, openSUSE, Solus и другие.

В качестве примеров сервисов можно привести: веб-сервер Apache, Network Manager, файрвол Ufw и другие.

Чтобы всем этим управлять нужна основная служба - система инициализации, которая будет запускать службы Linux в нужный момент, следить чтобы они нормально работали, записывать сообщения логов, и самое главное позволять останавливать службы.

Система инициализации запускается и начинает свою работу (инициализировать службы) сразу после загрузки ядра. После запуска systemd собирает весь вывод службы в лог, и следит за ее работой, если служба аварийно завершилась, то автоматически ее перезапускает.

Служба в Systemd описывается файлом юнита, в нем описано что с ней нужно делать и как себя вести. Существуют такие типы служб:

- **service** - обычная служба, программа
- **target** - группа служб
- **automount** - точка автоматического монтирования
- **device** - файл устройства, генерируется на этапе загрузки
- **mount** - точка монтирования
- **path** - файл или папка
- **scope** - процесс
- **slice** - группа системных служб systemd
- **snapshot** - сохраненное состояние запущенных служб
- **socket** - сокет для взаимодействия между процессами.

Нас будут интересовать только service, и совсем немного target, но мы рассмотрели все остальные, чтобы вы смогли взглянуть на картину немного шире.

### 1.2 Systemctl

В Systemd есть специальный инструмент для управления службами в Linux - systemctl. Эта утилита позволяет делать очень много вещей, начиная от перезапуска службы и проверки ее состояния, до анализа эффективности загрузки службы.

Синтаксис systemctl следующий:

```
 $ systemctl опции команда служба
```

Для начала рассмотрим доступные команды:

- **list-units** - посмотреть все службы (юниты), аналог - опция -t
- **list-sockets** - посмотреть все службы сокетов
- **start** - запустить службу linux
- **stop** - остановить службу linux
- **reload** - обновить конфигурацию службы из файла юнита
- **restart** - перезапустить службу
- **try-restart** - перезапустить службу, только если она запущена
- **reload-or-restart** - обновить конфигурацию затем выполнить перезапуск службы linux, если не поддерживается - только перезапустить
- **isolate** - запустить только одну службу вместе с ее зависимостями, все остальные остановить
- **kill** - отправить сигнал завершения процессу используется вместе с опциями --signal и --kill-who
- **is-active** - проверить запущена ли служба linux
- **is-failed** - проверить не завершилась ли служба с ошибкой
- **status** - посмотреть состояние и вывод службы
- **show** - посмотреть параметры управления службой в Linux
- **reset-failed** - перезапустить службы linux, завершившиеся с ошибкой
- **list-dependencies** - посмотреть зависимости службы linux
- **list-unit-files** - вывести все установленные файлы служб
- **enable** - добавить службу в автозагрузку
- **disable** - удалить службу из автозагрузки
- **is-enabled** - проверить если ли уже служба в автозагрузке
- **reenable** - сначала выполнить disable потом enable для службы
- **list-jobs** - все запущенные службы linux независимо от типа
- **snapsot** - сохранить состояние служб, чтобы потом восстановить
- **daemon-reload** - обновить конфигурацию всех служб
- **mask -** сделать юнит недоступным
- **unmask** - вернуть файл службы linux

А теперь основные опции:

- **t, --type** - тип служб для вывода
- **a, --all** - показать все известные службы, даже не запущенные
- **q** - минимальный вывод
- **-version** - версия программы
- **-no-pager** - не использовать постраничную навигацию
- **-no-legend** - не выводить подробное описание
- **f** - принудительное выполнение команды
- **-runtime** - не сохранять вносимые изменения после перезагрузки
- **n** - количество строк вывода лога для команды status
- **--plain** - использовать обычный текстовый режим вместо деревьев
- **-kill-who** - задать процесс, которому нужно отправить сигнал
- **-signal** - сигнал, который нужно отправить.
- -state - отфильтровать список служб по состоянию.

Для большинства повседневных задач вы будете использовать команды **start, stop, reload, restart, enable и disable**.

Чтобы запустить тот или иной сервис, воспользуйтесь следующей командой:

```jsx
$ sudo systemctl start application.service
```

Вместо “application” укажите сервис, который вы хотите запустить.

Суффикс .service указывает на то, чтобы вы работаете со службой, однако systemd достаточно умна чтобы знать, что вы хотите работать со службой при использовании команд по управлению службами, следовательно его можно опустить.

В следующем примере демонстрируется остановка службы, обратите внимание что суффикс отсутсвтует:

```jsx
$ sudo systemctl stop application
```

Чтобы перезапустить работающую службу, можно использовать команду `restart`:

```
$ sudo systemctl restart application
```

Если данное приложение может перезагрузить файлы конфигурации (без перезапуска), вы можете выдать команду `reload` для инициализации этого процесса:

```
$ sudo systemctl reload application
```

Если вы не уверены, есть ли у службы функция перезагрузки своей конфигурации, можно использовать команду `reload-or-restart`. Это перезагрузит необходимую конфигурацию при наличии. В противном случае будет перезагружена служба для выбора новой конфигурации:

```jsx
$ sudo systemctl reload-or-restart application
```

Указанные выше команды полезны для запуска или остановки служб во время текущего сеанса. Чтобы дать команду `systemd` автоматически запускать службы при загрузке, их необходимо включить. Для запуска службы во время загрузки используйте команду `enable`:

```
$ sudo systemctl enable application
```

При этом будет создана символическая ссылка из системной копии служебного файла (обычно в `/lib/systemd/system` или `/etc/systemd/system`) в месте на диске, где `systemd` ищет файлы для автозапуска.

Чтобы отключить автоматический запуск службы, можно ввести следующее:

```
$ sudo systemctl disable application
```

При этом будет удалена символическая ссылка, что укажет на то, что служба не должна запускаться автоматически.

Помните, что включение службы не запустит ее в текущем сеансе. Если вы хотите запустить службу и включить ее при загрузке, необходимо дать обе команды, `start` и `enable`.

### Проверка статуса служб

Чтобы проверить статус службы в вашей системе, можно использовать команду `status`:

```
$ systemctl status application.service
```

При этом вы получите статус службы, иерархию контрольных групп и первые несколько строк журнала.

Например, при проверке статуса сервера Nginx вы можете видеть следующий вывод:

```
Output
● nginx.service - A high performance web server and a reverse proxy server
   Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled)
   Active: active (running) since Tue 2015-01-27 19:41:23 EST; 22h ago
 Main PID: 495 (nginx)
   CGroup: /system.slice/nginx.service
           ├─495 nginx: master process /usr/bin/nginx -g pid /run/nginx.pid; error_log stderr;
           └─496 nginx: worker process
Jan 27 19:41:23 desktop systemd[1]: Starting A high performance web server and a reverse proxy server...
Jan 27 19:41:23 desktop systemd[1]: Started A high performance web server and a reverse proxy server.

```

Это дает вам хороший обзор текущего статуса приложения и уведомляет о наличии каких-либо проблем или необходимости выполнения каких-либо действий.

### Обзор состояния системы

Команды до сих пор были полезны для управления отдельными службами, но они не очень подходят для понимания текущего состояния системы. Существует ряд команд `systemctl`, предоставляющих эту информацию.

Чтобы увидеть список всех активных модулей, о которых знает `systemd`, можно использовать команду `list-units`:

```
$ systemctl list-units
```

Это покажет вам список всех модулей, которые у `systemd` активны в системе. Результат будет выглядеть примерно так:

```
Output
UNIT                                      LOAD   ACTIVE SUB     DESCRIPTION
atd.service                               loaded active running ATD daemon
avahi-daemon.service                      loaded active running Avahi mDNS/DNS-SD Stack
dbus.service                              loaded active running D-Bus System Message Bus
dcron.service                             loaded active running Periodic Command Scheduler
dkms.service                              loaded active exited  Dynamic Kernel Modules System
getty@tty1.service                        loaded active running Getty on tty1
. . .

```

Вывод содержит следующие столбцы:

- **UNIT**: имя модуля `systemd`
- **LOAD**: указывает на то, парсила ли `systemd` конфигурацию модуля. Конфигурация загруженных модулей сохраняется в памяти.
- **ACTIVE**: краткое состояние активности модуля. Обычно это довольно стандартный способ сообщить, запущен модуль или нет.
- **SUB**: это состояние более низкого уровня, которое указывает более подробную информацию о модуле. Это часто зависит от типа модуля, состояния и фактического метода работы модуля.
- **DESCRIPTION**: краткое текстовое описание того, чем является модуль/что делает.

Поскольку команда `list-units` показывает по умолчанию только активные модули, для всех вводов выше отобразится `loaded` в столбце LOAD и `active` в столбце ACTIVE. Это отображение фактически является поведением по умолчанию `systemctl` при вызове без дополнительных команд, поэтому вы увидите то же, что и при вызове `systemctl` без аргументов.

### Команда **service**

Вы также можете использовать другой способ мониторинга служб Linux - команду service. Однако systemctl является основным инструментом в инструменте управления сервисами и содержит в себе функцию service, другими словами принципиальной разницы в вышеописанных способах нет, это лишь разные обращения к одному и тому же инструменту. Тем не менее Вы должны владеть разными подходами, поэтому ниже представлены основные варианты использования команды service на примере работы с некоторыми распространеннными сервисами.

Чтобы посмотреть какие сервисы у нас работают, необходимо ввести команду

`service --status-all`

## 2. Передача файлов

### 2.1 SFTP

**FTP (File Transfer Protocol)**, или протокол передачи файлов, был популярным методом незашифрованной передачи файлов между двумя удаленными системами.

**SFTP (Secure FTP)**, протокол передачи файлов по **SSH**, или безопасный протокол передачи файлов, — это отдельный протокол, поддерживающий SSH, который работает схожим образом, но использует защищенное подключение. Его преимуществом является возможность использования защищенного подключения для передачи файлов и просмотра файловой системы как на локальной, так и на удаленной системе.

Практически во всех случаях использование SFTP будет более предпочтительным по сравнению с FTP из-за имеющихся у первого функций безопасности и возможности использования подключения SSH. FTP — это небезопасный протокол, который следует использовать в ограниченных случаях или в сетях, которым вы доверяете.

По умолчанию SFTP использует протокол SSH для аутентификации и установки защищенного подключения. По этой причине протокол использует те же методы аутентификации, что и SSH.

Так как SFTP работает поверх SSH, первым делом необходимо установить OpenSSH как со стороны сервера (хранилища):

```html
$ sudo apt install openssh-server
```

Также необходимо установить ssh на стороне клиента (устройства, с которого планируется доступ к хранилищу):

```html
$ sudo apt install ssh
```

Для безопасного использования SFTP, лучше всего создать группы и пользователей, которые будут использовать только эту службу:

```html
$ sudo useradd -g sftpgroup sftpuser
$ sudo passwd sftpuser
```

Cоздадим каталоги и изменим их доступ:

```html
$ sudo mkdir -p /data/sftpuser/upload 
$ chown -R root.sftpgroup /data/sftp 
$ chown -R sftpuser.sftpgroup /data/sftp/upload
```

_Важно: убедитесь, что владелец /data/sftpuser - root, это обязательно для изменения корневого каталога в SFTP._

Далее нужно настроить сервер так, чтобы когда пользователь, из группы **sftpgroup**, входил в систему, он попадал в **sftp** вместо обычной оболочки, в которую попадает через **ssh**. Для этого нужно добавьте фрагмент кода в файл /etc/ssh/sshd_config. Для редактирования файлов в Linux существует текстовый редактор nano. Чтобы воспользоваться им достаточно выполнить команду nano “путь к файлу”:

```html
$ nano /etc/ssh/sshd_config
```

Добавляем следующее:

```html
Match Group sftpgroup
ChrootDirectory /data/%u
ForceCommand internal-sftp
```

ChrootDirectory позволяет создать необходимый каталог в качестве корневого узла (/ каталог) в дереве каталогов. Вошедший в систему пользователь не сможет увидеть ничего выше этого каталога и это не даст ему получить доступ к файлам других пользователей. %u - это код для заполнения текущим именем пользователя во время входа в систему.

Для сохранения файла нажимаем ctrl + O, и выходим из редактора с помощью ctrl + X.

Чтобы выполнить внесенные в sshd_config изменения, перезапустите службу:

```html
$ sudo systemctl restart sshd
```

Доступ по sftp осуществляется аналогично с ssh → **sftp username@host** (чтобы узнать ip-адрес хоста выполните команду **ip a**) :

```html
$ sftp sftpuser@192.168.183.128
```

После успшеного подключения при необходимости загрузки файлов с удаленного хоста мы можем воспользоваться следующей командой для выполнения этой задачи: `sftp> get FileName`

По умолчанию команда get загружает удаленный файл и сохраняет файл с тем же именем в локальной файловой системе. Мы можем указать имя, с которым сохранится файл, добавив его в вышеуказанную команду:

`sftp> get FileName NewName`

Команда `get` также имеет несколько флагов. Например, мы можем скопировать каталог и все его содержимое с помощью рекурсивной опции: `sgtp> get -r DirectoryName`

Передача файлов в удаленную систему осуществляется таким же удобным образом с помощью команды с именем «put»:

`sftp> put FileName`

Директории передаются аналогичным с получением образом:

`sgtp> put -r DirectoryName`

Одним из хорошо знакомых инструментов, который может быть полезен при скачивании и загрузке файлов, является команда `df`, которая работает схожим образом с используемой в командной строке версией данной инструкции. Она позволяет убедиться, что у вас в распоряжении есть достаточное количество места для передачи данных, которые вас интересуют:

`sftp> df -h`

Вывод команды:

```
Output
    Size     Used    Avail   (root)    %Capacity
  19.9GB   1016MB   17.9GB   18.9GB           4%
```

Обратите внимание, что локального варианта этой команды нет, но мы можем обойти это ограничение, воспользовавшись `!` в качестве команды.

Команда `!` перемещает нас в локальную оболочку, где можно запустить любую команду в локальной системе. Выполнив её, мы можем проверить использование диска также с помощью `df -h`. Чтобы вернуться в сеанс SFTP, введите `exit` .

Для удаления файлов в удаленной системе используется команда **rm**:

`sftp> rm FileName`

### 2.2 WinSCP

Для передачи файлов с клиента под управлением Windows существует FTP-клиент WinSCP. Это свободный графический клиент протоколов SFTP и SCP, предназначенный для Windows. Благодаря графическому интерфейсу воспользоваться им не составит труда даже начинающему пользователю. Первым делом нужно скачать установщик с официального сайта ([winscp.net](http://winscp.net/)) и, следуя его указаниям, выполнить установку программы. При открытии пользователя встречает окно подключения к серверу:

Для подключения к нашем sftp-серверу введите ip-адрес в поле имя хоста, укажите порт 22 (если не меняли), имя пользователя и пароль.

При успешном подключении увидим следующую картину:

Для получения файла с сервера нажмите на соответствующий пункт и укажите путь, куда вы хотите сохранить файл:

Для загрузки файла на сервер достаточно перетащить его из папки на клиенте в нужный каталог, открытый в WinSCP:

### 2.3 Samba

Samba – это программное обеспечение для реализации файлового сервера. Данный сервис дает возможность обращаться к сетевым дискам и принтерам по протоколу SMB/CIFS. Имеет клиентскую и серверную части. Samba – свободно распространяемое ПО. Начиная с версии 4 в Samba была реализована возможность выступать в роли контроллера домена и аналога сервиса Active Directory.

Устанавливая Samba и базовые сетевые службы (DNS, NTP, Kerberos) на один из Linux-дистрибутивов вы получаете следующую функциональность:

1. Контроллер домена Active Directory:

- Служба Аутентификации на базе Kerberos v5
- LDAP-совместимая служба каталогов c возможностью репликации по DRS
- Сервер управления групповыми политиками
- DNS-сервер на базе BIND

1. Файловый сервер
2. Сервер печати

_Прежде чем приступить к установке, убедитесь, что вы вошли в систему как пользователь с правами суперпользователя, а также обновите пакеты (apt update и apt upgrade)_.

Для установки выполните:

```html
$ apt install samba 
```

Проверим корректность установки:

```html
$ systemctl status smbd
```

Создадим директорию, в которую будем организовывать общий доступ, и в ней тестовый текстовый файл:

```html
$ mkdir /Samba_Dir
$ touch /Samb_Dir/FileToShare
```

Установм полные права доступа всем пользователям на созданный только что каталог Samba_Dir:

```html
$ chmod 777 /Samba_Dir
```

Откроем файл конфигурации samba /etc/samba/smb.conf и пропишем там следующие настройки:

В случае, если samba-сервер не работает, одной из причин может быть ошибка в конфигурационном файле. Чтобы не искать её вручную, была создана утилита testparm. После анализа заданного конфигурационного файла testparm выводит все значения файла smb.conf, включая значения по умолчанию. Это помогает убедиться, что используются ожидаемые значения параметров конфигурации.Стоит отметить, что значения по умолчанию меняются от версии к версии, так что необходимо использовать версию Samba, соответствующую версии testparm.

Использование:

```html
$ testparm /etc/samba/smb.conf
```

Теперь перезапустим samba командой systemctl restart smbd и убедимся в том, что все работает, зайдя в нашу папку со сторонней windows машины. Для этого в проводнике вместо пути пропишите ip-адрес файлового сервера (узнать его можно с помощью команды ip a):

### 2.4 Filezilla

Протокол FTP в наши дни очень часто используется многими веб-мастерами и разработчиками для загрузки файлов на сервера, управления файлами сайтов и решения других подобных задач. Такой популярности этот протокол набрал потому, что он прост в использовании и не требует особых знаний устройства и команд операционных систем Linux.

Для демонстрации развернем на виртуальной машине FTP-сервер. Будем использовать FTP-сервер VSFTPD (Very Secure FTP Daemon), который обеспечивает самую надёжную защиту от уязвимостей.

**Установка vsftpd**:

`$ sudo apt install vsftpd`

Заранее создадим файл со списком пользователей vsftpd:

`$ sudo nano /etc/vsftpd.userlist`

И добавим пользователя ftpu:

`$ sudo useradd ftpu`

`$ sudo passwd ***`

Добавьте его имя в файл **/etc/vsftpd.userlist,** чтобы ****предоставить FTP-доступ пользователю:

`$ echo "ftpu" | sudo tee -a /etc/vsftpd.userlist`

Сами **настройки vsftpd** хранятся в конфигурационном файле **/etc/vsftpd.conf**

Прежде чем вносить в него изменения создадим резервную копию:

`$ sudo cp /etc/vsftpd.conf /etc/vsftpd.conf.orig`

Теперь откроем файл:

`$ sudo nano /etc/vsftpd.conf`

Добавьте такие настройки. Вам нужно будет найти и изменить значения указанных строк, или, если таковые отсутствуют, добавить новые.

```html
listen=YES  #Указываем, что нужно ожидать входящих соединений
```

```html
listen_ipv6=NO
```

```html
connect_from_port_20=YES #Использовать порт 20 для передачи данных вместо случайного
```

```html
anonymous_enable=NO #отключаем анонимный вход
```

```html
local_enable=YES #Разрешаем использовать имена локальных пользователей для входа
```

```html
write_enable=YES #Для авторизованных пользователей разрешаем команды, позволяющие изменять файловую систему
```

```html
chroot_local_user=YES
allow_writeable_chroot=YES
#При входе пользователей на FTP-сервер, они могут работать
#только в корневом каталоге FTP.
#Если вы хотите, чтобы пользователи были ограничены только своей домашней папкой,
#то необходимо раскомментировать эти строчки:
```

```html
secure_chroot_dir=/var/run/vsftpd/empty
```

```html
pam_service_name=vsftpd #Использовать PAM-библиотеки
```

```html
userlist_enable=YES #разрешим аутентификацию только пользователей, перечисленных в файле userlist:
```

```html
userlist_file=/etc/vsftpd.userlist #Указываем файл с виртуальными пользователями
```

```html
userlist_deny=NO #По умолчанию пользователям из userlist запрещён вход в систему, данная настройка делает наоборот
```

Затем необходимо **включить** сервис **vsftpd**, поскольку он не будет запущен по умолчанию, а также добавить службу в автозагрузку:

`$ sudo systemctl start vsftpd`

`$ sudo systemctl enable vsftpd`

Проверим статус сервиса:

Теперь, когда мы настроили FTP-сервер, посмотрим как можно к нему обращаться.

Один из самых популярных FTP клиентов, который используется множеством пользователей различных платформ, включая Windows, MacOS и даже Linux. Эта программа позволяет очень просто подключаться к удаленному серверу, выполнять там нужные действия, например, редактировать файлы, загружать их или скачивать, а также удобно просматривать файловую систему. В этой статье мы рассмотрим как пользоваться FileZilla для решения своих задач.

Для установки программы используйте такую команду:

`$ sudo apt install filezilla`

Откроем программу через графический интерфейс:

Для подключения к удаленному серверу введите ip-адрес сервера в поле Host, имя созданного пользователя в поле Username и пароль пользователя в поле Password. Нажмите quickconnect.

После подключения у Вас в одной части экрана будут видны локальные файлы, а в другой части будут файлы и директории на удаленном сервере. Вы можете _копировать_ их в любую сторону простым перетаскиванием из одной части рабочей области в другую, точно так же, как и в обычном проводнике **Windows**. Вы также можете _удалять_ файлы, _перемещать (переименовывать)_, _редактировать_ их и _изменять права доступа_ (chmod) к файлам и директориям на сервере.

## 3. Web-сервисы

Веб-сервис (служба) – программа, которая организовывает взаимодействие между сайтами и клиентами. Apache и Nginx – самые распространенные представители.

### 3.1 Apache

Apache – это свободное программное обеспечение для размещения веб-сервера. Он хорошо показывает себя в работе с масштабными проектами, поэтому заслуженно считается одним из самых популярных веб-серверов. Кроме того, Apache очень гибок в плане настройки, что даёт возможность реализовать все особенности размещаемого веб-ресурса.

Apache состоит из ядра и динамической модульной системы. Параметры системы изменяются с помощью конфигурационных файлов.

### Ядро

Ядро Apache разработано Apache Software Foundation на языке C. Основные функции — обработка конфигурационных файлов, протокол HTTP/HTTPS и загрузка модулей. Ядро может работать без модулей, но будет иметь ограниченный функционал.

### Модульная система

Модуль – отдельный файл, подключение которого расширяет изначальный функционал ядра. Они могут включаться в состав ПО при первоначальной установке или подгружаться позже через изменение конфигурационного файла.

Большинство из них отвечает за определенный аспект обработки клиентского запроса – поддержку различных языков программирования, безопасность, кэширование, аутентификацию и т.д. Таким образом, большая задача разбивается на несколько фаз, каждую из которых решает отдельный, узкоспециализированный модуль.

Для Apache существует больше 500 модулей. Многие популярные веб-приложения сразу выпускаются в виде модуля к Apache. Например, ISPmanager и VDSmanager.

### Виртуальные хосты

Веб-хост – это компонент сервера, отвечающий за обслуживание одного размещенного на нем объекта (сайта, виртуального сервера). Система виртуальных хостов Apache позволяет одновременно запускать несколько проектов с одного IP-адреса.

В Apache можно установить настройки модуля и ядра, а также вводить лимиты на потребление серверных ресурсов (трафик, RAM, CPU) для каждого виртуального хоста в отдельности. Это технологическая основа всего механизма веб-хостинга.

### Установка

```html
$ sudo apt install apache2
```

Зайдем на [localhost](http://localhost) чтобы убедиться что все работает:

Добавим сервис в автозагрузку:

```html
$ systemctl enable apache2
```

### Конфигурация

Все настройки содержатся в папке /etc/apache2/:

Внести изменения можно как через редактирование самого файла, так и через командную строку.

Веб-сервер Apache может запускать несколько веб-сайтов на одном компьютере. Каждый запущенный сайт («виртуальный хост») должен иметь свою собственную конфигурацию. Дефолный виртуальный хост описывается в файле /etc/apache2/sites-available/000-default.conf. Давайте посмотрим на него:

Чтобы сделать свой хост, нужно создать корневую директорию, а также создать базовую страницу, которая будет отображаться при открытии сайта:

```html
$ mkdir /var/www/example1
$ echo “Hello” > /var/www/example1/index.html
```

Затем создаем конфигурационный файл:

```html
$ nano /etc/apache2/sites-available/example1.conf
```

И вставляем туда базовые настройки:

Чтобы активировать ваш виртуальный хост, используйте команду a2ensite. Эта команда создаёт символическую ссылку файла в каталоге /etc/apache2/sites-enabled. Затем перезапустите веб-сервер:

```html
$ sudo a2ensite example1.conf
$ systemctl reload apache2
```

Осталось прописать доменное имя в файле /etc/hosts:

### 3.2 Nginx

Nginx — это веб-сервер с открытым исходным кодом, созданный работать под высокой нагрузкой, чаще всего используемый для отдачи статического контента, например, html страниц, медиафайлов, документов, архивов, картинок и т.д.

В отличие от других продуктов данного сегмента, Nginx использует иной принцип обработки входящих данных. ПО разбивает каждый запрос пользователя на несколько мелких, упрощая таким образом обработку каждого. В терминологии Nginx они получили название рабочее соединение.

После обработки каждое соединение собирается в одном виртуальном контейнере, чтобы трансформироваться в единый первоначальный запрос, а после отправляется пользователю. Одно соединение может одновременно обрабатывать до 1024 запросов конечного пользователя.

Для уменьшения нагрузки на оперативную память веб-сервер использует выделенный сегмент памяти, который называется «пул» (pool). Он динамический и расширяется при увеличении длины запроса.

### Установка

```html
$ sudo apt install nginx
```

### Конфигурация

Файлы конфигурации nginx находятся в папке /etc/nginx. Рассмотрим их:

- **/etc/nginx/nginx.conf** – главный файл конфигурации nginx.
- **/etc/nginx/sites-available** – каталог с конфигурациями виртуальных хостов, т.е. каждый файл, находящийся в этом каталоге, содержит информацию о конкретном сайте – его имени, IP адресе, рабочей директории и т.д.
- **/etc/nginx/sites-enabled** – в этом каталоге содержаться конфигурации сайтов, обслуживаемых nginx, т.е. активных, как правило, это символические ссылки sites-available конфигураций, что очень удобно для оперативного включения и отключения сайтов

Теперь мы создадим виртуальный хост для Nginx, используя ту же процедуру, что использовалась для Apache. Вначале необходимо создать корневой каталог. По умолчанию Nginx требует хранить сайты в каталоге /usr/share/nginx. Назовем веб-проект example1 и положим туда html файл, содержащий в себе заголовок [example.com](http://example.com):

```html
$ sudo mkdir -v /usr/share/nginx/example1.com
$ echo "<h1>Hello</h1>" | sudo tee /usr/share/nginx/example1.com/index.html
```

Удалим виртуальный хост по умолчанию, так как далее заменим его своим:

```html
$ sudo rm /etc/nginx/sites-enabled/default
```

Теперь создаем файл виртуального хоста для домена [example1.com](http://example1.com) и внесем туда настройки

```html
$ sudo nano /etc/nginx/sites-available/example1.com
```

Убедимся в отсутствии ошибок в конфигурации:

```html
$ sudo nginx -t
```

Активируем сайт, создав символическую ссылку на каталог sites-enabled:

```html
$sudo ln -s /etc/nginx/sites-available/example1.com /etc/nginx/sites-enabled/example1.com
```

Посмотрим на результат нашей работы, перейдя по адресу нашего хоста в браузере:

## 4. Cron

Системным администраторам, да и обычным пользователям часто приходится автоматизировать различные задачи по обслуживанию и работе с Linux с помощью скриптов. Это очень удобно, вы просто запускаете скрипт, и он делает все что необходимо без вашего вмешательства. Следующий шаг в этом пути - настроить автоматически запуск нужного скрипта в нужное время. Именно для этих задач в Linux используется системный сервис **cron**. Это планировщик, который позволяет выполнять нужные вам скрипты раз в час, раз в день, неделю или месяц, а также в любое заданное вами время или через любой интервал. Программа часто используется даже другими службами операционной системы.

Фактически, Cron - это сервис, как и большинство других сервисов Linux, он запускается при старте системы и работает в фоновом режиме. Его основная задача выполнять нужные процессы в нужное время. Существует несколько конфигурационных файлов, из которых он берет информацию о том что и когда нужно выполнять. Сервис открывает файл /etc/crontab, в котором указаны все нужные данные. Часто, в современных дистрибутивах там прописан запуск утилиты run-parts, которая запускает нужные скрипты из следующих папок:

- **/etc/cron.minutely** - каждую минуту;
- **/etc/cron.hourly** - каждый час;
- **/etc/cron.daily** - каждый день;
- **/etc/cron.weekly** - каждую неделю;
- **/etc/cron.monthly** - каждый месяц.

В этих папках должны находиться скрипты, которые нужно выполнять с указанным интервалом. Скрипты должны иметь права на выполнение и их имя не должно содержать точки. Это очень сильно облегчает работу с планировщиком для новых пользователей. Также в файле crontab прописан запуск команды anacron, которая работает так же как и cron, только предназначена для задач, которые нужно выполнять раз в длительный период, например, раз в день, неделю, месяц, год.

Она позволяет выполнять их даже если компьютер работает не всегда и время от времени выключается. Дата выполнения задания последний раз записывается в файл /var/spool/anacron, а затем, при следующем запуске anacron проверяет был ли запущен нужный процесс в нужное время, и если нет, то запускает его. Сам же сервис cron больше рассчитан на выполнение задач в течение дня или с точно расписанным временем и датой.

Для настройки времени, даты и интервала когда нужно выполнять задание используется специальный синтаксис файла cron и специальная команда. Конечно, вы всегда можете отредактировать файл /etc/crontab, но этого делать не рекомендуется. Вместо этого, есть команда crontab:

`$ crontab -e`

Ее всегда желательно выполнять с опцией -e, тогда для редактирования правил будет использован ваш текстовый редактор по умолчанию. Команда открывает вам временный файл, в котором уже представлены все текущие правила cron и вы можете добавить новые. При первом запуске вам будет предложено выбрать желаемый текстовый редактор (nano, vim).

Чтобы стало понятнее, давайте разберем на примере. Создадим инструкцию на выполнение скрипта /usr/local/bin/script.sh (cкрипт выводит в терминал сообщение) каждую среду в 15 часов 30 минут:

```html
30 15 * * 3 /usr/local/bin/script.sh
```

Символ * означает что инстуркция выполняется во все возможные значения аргумента. В нашем случае каждую тридцатую минуту пятнадцатого часа во все дни и все месяцы, которые являются третьим днем недели (то есть средой). Можно писать сокращенное название дня недели вместо его порядкового номера, например sun - воскресенье.

Для того чтобы указать определенный интервал нужно использовать символ "-", например, каждый час, с семи утра до семи вечера:

```html
0 7-19  * * * /usr/local/bin/script.sh
```

Если нужно запустить команду несколько раз, можно использовать разделитель ",". Например, запустим скрипт в 5 и 35 минут пятого (16:05 и 16:35), каждый день:

```html
5,35 16  * * * /usr/local/bin/script.sh
```

Вы можете захотеть не указывать отдельно время, а просто указать интервал, с которым нужно запускать скрипт, например, раз в 10 минут. Для этого используется разделитель косая черта - "/":

```html
/10 * * * * /usr/local/bin/script.sh
```

Кроме того, для некоторых часто используемых наборов были придуманы переменные, вот они:

**@reboot** - при загрузке, только один раз;

**@yearly, @annually** - раз год;

**@monthly** - раз в месяц;

**@weekly** - раз в неделю;

**@daily, @midnight** - каждый день;

**@hourly** - каждый час.

Например, вот так просто будет выглядеть команда запуска скрипта раз в час:

```html
@hourly /usr/local/bin/script.sh
```

После завершения работы команды cron файл будет обработан и все правила будут добавлены в /var/spool/cron/crontabs/имя_пользователя причем добавленные процессы будут запускаться именно от того пользователя, от которого вы их добавляли.

Поэтому тут нужно быть аккуратным, и если вам нужно выполнять скрипты от рута, то и crontab нужно выполнить от рута, а не от пользователя. Это часто становится причиной проблем.

Можно посмотреть задачи cron для суперпользователя, для этого можно воспользоваться опцией -l:

`$ crontab -l`

Вы можете удалить все существующие задачи командой -r:

`$ crontab -r`

















Задачи можно планировать с помощью systemd. Чтобы создать таймер для systemd, нужно создать каталог, в котором будет храниться скрипт таймера.

```bash
sudo mkdir /etc/systemd/system/mytimer.timer.d
sudo vim /etc/systemd/system/mytimer.timer
```

Далее нужно создать скрипт, настраивающий таймер. Скрипт должен содержать следующие опции: «Unit, «Timer» и «Install». Опция «Unit» определяет описание таймера. Опция «Timer» определяет, когда запускать таймер и когда его активировать. Наконец, опция «Install» указывает, где установить таймер.

```bash
[Unit]
Description=My Timer

[Timer]
OnBootSec=3min
OnUnitActiveSec=1hour

[Install]
WantedBy=timers.target
```

Например, если мы хотим запустить скрипт только один раз после загрузки системы, следует использовать настройку OnBootSec в таймере. Однако если мы хотим, чтобы сценарий запускался регулярно, нам следует использовать OnUnitActiveSec, чтобы система запускала сценарий через регулярные промежутки времени. Далее нам нужно создать наш сервис.

```bash
sudo vim /etc/systemd/system/mytimer.service
```

Здесь задаем описание и указываем полный путь к скрипту, который хотим запустить. «multi-user.target» — это система единиц, которая активируется при запуске обычного многопользовательского режима. Он определяет службы, которые должны запускаться при обычном запуске системы.

```bash
[Unit]
Description=My Service

[Service]
ExecStart=/full/path/to/my/script.sh

[Install]
WantedBy=multi-user.target
```

После этого мы должны позволить systemd снова прочитать папки, чтобы включить изменения.

```bash
sudo systemctl daemon-reload
```

После этого мы можем использовать systemctl, чтобы запустить службу вручную и включить автозапуск.

```bash
sudo systemctl start mytimer.service
sudo systemctl enable mytimer.service
```
