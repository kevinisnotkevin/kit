
## 1. Базовые настройки системы

## Настройка сети

Прежде чем Вы начнете, убедитесь, что:

- Различные сетевые утилиты, предназначенные для автоматического конфигурирования сети выключены.
- Различные сетевые фильтры (например, iptables), и утилиты их конфигурирования (например, Firestarter) отключены/правильно настроены и не вмешиваются в работу сети.
- У Вас есть все необходимые параметры для подключения в Вашей сети (например, IP-адрес, маска подсети и шлюз по умолчанию для соединения с использованием статического IP).
- Устройства сети осуществляющие фильтрацию по MAC-адресу правильно настроены и «знают» Ваш сетевой интерфейс.
- Драйвер Вашего сетевого устройства корректно установлен, кабель (при проводном соединении) исправен и подсоединен.

Для настроек вам обязательно потребуется имя вашего сетевого адаптера. Команды `ip a` и `ifconfig` позволяют посмотреть сетевые интерфейсы системы.

- **enp0s3** - это физический интерфейс, который мы и будем настраивать.
- **eth0** - это физический интерфейс, который обозначает что используется Ethernet интерфейс.
- **lo (loopback)** - это виртуальный интерфейс, указывающий на хост.

```bash
nano /etc/network/interfaces
```
- Настройки сети находятся в файле `/etc/network/interfaces`. Нас интересует auto и iface. Первая указывает, что нужно активировать интерфейс при загрузке, вторая же определяет настройки самого интерфейса.

## Настройка динамического IP-адреса

```bash
auto enp0s3 iface enp0s3 inet dhcp
```
- Добавьте в файл следующую строку, чтобы запускать интерфейс при загрузке и получать IP-адрес автоматически по DHCP.

```bash
service networking restart
```
- Перезагружаем сеть.

## Настройка статического адреса

При настройке статического IP-адреса компьютер не будет связываться с DHCP-сервером, поэтому здесь придётся указать намного больше параметров.

```txt
auto eth0
iface eth0 inet static
address 192.168.1.7
gateway 192.168.1.1
netmask 255.255.255.0
network 192.168.1.0
broadcast 192.168.1.255
```
- Добавляем в файл `/etc/network/interfaces` настройку интерфейса `eth0`, где:
- **address** - наш IP-адрес.
- **gateway** - шлюз, через который будем получать доступ в интернет.
- **netmask** - маска сети.
- **network** - адрес сети, имеет тот же адрес, что и шлюз, только с нулем вместо единицы.
- **broadcast** - широковещательный адрес сети, отправленный на него пакет придет всем компьютерам локальной сети.
- network и broadcast - это первый и последний IP-адреса сети.

```bash
service networking restart
```
- Перезагружаем сеть.

## Настройка сети с использованием команды ip

```bash
sudo ip link set enp0s3 up
```
- Включаем сетевой интерфейс.

```bash
sudo dhclient enp0s3
```
- Запрашиваем IP-адрес у DHCP-сервера.

```bash
sudo ip addr add 192.168.1.7/255.255.255.0 broadcast 192.168.1.255 dev enp0s3
```
- Устанавливаем IP-адрес, маску сети и широковещательный адрес для интерфейса. Здесь 192.168.1.7 - IP-адрес, 255.255.255.0 - маска сети, 192.168.1.255 - широковещательный адрес.

```bash
sudo ip route add default via 192.168.1.1
```
- Указываем IP-адрес шлюза.

```bash
dns-nameservers 8.8.8.8 4.4.4.4
```
- Настраиваем DNS. В файл `/etc/network/interfaces` добавляем строку. При настройке IP-адреса через DHCP используются правильные DNS-серверы, а при настройке IP-адреса вручную могут использоваться неправильные. Во втором случае необходимо выполнить этот шаг. Здесь 8.8.8.8 и 4.4.4.4 это IP-адреса DNS серверов. Дальше сохраните файл и перезапустите сеть. Далее перезапускаем сеть.

# Модель прав доступа

### Права доступа

Согласно модели прав доступа, каждый файл в Linux системах принадлежит одному пользователю и одной группе. Вы можете узнать, какому пользователю и группе принадлежит файл в выводе команды ls -l “путь к файлу”. Он выглядит следующим образом:

```
$ ls -l /bin/bash

$ -rwxr-xr-x l root wheel 430540 Oct 23 19:24 /bin/bash
```

В данном случае мы получили информацию о том, что исполняемый файл /bin/bash принадлежит пользователю root и группе wheel. Модель прав доступа позволяет задать три независимых уровня прав на каждый объект файловой системы — для владельца, для группы и для всех остальных пользователей. Резберем подробнее. Первый знак (-) содержит информацию о типе файла, в данном случае значение “-” свидетельствует о том что перед нами обычный файл. Другие возможные значения:

```
'd' директория

'l' символическая ссылка

'c' устройство символьного ввода-вывода

'b' устройство блочного ввода-вывода

'p' FIFO

's' сокет
```

Оставшиеся до пробела символы определяют какие действия те или иные пользователи могут совершать с файлом. Для удобства восприятия перепишем 2-10 символы, разбив их на тройки:

```
rwx | r-x | r-x
```

Три блока соответсвуют трем типам пользователей. Первый блок - права владельца файла, второй - группы файла, третий - все остальные. В нашем случае владелец файла имеет право на чтение (r - read), запись (w - write), исполнение (x - execute). Оставшиеся два блока отличаются лишь тем, что вместо права записи стоит знак “-”, что говорит о том что данного права у пользователя нет. Таким образом, группа файла и все остальные пользователи могут читать и испольнять файл, однако им не доступна редакция файла. Обратите внимание, что права всегда идут в таком порядке - чтение | запись | исполнение.

Чтобы узнать, под каким пользователем вы сейчас работаете, используйте команду whoami. Для вывода информации о группах, которым вы принадлежите - команда groups. Если вы хотите посмотреть, в каких группах состоит другой пользователь, то передайте его имя в качестве аргумента

```
$ groups root daemon

root : root bin daemon sys adm disk wheel floppy dialout tape video

daemon : daemon bin adm
```

Чтобы изменить владельца или группу файла (или другого объекта) используется команды _chown_ или _chgrp_ соответственно. Сначала нужно передать имя группы или владельца, а потом список файлов.

```
# chown root /etc/passwd
# chgrp wheel /etc/passwd
```

Вы также можете изменить пользователя и группу одновременно используя команду _chown_ в другой форме:

```
# chown root:wheel /etc/passwd
```

Вы не можете использовать команду _chown_ без прав суперпользователя, но _chgrp_ может быть использована всеми, чтобы изменить группу-владельца файла на ту группу, к которой они принадлежат.

### Рекурсивное изменение прав

Команды _chown_ и _chgrp_ могут быть использованы с параметром -R, что позволяет рекурсивно изменить владельца или группу у всех объектов в данной директории и ниже. Пример:

```
# chown -R drobbins /home/drobbins
```

### Знакомство с chmod

C_hown_ и _chgrp_ используются для изменения владельца и группы объекта файловой системы, но кроме них существует и другая программа, называемая _chmod_, которая используется для изменения прав доступа на чтение, запись и исполнение, которые мы видим в выводе команды _ls -l._

C_hmod_ использует два и более аргументов: метод, описывающий как именно необходимо изменить права доступа с последующим именем файла или списком файлов, к которым необходимо применить эти изменения:

```
$ chmod +x **"имя файла"**
```

В примере выше в качестве метода указано +x. Метод +x указывает _chmod_, что файл необходимо сделать исполняемым для пользователя, группы и для всех остальных. Если мы решим отнять все права на исполнение файла, то сделаем вот так:

```
$ chmod -x **"имя файла"**
```

Чтобы изменить права для конкретного типа пользователя, а не для всех, используйте перед -x специальный символ обозначения категории пользователей, который вам необходимо изменить, со знаком + или - перед ним. Используйте u для пользователя, g для группы и o для остальных пользователей.

```
$ chmod go-w **"имя файла"**
```

Командой выше мы удалили право на запись для группы и всех остальных пользователей, но оставили права владельца нетронутыми.

Помимо переключения бит, отвечающих за права доступа, в состояние вкл/выкл, мы можем задать конкретные значения для всех сразу. Используя оператор равенства мы можем указать _chmod_, что хотим задать только указанные права доступа:

```
$ chmod =rx **"имя файла"**
```

Этой командой мы установили все биты чтения и исполнения и сбросили все биты записи. Если вы хотите задать значения конкретной тройки бит, то можете сделать это, указав ее символьное наименование перед оператором равенства:

```
$ chmod u=rx **"имя файла"**
```

### Числовые режимы

До сих пор, мы использовали то что называется символическим способом указания прав доступа для команды _chmod_. Однако есть еще один достаточно распространенный способ указания прав: использование четырехзначных восьмеричных чисел. Этот синтаксис, называется числовым синтаксисом прав доступа, где каждая цифра представляет тройку разрешений. Эта таблица показывает как транслируются права доступа на числовые значения.

**`Режим Число`**

```
rwx     7
rw-     6
r-x     5
r--     4
-wx     3
-w-     2
--x     1
---     0
```

### Числовой синтаксис прав доступа

Числовой синтаксис прав доступа особенно полезен когда требуется указать все разрешения для файла, как показано в следующем примере:

```
$ chmod 0755 **"имя файла"**
```

В этом примере мы назначили права доступа 0755, что равносильно комбинации прав -rwxr-xr-x.

### **suid и sgid**

Расшифровываются эти аббревиатуры как _Set User Identifier_ и _Set Group Identifier_ соответственно. Так называются биты, указывающие особые права доступа к файлам и каталогам, наряду с обычными правами – _rwx_. Проверить наличие такого бита можно с помощью команды ls -l. Если бит установлен, то в выводе вы увидите такую картину:

```
$ -rwxr-***s***r-x  1 root ...
```

Кроме привычных _rwx_ в описании прав доступа к файлу присутствует буква _**s**_ – это и есть идентификатор установленного **SUID** на этот файл.

Зачем нужны SUID и SGID? Есть достаточно много программ и файлов, которые должны принадлежать пользователю root, и в то же время – простые пользователи должны иметь возможность выполнять его. Для примера – утилита passwd (предназначена для управления паролями пользователей), которая находится в каталоге _/usr/bin/passwd_ и которая имеет дело с файлом _/etc/passwd_, редактировать который может только пользователь root. Для того, что бы дать пользователям возможность менять свои пароли – на файл утилиты установлен бит **suid**:

```
$ ls -l /usr/bin/passwd
$ -rw**s**r-xr-x 1 root root 41284 2011-06-24 12:36 /usr/bin/passwd
```

**Suid** даёт возможность на время выполнения файла (запущенного им процесса) непривелигированному пользователю получить права пользователя – владельца файла, в данном случае – root.

Бит **sgid** аналогичен **suid**, но устанавливаются права не пользователя файла, а группы – владельца файла. Так же, все файлы, создаваемые в каталоге с установленным **sgid** будут получать идентификатор группы – владельца каталога, а не владельца файла. Новые каталоги, создаваемые в каталоге с установленным **sgid** будут его наследовать от каталога-родителя.

Так же, следует учитывать, что **suid** установленный, установленный на файл перекрывает **sgid**, установленный на каталог.

### Изменение suid и sgid

Способ установки и удаления битов suid и sgid чрезвычайно прост. Вот так мы задаем бит suid:

```
# chmod u+s /usr/bin/myapp
```

А в следующем примере мы снимаем флаг sgid с директории. Вы увидите, как бит sgid работает с директориями немного ниже:

```
# chmod g-s /home/drobbins
```

### Права и директории

До текущего момента мы рассматривали права доступа с точки зрения обычных файлов. Когда речь заходит о директориях, появляются некоторые отличия. Директории используют те же флаги прав доступа, но их интерпретация имеет немного другой смысл.

Если для директории задан флаг чтения, то вы можете просматривать список содержимого директории; флаг записи означает, что вы можете создавать файлы в директории; и флаг исполнения означает, что вы можете войти в директорию и обращаться ко всем поддиректориям внутри. Без флага исполнения у вас не будет доступа к объектам файловой системы внутри директории. Без флага чтения объекты файловой системы внутри директории нельзя просмотреть, но к объектам внутри директории все еще можно обратиться, если вы знаете полный путь к объекту на диске.

### Директории и флаг sgid

В случае же, если для директории установлен бит sgid, все объекты файловой системы, создаваемые внутри, наследуют группу директории. Эта возможность бывает кстати, когда вам необходимо создать дерево директорий и все они должны принадлежать одной группе. Это можно сделать вот так:

```
# mkdir /home/groupspace

# chgrp mygroup /home/groupspace

# chmod g+s /home/groupspace
```

Теперь любые пользователи группы mygroup могут создавать файлы и директории внутри /home/groupspace и им также будет автоматически задана принадлежность группе mygroup.

### umask

Когда процесс создает новый файл, он указывает, какие права доступа нужно задать для данного файла. Зачастую запрашиваются права 0666 (чтение и запись всеми), что дает больше разрешений, чем необходимо в большинстве случаев. К счастью, каждый раз, когда в Linux создается новый файл, система обращается к параметру, называемому umask. Система использует значение umask чтобы понизить изначально задаваемые разрешения на что-то более разумное и безопасное. Вы можете просмотреть текущие настройки umask набрав _umask_ в командной строке:

```
$ umask

0022
```

В Linux-системах значением по умолчанию для umask является 0022, что позволяет другим читать ваши новые файлы (если они могут до них добраться), но не изменять их. Чтобы автоматически обеспечивать больший уровень защищенности для создаваемых файлов, можно изменить настройки umask:

```
$ umask 0077
```

Такое значение umask приведет к тому, что группа и прочие не будут иметь совершенно никаких прав доступа для всех, вновь созданных файлов. Итак, как работает umask? В отличие от «обычного» назначения прав доступа к файлу, umask задает какие права доступа должны быть отключены. Снова посмотрим на таблицу соответствия значений чисел и методов:

**`Режим Число`**

```
rwx     7
rw-     6
r-x     5
r--     4
-wx     3
-w-     2
--x     1
---     0
```

Воспользовавшись этой таблицей мы видим, что последние три знака в 0077 обозначают ---rwxrwx. Теперь вспомните, что _umask_ показывает системе, какие права доступа отключить. Совместив первое и второе становится видно, что все права для группы и остальных пользователей будут отключены, в то время как права владельца останутся нетронутыми. В зависимости от настроек umask для данного пользователя новые объекты файловой системы могут быть или не быть читаемыми, изменяемыми или исполняемыми другими пользователями группы mygroup.

## Сервисы

### Что такое сервисы в Linux

Сервисы или службы — это программы, которые работают в системе Linux в фоновом режиме. Обычно они запускаются при загрузке системы. Большинство сервисов необходимы для полноценной работы системы, то есть они являются своего рода кирпичиками, из которых строится работающая система.

При запуске системы загружается целый ряд сервисов, которые включены для автозагрузки. Сервисы работают пока система запущена, и выгружаются при выключении системы.

Чаще всего в Linux дистрибутивах для инициализации сервисов используется демон Systemd. К Systemd-дистрибутивам относятся Ubuntu, Debian, Linux Mint, Fedora, openSUSE, Solus и другие.

Есть дистрибутивы, которые не используют Systemd. Вместо Systemd могут использоваться такие системы инициализации, как Upstart, SysV.

В качестве примеров сервисов можно привести: веб-сервер Apache, Network Manager, файрвол Ufw и другие.

**Apache** — это кроссплатформенное программное обеспечение для гибкой настройки надежных веб-серверов. На базе Apache строится огромное количество веб-сервисов и сайтов.

Этот инструмент для создания серверов очень популярен в мире за счет высокого уровня безопасности и обширного количества модулей, которые можно подключить, чтобы упростить управление веб-ресурсами.

Apache считается свободным программным обеспечением, поэтому разрабатывается и поддерживается сообществом, а не отдельной компанией. Соответственно, и распространяется он бесплатно.

**TELNET** — сетевой протокол для реализации текстового терминального интерфейса по сети (в современной форме — при помощи транспорта TCP). Название «telnet» имеют также некоторые утилиты, реализующие клиентскую часть протокола. Выполняет функции протокола прикладного уровня модели OSI. Протокол telnet использовался для удалённого администрирования различными сетевыми устройствами и программными серверами, но уступил ssh из-за безопасности. Тем не менее может являться единственной возможностью взаимодействовать через cli с embedded systems, например, router, т.к. на них отсутствует ssh.

**SSH** (Secure Shell) - это сетевой протокол, который обеспечивает безопасное удаленное соединение между двумя системами. Системные администраторы используют утилиты SSH для управления компьютерами, копирования или перемещения файлов между системами. Поскольку SSH передает данные по зашифрованным каналам, безопасность находится на высоком уровне.

**FTP** (англ. File Transfer Protocol) — протокол передачи файлов по сети, появившийся в 1971 году задолго до HTTP и даже до TCP/IP, благодаря чему является одним из старейших прикладных протоколов. Изначально FTP работал поверх протокола NC (nc - реализация подключений и ожиданий входящих соединений, через TCP и UDP), на сегодняшний день широко используется для распространения ПО и доступа к удалённым хостам. В отличие от TFTP, гарантирует передачу (либо выдачу ошибки) за счёт применения квотируемого протокола.Протокол построен на архитектуре «клиент-сервер» и использует разные сетевые соединения для передачи команд и данных между клиентом и сервером. Пользователи FTP могут пройти аутентификацию, передавая логин и пароль открытым текстом.

**Samba** — это программа, которая позволяет компьютерам UNIX/Linux имитировать машины Windows. При помощи Samba компьютеры могут обмениваться файлами или управлять заданиями на печать как файл-серверы или серверы печати под Windows. Подобно операционной системе UNIX/Linux, на которой она работает, Samba представляет собой разработанное множеством программистов ПО с открытым исходным кодом. Протокол SMB используется Microsoft Windows 2000, NT и 95/98 для организации доступа к дискам и принтерам.

**SFTP** протокол передачи файлов по SSH, или безопасный протокол передачи файлов, — это отдельный протокол, поддерживающий SSH, который работает схожим образом, но использует защищенное подключение. Его преимуществом является возможность использования защищенного подключения для передачи файлов и просмотра файловой системы как на локальной, так и на удаленной системе.Практически во всех случаях использование SFTP будет более предпочтительным по сравнению с FTP из-за имеющихся у первого функций безопасности и возможности использования подключения SSH. FTP — это небезопасный протокол, который следует использовать в отдельных случаях или в сетях, которым вы доверяете.

Теперь рассмотрим **управление сервисами**.

### **systemd**

`*systemd` -* это система инициализации и системный диспетчер. Позволяет запускать/останавливать службы, а также следить за их состоянием (это лишь часть функционала systemd, помимо этого утилита предоставляет пользователю широкий инструментарий для контроля и тонкой настройки работы служб).

Чтобы запустить тот или иной сервис, воспользуйтесь следующей командой:

```jsx
$ sudo systemctl start application.service
```

Вместо “application” укажите сервис, который вы хотите запустить.

Суффикс .service указывает на то, чтобы вы работаете со службой, однако systemd достаточно умна чтобы знать, что вы хотите работать со службой при использовании команд по управлению службами, следовательно его можно опустить.

В следующем примере демонстрируется остановка службы, обратите внимание что суффикс отсутсвтует:

```jsx
$ sudo systemctl stop application
```

Чтобы перезапустить работающую службу, можно использовать команду `restart`:

```
$ sudo systemctl restart application
```

Если данное приложение может перезагрузить файлы конфигурации (без перезапуска), вы можете выдать команду `reload` для инициализации этого процесса:

```
$ sudo systemctl reload application
```

Если вы не уверены, есть ли у службы функция перезагрузки своей конфигурации, можно использовать команду `reload-or-restart`. Это перезагрузит необходимую конфигурацию при наличии. В противном случае будет перезагружена служба для выбора новой конфигурации:

```jsx
$ sudo systemctl reload-or-restart application
```

Указанные выше команды полезны для запуска или остановки служб во время текущего сеанса. Чтобы дать команде `systemd` автоматически запускать службы при загрузке, их необходимо включить. Для запуска службы во время загрузки используйте команду `enable`:

```
$ sudo systemctl enable application
```

При этом будет создана символическая ссылка из системной копии служебного файла (обычно в `/lib/systemd/system` или `/etc/systemd/system`) в месте на диске, где `systemd` ищет файлы для автозапуска.

Чтобы отключить автоматический запуск службы, можно ввести следующее:

```
$ sudo systemctl disable application
```

При этом будет удалена символическая ссылка, что укажет на то, что служба не должна запускаться автоматически.

Помните, что включение службы не запустит ее в текущем сеансе. Если вы хотите запустить службу и включить ее при загрузке, необходимо дать обе команды, `start` и `enable`.

### Проверка статуса служб

Чтобы проверить статус службы в вашей системе, можно использовать команду `status`:

```
$ systemctl status application.service
```

При этом вы получите статус службы, иерархию контрольных групп и первые несколько строк журнала.

Например, при проверке статуса сервера Nginx вы можете видеть следующий вывод:

```
Output
● nginx.service - A high performance web server and a reverse proxy server
   Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled)
   Active: active (running) since Tue 2015-01-27 19:41:23 EST; 22h ago
 Main PID: 495 (nginx)
   CGroup: /system.slice/nginx.service
           ├─495 nginx: master process /usr/bin/nginx -g pid /run/nginx.pid; error_log stderr;
           └─496 nginx: worker process
Jan 27 19:41:23 desktop systemd[1]: Starting A high performance web server and a reverse proxy server...
Jan 27 19:41:23 desktop systemd[1]: Started A high performance web server and a reverse proxy server.

```

Это дает вам хороший обзор текущего статуса приложения и уведомляет о наличии каких-либо проблем или необходимости выполнения каких-либо действий.

### Обзор состояния системы

Команды до сих пор были полезны для управления отдельными службами, но они не очень подходят для понимания текущего состояния системы. Существует ряд команд `systemctl`, предоставляющих эту информацию.

Чтобы увидеть список всех активных модулей, о которых знает `systemd`, можно использовать команду `list-units`:

```
$ systemctl list-units
```

Это покажет вам список всех модулей, которые у `systemd` активны в системе. Результат будет выглядеть примерно так:

```
Output
UNIT                                      LOAD   ACTIVE SUB     DESCRIPTION
atd.service                               loaded active running ATD daemon
avahi-daemon.service                      loaded active running Avahi mDNS/DNS-SD Stack
dbus.service                              loaded active running D-Bus System Message Bus
dcron.service                             loaded active running Periodic Command Scheduler
dkms.service                              loaded active exited  Dynamic Kernel Modules System
getty@tty1.service                        loaded active running Getty on tty1
. . .

```

Вывод содержит следующие столбцы:

- **UNIT**: имя модуля `systemd`
- **LOAD**: указывает на то, парсила ли `systemd` конфигурацию модуля. Конфигурация загруженных модулей сохраняется в памяти.
- **ACTIVE**: краткое состояние активности модуля. Обычно это довольно стандартный способ сообщить, запущен модуль или нет.
- **SUB**: это состояние более низкого уровня, которое указывает более подробную информацию о модуле. Это часто зависит от типа модуля, состояния и фактического метода работы модуля.
- **DESCRIPTION**: краткое текстовое описание того, чем является модуль/что делает.

Поскольку команда `list-units` показывает по умолчанию только активные модули, для всех вводов выше отобразится `loaded` в столбце LOAD и `active` в столбце ACTIVE. Это отображение фактически является поведением по умолчанию `systemctl` при вызове без дополнительных команд, поэтому вы увидите то же, что и при вызове `systemctl` без аргументов.

### Команда **service**

Вы также можете использовать другой способ мониторинга служб Linux - команду service. Однако systemctl является основным инструментом в инструменте управления сервисами и содержит в себе функцию service, другими словами принципиальной разницы в вышеописанных способах нет, это лишь разные обращения к одному и тому же инструменту. Тем не менее Вы должны владеть разными подходами, поэтому ниже представлены основные варианты использования команды service на примере работы с некоторыми распространеннными сервисами.

Чтобы посмотреть какие сервисы у нас работают, необходимо ввести команду

`service --status-all`

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/40d1215d-802e-4d4a-90fa-2d5e984835ab/Untitled.png)

**Мониторинг Apache с помощью service**

Прежде всего установим Apache:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/f502c7f0-2cff-489e-be77-4752be9fb276/Untitled.png)

Просмотр статуса:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/6b6db986-12bd-4dff-9083-e94f37b64119/Untitled.png)

Как видим, в данный момент сервис не активен, следует его запустить:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/2512da15-c682-4d83-a2f3-0b32d40d2941/Untitled.png)

Снова проверим статус:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/722a4a9f-1881-4a8e-acc1-6ff4c200c745/Untitled.png)

Отлично, Apache присвоен статус _active._ Давайте убедимся в этом, зайдя на старницу сервиса в браузере. Для этого перейдем по адресу 127.0.0.1 (это так называемый локальный адрес):

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/6fd23ceb-8c5c-4413-a536-0b1498ff1b54/Untitled.png)

Такая страница свидетельствует о том, что мы всё сделали правильно.

Теперь давайте отключим web-сервер и посмотрим какой вывод нам даст браузер:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/0ab8f723-c4b4-486b-8014-b98a346deaa2/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/47ded24c-a1a9-4df6-bf61-23488023f019/Untitled.png)

**Мониторинг Telnet с помощью service**

Если данный сервис не установлен, то делаем следующее:

```html
$ sudo apt-get install telnet
```

У Telnet есть несколько режимов работы:

- Режим «Тестирование». Клиентская машина обрабатывает только текст, без загрузки графики. Например, введём в терминале: **telnet [opennet.ru](http://opennet.ru/) 80.** Утилита отправит запрос сайту [opennet.ru](http://opennet.ru/) на порт под номером 80. Далее вводим ключ: GET / для показа кода страницы. Результат представится в виде текстового сообщения с нечитаемыми символами, поскольку утилита не работает с русскими шрифтами

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/1b0bbf95-e11a-4cc7-adf1-2d37683a2699/Untitled.png)

С помощью telnet можно узнать есть ли на хосте ssh сервер:

```html
$ telnet -d ip-адрес 22
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/70c53b9b-eaf3-4dc4-be66-e2c51a9fc8e0/Untitled.png)

Вуаля, мы зашли на удаленный сервер (подробнее работа с удаленными хостами будет рассмотрена несколько позже).

_**ОБРАТИТЕ ВНИМАНИЕ, TELNET - ПРОТОКОЛ БЕЗ ШИФРОВАНИЯ, ИСПОЛЬЗУЙТЕ ЕГО С ОСТОРОЖНОСТЬЮ**_

**SSH** (англ. Secure SHell — «безопасная оболочка») – протокол передачи данных, позволяющий производить безопасное и защищенное управление операционной системой и данными. Это сетевой протокол прикладного уровня, который дает возможность шифрования передаваемых данных и паролей. К тому же позволяет передавать любой другой протокол. Первая версия протокола SSH была разработана аж в 1995 году. С тех пор были обнаружены некоторые слабые места и программа претерпела ряд существенных изменений. Таким образом, уже через год, в 1996 году, в свет вышла вторая версия SSH – 2. Она не совместима с первой версией и, говоря о SSH сегодня, всегда подразумевается SSH – 2. С тех пор SSH не изменила значительно стандарты своей работы и широко используется по сей день. SSH является сугубо коммерческим продуктом и предоставляется на платной основе. Однако повсеместно доступна и ее бесплатная версия, которая носит название OpenSSH. Не смотря на то, что OpenSSH является лишь одной из версий SSH, она намного чаще используется программистами.

Установка:

```html
$ sudo apt-get install openssh-server
```

Основные команды управления службой:

- sudo service ssh restart
- sudo service ssh stop
- sudo service ssh start

Подробнее мы вернемся к этому протоколу ниже в разделе Удаленное Администрирование Linux.

## Мониторинг системы

Отслеживание состояние системы и запущенных процессов - важная часть администрирования Linux. В обязанности администратора входит отслеживать различные параметры работы сервера Linux, нагрузку на процессор, диск, доступное дисковое пространство и оперативную память.

---

### **htop**

Продвинутый монитор процессов, написанный для Linux. Он был задуман заменить стандартную программу top. Htop показывает динамический список системных процессов, список обычно выравнивается по использованию ЦПУ. В отличие от top, htop показывает все процессы в системе. Также показывает время непрерывной работы, использование процессоров и памяти.

Установка:

```jsx
$ sudo apt-get install htop
```

Запускаем:

```jsx
$ sudo htop
```

Вывод:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/71d334a2-b948-4647-aef6-589a0d2e9390/Untitled.png)

Расшифровка:

**PID** - идентификатор процесса.

**USER** - владелец процесса.

**PRI** - текуший приоритет (влияет на процессорное время, отводимое процессу, значение по умолчанию - 20; чем меньше приоритет, тем больше времени отводится процессу, следовательно он выполняется быстрее).

**NI** - величина изменения приоритета относительно значения PRI (клавиши F7, F8).

**VIRT** - общий объем виртуальной памяти, используемой процессом. Включает в себя: область кода (CODE), данные (DATA), разделяемые библиотеки (SHARED) и страницы, перемещенные в swap-область памяти. Если  
приложение потребовало от ядра выделить ему 100Мб памяти, а  
использует всего 5 Мб, данный столбец всё равно будет показывать цифру 100.

**CODE** - объем памяти, содержащий исполняемый код процесса.

**DATA** - объем памяти, занятой данными, используемыми процессом в ходе выполнения.

**SWAP** - объем памяти, используемой процессом, но перемещенной в swap-область.**)**

**RES** - количество резидентной (не перемещаемой в swap) памяти в килобайтах. Если приложение потребовало от ядра выделить ему 100Мб памяти, а  
использует всего 5 Мб, то данный столбец покажет 5. Но здесь есть два ньюанса: а) RES не показывает сколько данных было перемещено в swap, б) часть RES-памяти может быть разделяемой.

**SHR** - количество разделяемой (shared) памяти программы в килобайтах,  
т.е. памяти, которая может быть использована другими приложениями.

**S** - состояние процесса:

**S** — так называемое состояние сна;

**R** — состояние выполнения;

**D** — состояние ожидания.

**CPU%** - использование процессора в процентном отношении.

**MEM%** - использование процессом памяти в процентном отношении.

**TIME+** - время работы процесса.

**Command** - указывает на команду, которой был запущен процесс.Через настройки (F2) можно добавить еще некоторые полезные параметры:

**IO RATE** - Операции ввода\вывода. Чтение + запись. Если нужно отдельно на чтение и на запись, то можно добавить: **IO READ RATE** и **IO WRITE RATE**.

Также на экран выводятся следующие параметры:

**Load average** - отражает число блокирующих процессов в очереди на исполнение в определенный временной интервал, а именно 1 минута, 5 минут и 15 минут, соответственно. Блокирующий процесс — это процесс, который ожидает ресурсов для продолжения работы.

**Uptime** - время работы системы.

### Управление:

**F1** - справка; **F2** - настройки; **F3** - поиск процесса; **F4** - сортировка списка процессов (от большего к меньшему или от меньшего к большему); **F5** - устанавливает древовидное отображение (корни - родительские процессы, а листья - дочерние) и наоборот; **F6** - открывает панель с выбором параметра сортировки процессов; **F7** - увеличить приоритет выполнения текущего процесса; **F8** - уменьшить приоритет выполнения текущего процесса; **F9** - убить процесс; **F10** - выйти из программы.

---

### Free

Вы можете использовать команду `free` для получения подробного отчета об использовании памяти системой.

Команда `free` предоставляет информацию об общем объеме физической и подкачки памяти, а также о свободной и используемой памяти и пространстве подкачки в системе.

При выполнении без каких либо опций вывод будет включать три строки, заголовок, одну строку для памяти и одну для подкачки:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/9ec399e3-365b-4717-af82-9a4712e6349e/Untitled.png)

Вот что означает каждый столбец:

- **total** - это число представляет собой общий объем памяти, который может использоваться приложениями.
- **used** - использованная память Он рассчитывается как: `used = total - free - buffers - cache`
- **free** - Свободная / Неиспользуемая память.
- **shared** - этот столбец можно игнорировать, так как он не имеет смысла. Это здесь только для обратной совместимости.
- **buff / cache** - объединенная память, используемая буферами ядра, кешем страниц и слэбами. Эта память может быть восстановлена в любое время, если это необходимо приложениям. Если вы хотите, чтобы буферы и кеш отображались в двух отдельных столбцах, используйте эту `w` опцию.
- **available** - оценка объема памяти, доступной для запуска новых приложений без замены.

Для вывода более удобочитаемых значений (обычно мегабайты и гигабайты) воспользуйтесь опцией -h

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/cc3afff4-4100-4f9a-9177-49227f050626/Untitled.png)

---

## Аудит безопасности (auditd)

В дистрибутивах Linux предусмотрена утилита для сбора системных событий и анализа полученных данных. Имя ей - **auditd.**

Auditd (сокращение от Linux Audit Daemon) — нативный инструмент предназначенный для мониторинга событий операционной системы и записи их в журналы событий. Был создан для тесного взаимодействия с ядром операционной системы — во время своей работы наблюдает за системными вызовами и может записывать события — чтение, запись, выполнение, изменение прав - связанные с файлами ОС. Таким образом, с его помощью можно отслеживать практически любые события, происходящие в операционной системе.

Установка:

`$ sudo apt-get install auditd`

Файлы конфигурации хранятся в /etc/audit/auditd.conf. Правила желательно хранить в /etc/audit/rules.d/*.rules, по умолчанию доступ к этой директории только у root'а. Обратите внимание на то, что файл с правилами в этой директории должен иметь название *.rules, иначе auditd не прочитает его без явного указания. Если вы решили хранить правила в другом месте, то владелец файла должен быть root. Помимо этого рекомендую выставить группу файла root и права 600, чтобы никто кроме root'а не мог работать с файлом конфигурации auditd, т.к. зная что логируется, атакующий может избежать обнаружения. То же самое касается и файлов с правилами для других инструментов.

Конфигурационный файл содержит следующие параметры:

- log_file — файл, в котором будут храниться логи подсистемы аудита;
- log_format — формат, в котором будет сохранены логи;
- freq — максимальное число записей протокола, которые могут храниться в буфере;
- flush — режим синхронизации буфера с диском (none — ничего не делать, incremental — переносить данные из буфера на диск с частотой, указанной в значении параметра freq; data — синхронизировать немедленно, sync — синхронизировать как данные, так и метаданные файла при записи на диск);
- max_log_file — максимальный размер файла лога в мегабайтах;
- max_log_file_action — действие при превышении максимального размера файла лога;
- space_left — минимум свободного пространства в мегабайтах, по достижении которого должно быть осуществлено действие, указанное в следующем параметре;
- space_left_admin — указывает, что делать, когда на диске недостаточно свободного места (ignore — ничего не делать; syslog — отправлять в syslog, email — отправлять уведомление по почте; suspend — прекратить запись логов на диск; single — перейти в однопользовательский режим; halt — выключить машину)
- disk_full_action — действие, которое нужно осуществить при переполнении диска (этот параметр может принимать те же значения, что и space_left_admin).

## Создание правил

Для добавления и настройки правил используется команда auditctl. Вот список её опций:

- l — вывести список имеющихся правил;
- а — добавить новое правило;
- d — удалить правило из списка;
- D — удалить все имеющиеся правила.

Чтобы создать новое правило, нужно выполнить команду вида:

```
$ auditctl -a <список>, <действие> -S <имя системного вызова> -F <фильтры>
```

Сначала после опции -а указывается список, в который нужно добавить правило. Всего существует 5 таких списков:

- task — события, связанные с созданием новых процессов;
- entry — события, которые имеют место при входе в системный вызов;
- exit — события, которые имеют место при выходе из системного вызова;
- user — события, использующие параметры пользовательского пространства;
- exclude — используется для исключения событий.

Затем указывается, что нужно делать после наступления события. Здесь возможны два варианта: always (события будут записываться в журнал) и never (не будут).

После опции -S идёт имя системного вызова, при котором событие нужно перехватить (open, close и т.п.).

После опции -F указываются дополнительные параметры фильтрации. Например, если нам требуется вести аудит обращений к файлам из каталога /etc, правило будет выглядеть так:

```
$ auditctl -a exit,always -S open -F path =/etc/
```

Можно установить и дополнительный фильтр:

```
$ auditctl -a exit,always -S open -F path =/etc/ -F perm = aw
```

Аббревиатура aw означает следующее: а — изменение атрибута (attribute change), w — запись (write). Формулировка perm = aw указывает, что для директории /etc нужно отслеживать все факты изменения атрибутов (а — attribute change) и w (w — write).

При настройке слежения за отдельными файлами можно опустить опцию -S, например:

```
$ auditctl -a exit,always -F path =/etc/ -F perm = aw
```

## Файлы правил

Правила можно не только задавать через командную строку, но и прописывать в файле etc/audit/audit.rules.

Начинается этот файл с так называемых метаправил, в которых задаются общие настройки журналирования:

```
# удаляем все ранее созданные правила
-D

# задаём количество буферов, в которых будут храниться сообщения
-b 320

# указываем, что делать в критической ситуации (например, при переполнении буферов):
0 - ничего не делать; 1 - отправлять сообщение в dmesg, 2 -  отправлять ядро в панику
-f 1
```

Далее следуют пользовательские правила. Их синтаксис предельно прост: достаточно просто перечислить соответствующие опции команды auditctl. Рассмотрим пример типового файла правил:

```
# отслеживать системные вызовы unlink () и rmdir()
-a exit,always -S unlink -S rmdir

# отслеживать системные вызовы open () от пользователя с UID 1001
-a exit,always -S open -F loginuid=1001

# отслеживать доступ к файлам паролей и групп и попытки их изменения:
-w /etc/group -p wa
-w /etc/passwd -p wa
-w /etc/shadow -p wa
-w /etc/sudoers -p wa

# отслеживать доступ к следующей директории:
-w /etc/my_directory -p r

# закрыть доступ к конфигурационному файлу для предотвращения изменений
-e 2

```

Изменения конфигурации вступят в силу после перезапуска демона auditd:

```
$ sudo service auditd restart

```

## Анализ журнальных файлов: утилита aureport

Все журнальные файлы сохраняются в директории /var/log/audit в машиночитаемом формате. Их можно сделать человекопонятными c помощью утилиты aureport.

Если ввести команду aureport без аргументов, мы увидим общую системную статистику (количество пользователей системы, общее количество системных вызовов, число открытых терминалов и т.п.):

```
$ sudo aureport

Summary Report
======================
Range of time in logs: 07/31/2015 14:04:23.870 - 08/04/2015 09:37:13.200
Selected time for report: 07/31/2015 14:04:23 - 08/04/2015 09:37:13.200
Number of changes in configuration: 0
Number of changes to accounts, groups, or roles: 3
Number of logins: 0
Number of failed logins: 0
Number of authentications: 0
Number of failed authentications: 61205
Number of users: 2
Number of terminals: 5
Number of host names: 73
Number of executables: 6
Number of files: 0
Number of AVC's: 0
Number of MAC events: 0
Number of failed syscalls: 0
Number of anomaly events: 0
Number of responses to anomaly events: 0
Number of crypto events: 0
Number of keys: 0
Number of process IDs: 17858
Number of events: 61870
```

Она не имеет особой практической ценности. Гораздо больший интерес представляют специализированные отчёты. Вот так, например, можно просмотреть информацию обо всех системных вызовах:

```
$ sudo aureport -s

Syscall Report
=======================================
# date time syscall pid comm auid event
=======================================
1. 08/03/2015 15:45:03 313 10285 modprobe -1 52501
2. 08/03/2015 15:45:03 313 10290 modprobe -1 52502
3. 08/03/2015 15:45:03 54 10296 iptables -1 52503
4. 08/03/2015 15:45:03 54 10302 iptables -1 52504
5. 08/03/2015 15:45:03 54 10305 iptables -1 52505
6. 08/03/2015 15:45:03 54 10313 iptables -1 52506
7. 08/03/2015 15:45:03 54 10325 iptables -1 52507
8. 08/03/2015 15:45:03 54 10329 iptables -1 52508
9. 08/03/2015 15:45:03 54 10343 iptables -1 52509
10.08/03/2015 15:45:03 54 10345 iptables -1 52510
11.08/03/2015 15:45:03 54 10349 iptables -1 52511

```

Воспользовавшись опцией -au (или −−auth), можно просмотреть информацию обо всех попытках входа в систему:

```
$ sudo aureport -au

Authentication Report
============================================
# date time acct host term exe success event
============================================
1. 08/31/2015 18:00:19 ubnt static-166-6-249-80.stalowa.pilicka.pl ssh /usr/sbin/sshd no 333
2. 08/31/2015 18:01:38 root 59.63.188.31 ssh /usr/sbin/sshd no 334
3. 08/31/2015 18:01:41 root 59.63.188.31 ssh /usr/sbin/sshd no 335
4. 08/31/2015 18:01:45 root 59.63.188.31 ssh /usr/sbin/sshd no 336
5. 08/31/2015 18:01:53 root 59.63.188.31 ssh /usr/sbin/sshd no 337
6. 08/31/2015 18:01:57 root 59.63.188.31 ssh /usr/sbin/sshd no 338
7. 08/31/2015 18:01:59 root 59.63.188.31 ssh /usr/sbin/sshd no 339

```

В аureport поддерживается фильтрация по дате и времени:

```
$ sudo aureport -s --start 07/31/15 12:00 --end 07/31/15 13:00
```

Можно указывать как конкретные время и дату, так и специальные человекопонятные конструкции:

- now — текущий момент;
- yesterday — вчерашнее сутки;
- recent — 10 минут назад;
- this-week (или this-month, this-year) — текущая неделя (месяц, год).

С помощью aureport можно просмотреть информацию о действиях любого пользователя системы. Для этого нужно сначала узнать id этого пользователя:

```
$ id user
uid=1000(user) gid=1000(andrei) groups=1000(andrei),27(sudo)

```

и затем выполнить следующую команду:

```
$ sudo ausearch -ui 1000 --interpret

```

## Ausearch: поиск и анализ событий

Для просмотра детальной информации о событии используется утилита ausearch:

```
$ sudo ausearch -a <номер события>

```

Вывод приведённой выше команды выглядит так:

```
type=SYSCALL msg=audit(1364481363.243:24287): arch=c000003e
syscall=2 success=no exit=-13 a0=7fffd19c5592 a1=0 a2=7fffd19c4b50 a3=a
items=1 ppid=2686 pid=3538 auid=500 uid=500 gid=500 euid=500 suid=500
fsuid=500 egid=500 sgid=500 fsgid=500 tty=pts0 ses=1 comm="cat"
exe="/bin/cat"
subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
key="sshd_config"

```

Рассмотрим его структуру более подробно. В поле type указывается тип записи; type = syscall означает, что запись была сделана после выполнения системного вызова. В поле msg указано время события в формате Unix Timestamp и его уникальный идентификационный номер.

В поле arch содержится информация об используемой архитектуре системы (c000003e означает x86_84), представленная в закодированном шестнадцатеричном формате. Чтобы она выводилась в человекочитаемом виде, можно воспользоваться опцией -i или −−interpret.

В поле syscall указан тип системного вызова — в нашем случае это 2, то есть вызов open. Параметр success сообщает, был ли вызов обработан успешно или нет. В нашем примере вызов был обработан неудачно (success = no). Вывести на консоль информацию о любом параметре в человекочитаемой форме можно получить при помощи упомянутой выше опции -i или −−interpret, например:

```
$ sudo ausearch --interpet --exit  -13
```

Опция -sc позволяет включать в список события, относящиеся к указанному системному вызову, например:

```
$ sudo ausearch -sc ptrace
```

Опция -ui служит для поиска событий по идентификатору пользователя:

```
$ ausearch -ui 33
```

Поиск по именам демонов осуществляется с помощью опции -tm:

```
$ ausearch -x -tm cron
```

Для поиска нужных событий можно также использовать ключи, например:

```
$ sudo auditctl -k root-actions
```

Приведённая команда выведет список всех действий, совершённых от имени root-пользователя. Поддерживается также фильтрация по дате и времени, аналогичная той, что была описана выше. Вывести список событий, завершившихся неудачно, можно с помощью опции −−failed.

## Анализ процессов с помощью утилиты autrace

В некоторых случаях бывает полезным получить информацию о событиях, связанных с одним конкретным процессом. Для этой цели можно воспользоваться утилитой autrace. Предположим, нам нужно отследить процесс date и узнать, какие системные вызовы и файлы он использует. Выполним команду:

```
$ sudo autrace /bin/date
```

На консоли появится следующий текст:

```
Waiting to execute: /bin/date
Mon Aug 31 17:06:32 MSK 2015
Cleaning up...
Trace complete. You can locate the records with 'ausearch -i -p 29234'
```

Обратим внимание на последнюю строку вывода: в ней указана команда, с помощью которой можно получить более подробную информацию. Выполним эту команду и передадим вывод утилите aureport, которая преобразует его в человекочитаемый формат:

```
$ sudo ausearch -p 29215 --raw | aureport -f -i
```

В результате мы получим вот такой отчёт:

```
File Report
===============================================
# date time file syscall success exe auid event
===============================================
1. 08/31/2015 16:52:16 /bin/date execve yes /bin/date root 25
2. 08/31/2015 16:52:16 /etc/ld.so.nohwcap access no /bin/date root 27
3. 08/31/2015 16:52:16 /etc/ld.so.preload access no /bin/date root 29
4. 08/31/2015 16:52:16 /etc/ld.so.cache open yes /bin/date root 30
5. 08/31/2015 16:52:16 /etc/ld.so.nohwcap access no /bin/date root 34
6. 08/31/2015 16:52:16 /lib/x86_64-linux-gnu/libc.so.6 open yes /bin/date root 35
7. 08/31/2015 16:52:16 /usr/lib/locale/locale-archive open yes /bin/date root 52
8. 08/31/2015 16:52:16 /etc/localtime open yes /bin/date root 56

```

## Централизованное хранение логов

Для отправки логов подсистемы аудита в централизованное хранилище используется плагин audisp-remote. Он входит в пакет audisp-plugins, который нужно устанавливать дополнительно:

```
$ sudo apt-get install audisp-plugins
```

Конфигурационные файлы всех плагинов хранятся в директории /etc/audisp/plugins.d.

Настройки удалённого логгирования прописываются в конфигурационном файле /etc/audisp/plugins.d/audisp-remote.conf. По умолчанию этот файл выглядит так:

```
active = no
direction = out
path = /sbin/audisp-remote
type = always
#args =
format = string
```

Чтобы активировать отправку логов в удалённое хранилище, заменим значение параметра active на yes. Затем откроем файл etc/audisp/audisp-remote.conf и в качестве значения параметра remote_server укажем буквенный или IP-адрес cервера, на котором будут храниться логи.

Чтобы принимать логи с удалённых хостов и сохранять их на сервере, в файле /etc/audit/auditd.conf нужно прописать следующие параметры:

```
tcp_listen_port = 60

tcp_listen_queue = 5

tcp_max_per_addr = 1

##tcp_client_ports = 1024-65535 #optional

tcp_client_max_idle = 0
```

---

## Работа с менеджерами пакетов

Ранее мы неоднократно устанавливали те или иные утилиты (скачивая их пакеты), однако не рассматривали команду, которой для этого пользовались - apt. APT - один из самых распространенных менеджеров пакетов. Менеджер пакетов - программа, выполняющая установку, удаление или обновление любого пакета или группы пакетов, и автомитически выполняющая все необходимые для этого процедуры (доставку пакетов из удалённых репозиториев, вычисление зависимостей и установку требуемых по ним пакетов, удаление замещаемых пакетов и т. п.).

### Категории пакетных менеджеров

- **Высокоуровневые менеджеры.** Применяются для поиска и скачивания пакетов из репозиториев. В процессе работы могут задействовать низкоуровневые менеджеры для инсталляции загруженных программ.
- **Низкоуровневые менеджеры.** Используются для установки локальных пакетов, загруженных вручную пользователем, или высокоуровневым пакетным менеджером.

### Распространенные форматы пакетов

- **DEB (.deb)**. Самый популярный формат пакетов дистрибутива Debian и его ближайших родственников — Ubuntu, MX Linux, Pop!_OS, elementary OS и других.
- **RPM (.rpm)**. Разработан компанией Red Hat и внедрен в дистрибутив RHEL. Также применяется в таких системах как Fedora и CentOS.
- **PKG.TAR.XZ**. Стандартный тип пакетов для дистрибутива ArchLinux и его производных — Manjaro, ARCOLINUX и других.
- **Ebuild (.ebuild).** Скрипт bash-сценария для компиляции программ в дистрибутивах Gentoo и Calculate Linux.

Для корректного функционирования пакетных менеджеров необходимо корректное отслеживание пакетных зависимостей. Зависимости – список дополнительных пакетов и библиотек, участвующие в работе программы. Во время установки приложения пакетный менеджер или компилятор считывают специальный файл со списком зависимостей, а после проверяют их наличие в системе.

Если важная зависимость будет не удовлетворена при установке программы низкоуровневым менеджером, то будет выдана ошибка с названием отсутствующего пакета. В подобной ситуации проблема решается отдельной установкой недостающего пакета.

При использовании высокоуровнего пакетного менеджера для установки программы, зависимые пакеты будут установлены в автоматическом режиме, без вмешательства пользователя.

Самые распростанённые пакетные менеджеры:

### APT

APT (Advanced Packaging Tool) – консольная утилита, выполняющая роль «поисковика» и загрузчика пакетов из репозиториев. Установка скачанных пакетов производится утилитой DPKG. Благодаря эффективному разрешению зависимостей, пакетный менеджер APT используется по умолчанию в дистрибутивах с архитектурой Debian и поддерживает систему в актуальном состоянии.

Синтаксис команды apt следующий:

```
$ sudo apt <действие> <пакет(ы)> <доп. параметры>
```

С примением apt install вы уже хорошо знакомы, эта команда позволяет скачать и установить тот или иной пакет. Однако у apt есть и другие применения:

```
$ sudo apt update
```

У APT есть список репозиториев, из которых происходит установка пакетов. Список хранится в текстовом файле _/etc/apt/sources.list_, а также в директории _/etc/apt/sources.list.d/_. При выполнении команды _apt update_, APT проходит по списку репозиториев и из каждого репозитория в списке получает информацию о пакетах, находящихся в репозитории. Вся эта информация сохраняется в системе.

Если выходит новая версия какого-нибудь пакета, то APT не узнает об этом, пока не будет выполнена команда _apt update_. Поэтому, если установить данный пакет (не выполнив предварительно apt update), то будет установлена та версия пакета, информация о которой хранится в системе в данный момент.

Чтобы выполнить обновление пакетов, установленных в системе, используется команда:

```
$ sudo apt upgrade
```

Данная команда только обновляет пакеты до новых версий, но никогда не удаляет и не устанавливает другие пакеты.

Есть еще одна команда для **обновления** пакетов:

```
$ sudo apt full-upgrade
```

Данная команда выполняет обновление пакетов, а также удаляет или устанавливает новые пакеты, если это потребуется для разрешения зависимостей.

Чтобы **установить** пакет используется команда:

```
$ sudo apt install <пакет>
```

Для **установки нескольких** пакетов их имена записываются через пробел:

```
$ sudo apt install <пакет1> <пакет2> <пакет3>
```

Чтобы установить **определенную версию** пакета нужно после названия пакета, через знак равенства, указать требуемую версию:

```
$ sudo apt install <пакет>=<версия>
```

Для **удаления**, установленного пакета, используется команда:

```
$ sudo apt remove <пакет>
```

Удалить пакет и его конфигурационные файлы:

```
$ sudo apt purge <пакет>
```

_apt purge_ работает аналогично _apt remove_, но удаляет еще и конфигурационные файлы, относящиеся к пакету. Это означает, что если вы установили какую-нибудь программу, настроили ее, а потом удалили командой _apt remove_, то конфигурационный файл этой программы останется в системе. Если вы теперь установите эту программу снова, то можно будет использовать предыдущий конфигурационный файл, так как он не был удален.

_apt purge_ не удаляет конфигурационные файлы, хранящиеся в вашей домашней директории.

Если вы удалили пакет командой _apt remove_, то вы можете выполнить _apt purge_ для данного, уже удаленного пакета, чтобы «доудалить» его конфигурационные файлы.

Удалить неиспользуемые пакеты

```
$sudo apt autoremove
```

Когда вы устанавливаете пакет, то часто устанавливаются дополнительные пакеты, являющиеся его зависимостями. Если теперь вы удалите этот пакет, то зависимости останутся в системе. _apt autoremove_ удаляет эти зависимости, но только те, которые не нужны другим установленным пакетам.

### Список пакетов

Команда apt list используется для вывода списка пакетов по какому-то критерию.

Вывести список установленных в системе пакетов:

```
$ apt list --installed
```

Вывести список пакетов, которые требуют обновления (у которых вышла новая версия):

```
$ apt list --upgradable
```

Вывести список всех пакетов доступных для вашей системы:

```
$ apt list --all-versions
```

Если Вас интересует количество установленных пакетов, то его Вам выведет следующая команда:

```html
$ apt list --installed | wc -l
```

**Поиск** пакетов:

```
$ apt search <слово>
```

Данная команда выполняет поиск указанного _слова_ в названии пакетов и в описании пакетов. Поддерживаются регулярные выражения.

Можно выполнять поиск только по названиям пакетов для этого используется опция --names-only:

```
$ apt search --names-only <слово>
```

Поиск пакета с использованием регулярных выражений:

```
$ apt search --names-only '^python'
```

**Информация** о пакете:

```
$ apt show <пакет>
```

Выводит информацию о пакете. Отображается версия, размер, описание, зависимости и другая информация.

Редактирование списка репозиториев:

```
$ sudo apt edit-sources
```

Открывает файл _/etc/apt/sources.list_ в текстовом редакторе для редактирования, после сохранения изменений и закрытия редактора, выполняет проверку файла на предмет ошибок. В случае наличия ошибок, выводит предложение на повторное редактирование файла, чтобы исправить ошибки.

Вы могли заметить, что ранее помимо apt мы пользовались также утилитой apt-get, и может возникнуть резонный вопрос - в чем разница?

Apt это утилита, которая появилась, как альтернатива apt-get. Она выполняет практически все те же функции, что и apt-get, но с ней проще и понятнее работать.

Например, все команды apt имеют простой синтаксис: _apt название_команды_. А у apt-get есть дополнительные команды, например, _apt-cache_. Таким образом, при использовании apt, пользователю не нужно запоминать дополнительные наборы команд.

Помимо упрощения работы с командами, apt нагляднее выводит информацию, вроде бы мелочи, но работать удобнее. Например, apt умеет показывать прогресс бар, а при выполнении _apt update_ можно увидеть сколько пакетов можно обновить.

Стоит отметить, что утилита apt-get более функциональна, чем apt.

### **dpkg**

DPKG (Debian Package) – система управления пакетами в Debian и дистрибутивах на его основе, например Ubuntu. Утилита DPKG появилась в дистрибутиве Debian в 1995 году. Низкоуровневый пакетный менеджер создан только для работы с локальными DEB пакетами и не может самостоятельно разрешать зависимости, а также скачивать пакеты из репозиториев

- Для получения списка пакетов, установленных в системе, в терминале наберите:

```
$ dpkg -l
```

- В зависимости от количества пакетов в вашей системе, эта команда может породить большой объем вывода. Пропустите выходной поток через `grep` чтобы увидеть установлен ли определенный пакет:

```
$ dpkg -l | grep apache2
```

Замените `apache2` на любое имя пакета, часть имени или иное регулярное выражение.

- Для получения списка файлов, установленных пакетом (в нашем случае ufw), введите:

```
$ dpkg -L ufw
```

- Если вы не уверены каким пакетом установлен файл, dpkg -S может подсказать вам. Например:

```
$ dpkg -S /etc/host.conf
base-files: /etc/host.conf
```

Вывод указывает, что /etc/host.conf принадлежит пакету base-files.

Многие файлы автоматически создаются в процессе установки пакета, но несмотря на то, что они находятся на файловой системе, dpkg -S может не знать какому пакету они принадлежат.

- Вы можете установить локальный .deb файл, набрав:

```
$ sudo dpkg -i zip_3.0-4_i386.deb
```

Замените zip_3.0-4_i386.deb на реальное имя локального .deb файла, который вы собираетесь установить.

- Удаление пакета может быть выполнено так:

```
$ sudo dpkg -r zip
```

Удаление пакетов с использованием dpkg в большинстве случаев не рекомендуется. Лучше использовать менеджер пакетов, отслеживающий зависимости, чтобы гарантировать, что система находится в связанном состоянии. Например, использование dpkg -r zip удалит пакет zip, однако любые пакеты, зависящие от него, останутся установленными и более не смогут работать правильно.

Для дополнительной информации смотрите страницу описания:

```
$ man dpkg
```

### **RPM**

**RPM (Red Hat Package Manager)** - это популярная утилита управления пакетами для Linux систем на базе Red Hat, таких как (RHEL, CentOS и Fedora). Она используется для установки, удаления, обновления, запроса и проверки пакетов программного обеспечения. Пакет состоит из архива файлов и информации о пакете, включая имя, версию и описание. Формат файлов также называется RPM.

В RPM используется несколько основных режимов команд:

**Install** (используется для установки любого пакета RPM),

**Remove** (используется для удаления, стирания или деинсталляции пакета),

**Upgrade** (используется для обновления существующего пакета),

**Query** (используется для запроса пакета),

**Verify** (используется для проверки пакетов RPM).

Применение:

установить RPM пакет:

`$ sudo rpm -ivh GeoIP-1.5.0-11.el7.x86_64.rpm`

проверить установленный пакет RPM:

`$ sudo rpm -q GeoIP`

вывести список всех файлов для определенного установленного пакета RPM:

`$ sudo rpm -ql GeoIP`

вывести список недавно установленных пакетов RPM:

`$ sudo rpm -qa --last`

установить RPM пакет без зависимостей:

`$ sudo rpm -ivh --nodeps GeoIP-1.5.0-11.el7.x86_64.rpm`

заменить установленный пакет RPM:

`$ sudo rpm -ivh --replacepkgs GeoIP-1.5.0-11.el7.x86_64.rpm`

удалить пакет RPM:

`$ sudo rpm -e --nodeps GeoIP`

обновить установленный пакет RPM:

`$ sudo rpm -Uvh GeoIP-1.5.0-11.el7.x86_64.rpm`

запросить все установленные пакеты:

`$ sudo rpm -qa`

получить информацию для конкретного пакета:

`$ sudo rpm -qi GeoIP`

Перечень других популярных менеджеров с кратким описанием:

### YUM

YUM (Yellowdog Updater, Modified) – высокоуровневый пакетный менеджер, написанный на языке Python для систем RED HAT (RHEL, CentOS, Fedora). Программа представляет собой своеобразную оболочку для утилиты RPM. В задачу YUM входит скачивание и обновление пакетов из репозиториев, а также удовлетворение зависимостей во время установки программы.

### Pacman

Pacman – высокоуровневый пакетный менеджер системы Arch Linux и его родственных дистрибутивов (Manjaro, EndeavourOS и др.). Программа написана на языке C# и совмещает высокую функциональность, легкость и производительность. В качестве пакетов используются архивы pkg.tar.xz*.*

### Synaptic

Synaptic — графический менеджер пакетов, работающий на основе APT. Программа пригодится новичкам, плохо знакомым с командной строкой. Несмотря на простоту интерфейса, утилита предоставляет весь необходимый функционал пакетного менеджера APT (установка, удаление, обновление и поиск пакетов).

### GIT

Git - это очень популярная система контроля версий и совместной разработки проектов с открытым исходным кодом. С помощью Git вы можете отслеживать изменения в исходном коде своих проектов, возвращать предыдущие версии в случае критических ошибок, а также делиться своим кодом со всеми желающими и принимать от них исправления.Это мощная система, которая позволяет оптимизировать работу над вашими проектами. Здесь нет каких-либо требований к языку или структуре файлов, поэтому у разработчиков полная свобода действий.

Установка:

`sudo apt install git`

![https://i.imgur.com/kQiFjP6.png](https://i.imgur.com/kQiFjP6.png)

С помощью этой системы контоля версии мы можем получать исходные коды приложений, например мы хотим скачать сканнер BlackWidow ([https://github.com/1N3/BlackWidow](https://github.com/1N3/BlackWidow)). Для этого с помощью команды **git clone** склонируем проект из неофициального репозитория в нашу директорию (предварительно создадим её командой mkdir git и перейдем в неё командой cd git):

```html
$ git clone <https://github.com/1N3/BlackWidow>
```

![https://i.imgur.com/jRNYbtY.png](https://i.imgur.com/jRNYbtY.png)

## Удаленное администрирование Linux

Когда Вы занимаетесь администрированием одного единственного сервера, то можете выполнять все действия непосредственно на нём, зачастую имея к нему физический доступ. Но на практике корпоративная инфраструктура состоит из множества объединенных в сеть серверов, которые могут располагаться на разных этажах, в разных офисах, или даже городах. Что делать в таком случае? Не покупать же билет до Мурманска каждый раз, когда на расположенном там сервере вдруг перестал работать Apache. Для решения подобных задач существуют протоколы удаленного доступа, такие как Telnet и SSH. Мы уже рассматривали их в контексте управления сервисами, теперь же погрузимся в них более детально.

---

**TELNET** - одна из самых старых информационных технологий. Основным назначением протокола является реализация сетевого терминала для доступа к ресурсам удаленного компьютера. Протокол telnet ****обеспечивает двунаправленный восьмибитный канал передачи данных. Его главной задачей является создание стандартного метода взаимодействия терминальных устройств и терминал-ориентированных процессов через сеть telnet **** использует TCP-соединение для передачи данных вперемешку с управляющей информацией протокола. В принципе, для работы протокола передавать какую-либо управляющую информацию не обязательно. Таким образом, протокол может использоваться для соединения с любым сервисом, использующим TCP в качестве транспортного протокола, и обмену данными между участниками соединения.

Протокол telnet ****находится на сеансовом уровне модели **OSI/ISO**. Для обеспечения удаленного доступа к терминалу сервера стандартом резервируется порт 23. Основу протокола составляют три базовые концепции:

1. _**Концепция "Сетевого Виртуального Терминала"**_

**Сетевой виртуальный терминал, Network Virtual Terminal, NVT**

Когда устанавливается соединение, предполагается, что оно начинается и завершается на "Сетевом Виртуальном Терминале" (Network Virtual Terminal, NVT). NVT - это воображаемое устройство, которое создает промежуточное стандартное представление канонического терминала. NVT является стандартным описанием наиболее широко используемых возможностей реальных физических терминальных устройств. NVT позволяет описать и преобразовать в стандартную форму способы отображения и ввода информации.

Терминальная программа и работающий с ней процесс преобразовывают характеристики физических устройств в спецификацию **NVT**, что позволяет, с одной стороны, унифицировать характеристики физических устройств, а с другой обеспечить совместимость устройств с различными возможностями.

Характеристики диалога определяются устройством с меньшими возможностями. В результате, "пользовательскому" и "серверному" узлам не нужно хранить информацию о характеристиках терминалов друг друга. Все узлы отображают характеристики своих устройств так, чтобы другой стороне казалось, что она имеет дело с NVT. Обычно, под "пользовательским" понимают узел, к которому подключен реальный терминал, а под "серверным" - который предоставляет некоторый сервис. Можно считать "пользовательским" тот узел, который инициирует соединение.

2. _**Принцип согласования параметров**_

**Option negotiation**

NVT - это минимально необходимый набор параметров, который позволяет работать даже самым примитивным устройствам. Реальные современные устройства обладают гораздо большими возможностями представления информации. Принцип согласования параметров позволяет использовать эти возможности. Например, NVT является терминалом, который не может использовать функции управления курсором, а реальный терминал, с которого осуществляется работа, возможно умеет это делать. Используя согласование параметров, терминальная программа предлагает обслуживающему процессу использовать управляющие последовательности для управления выводом информации. Получив такую команду процесс начинает вставлять управляющие последовательности в данные, предназначенные для отображения.

Протокол предлагает структуру дополнительных параметров "DO, DON'T, WILL, WON'T", позволяющую пользователю и серверу более точно договориться об используемых в соединении соглашениях.

Команда **WILL** XXX указывает на предложение отправляющей стороны использовать параметр XXX. **DO** XXX и **DON'T** XXX являются, соответственно, положительным и отрицательным ответом. Аналогично, **DO** XXX посылается как предложение получающей стороне использовать параметр XXX**. WILL** XXX и **WON'T** XXX суть положительный и отрицательный ответы. Так как **NVT** это то, что остается, когда никакие параметры не используются, ответы **DON'T** и **WON'T** гарантируют, что соединение останется в состоянии, которое подходит обеим сторонам. В отличие от других протоков сеансового уровня, таких как **FTP** или **SMTP**, команды передаются не английскими словами (или их сокращениями), а в виде восьмибитных последовательностей (байтов).

Так, команде **DO** соответствует байт 253, **WON'T** - 252, и т.д.

Установка определенного параметра происходит так: один из участников соединения посылает другому запрос, предлагая использовать в сеансе работы определенный параметр. Если другая сторона соглашается, параметр немедленно вступает в силу. Если приходит отказ, используется то значение параметра, которое определяется для **NVT**. Обычно параметры согласуются вначале при установке соединения, хотя при работе одна из сторон может вновь изменить какие-либо параметры.

3. _**Симметрия терминалов и процессов**_

Симметрия терминалов и процессов отражает тот факт, что все управляющие команды протокола могут даваться любой стороной, участвующей в соединении. Разделения на "клиент" и "сервер" здесь нет.

Вспомним команду установки telnet:

```html
$ sudo apt install telnet
```

**Синтаксис** telnet:

```html
$ telnet опции хост порт
```

Хост - это домен удаленного компьютера, к которому следует подключиться, а порт - порт на этом компьютере.

Мы можем использовать telnet для проверки доступности хоста (в случае, если наша идеология по той или иной причине презирает утилиту ping):

```html
$ telnet 192.168.1.243
```

Можно проверить доступность порта (в команде ниже проверяем порты 123 и 22 на localhost):

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/6b77eda5-b7bc-41d0-9972-a6ef4415a880/Untitled.png)

В первом случае мы видим, что соединение никто не принимает, во втором же выводится сообщение об успешном подключении и приветствие SSH сервера (SSH по умолчанию висит на 22 порту, однако для повышения уровня защиты системы следует его “перевесить” на какой-либо нестандартный порт).

А теперь давайте рассмотрим основные опции:

- **4** - принудительно использовать адреса ipv4;
- **6** - принудительно использовать адреса ipv6;
- **8** - использовать 8-битную кодировку, например, Unicode;
- **E** - отключить поддержку Escape последовательностей;
- **a** - автоматический вход, берет имя пользователя из переменной окружения USER;
- **b** - использовать локальный сокет;
- **d** - включить режим отладки;
- **р** - режим эмуляции rlogin;
- **e** - задать символ начала Escape последовательности;
- **l** - пользователь для авторизации на удаленной машине.

После установки подключения telnet может работать в двух режимах:

- **Построчный** - это предпочтительный режим, здесь строка текста редактируется на локальном компьютере и отправляется только тогда, когда она будет полностью готова. На такая возможность есть не всегда и не у всех сервисов;
- **Посимвольный** - все набираемые вами символы отправляются на удаленный сервер. Тут будет сложно что-либо исправить, если вы допустили ошибку, потому что Backspace тоже будет отправляться в виде символа и стрелки движения тоже.

Использование telnet заключается в передаче специальных команд. У каждого сервиса свои команды, но у протокола есть свои команды telnet, которые можно применять в консоли telnet.

- **CLOSE** - закрыть соединение с сервером;
- **ENCRYPT** - шифровать все передаваемые данные;
- **LOGOUT** - выйти и закрыть соединение;
- **MODE** - переключить режим, со строчного на символьный или с символьного на строчный;
- **STATUS** - посмотреть статус соединения;
- **SEND** - отправить один из специальных символов telnet;
- **SET** - установить значение параметра;
- **OPEN** - установить подключение через telnet с удаленным узлом;
- **DISPLAY** - отобразить используемые спецсимволы;
- **SLC** - изменить используемые спецсимволы.

### Консоль telnet

Использование консоли telnet тоже важный момент в разборе как пользоваться telnet. В основном режиме вы можете выполнять команды, на удаленном сервере, если же вы хотите адресовать команду именно telnet, например, для настройки ее работы, необходимо использовать спецсимвол для открытия консоли, обычно утилита сразу говорит вам что это за символ. По умолчанию используется символ, соответсвующий очетанию клавиш Ctrl+[

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/fe20e415-ca6f-412d-a30f-87a24d7a895e/Untitled.png)

Чтобы посмотреть все доступные команды, вы можете набрать ?. Например, вы можете посмотреть статус подключения:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/af8a5728-7d91-429f-84d0-3dfb162cafd8/Untitled.png)

Настоятельно не рекомендуется использовать небезопасный telnet для удаленного управления, потому что все команды и пароли могут быть прослушаны сторонним пользователем. Но иногда, например, для роутеров, telnet все же используется для удаленного управления. Все работает точно так же, как и для других подключений, только нужно использовать порт 23, а на удаленном компьютере должен быть установлен telnet-server:

```html
$ telnet localhost 23
```

Далее, вам нужно ввести логин и пароль, а затем вы сможете выполнять команды в удаленной системе.

## **SSH**

Средство номер один для организации удаленного доступа - протокол SSH.

SSH (от англ. _s_ecure _sh_ell -- безопасная оболочка) это набор программ, которые позволяют регистрироваться на компьютере по сети, удаленно выполнять на нем команды, а также копировать и перемещать файлы между компьютерами. SSH организует защищенное безопасное соединение поверх небезопасных каналов связи.

SSH предоставляет замены традиционным r-командам удаленного доступа с тем отличием, что они обладают повышенной безопасностью. Они выполняются поверх защищенных зашифрованных соединений, которые не позволяет прослушивать или подменять трафик. Кроме того, SSH может обеспечивать безопасное соединение для передачи любого другого трафика: например, почтовых сообщений или файлов.

Протокол SSH возник как попытка обезопасить открытые незащищенные соединения. Впоследствии его функции были значительно расширены. Наиболее важными из них являются:

- _Безопасные команды доступа к хосту._ SSH дает возможность выполнять безопасные команды доступа к хосту, такие как ssh (удаленная оболочка), slogin (удаленный вход в систему), scp (удаленное копирование);
- _X11 Forwarding._ SSH предоставляет встроенный механизм для выполнения удаленных клиентов X Window.
- _Port forwarding._ SSH может выполнять переадресацию портов, передавая трафик c одного порта одной машины на другой порт другой машины. При этом передаваемый трафик шифруется;

### Обеспечение безопасности SSH

Безопасность протокола достигается использованием нескольких решений, которые сводят к минимуму риск использования соединения:

- _Шифрование соединение_, которое может выполняться одним из методов, выбранных в процессе переговоров. Шифрованное соединение не позволяет просто перехватить и использовать трафик. Выбор алгоритма шифрования делает систему более гибкой, позволяя не использовать алгоритмы, в которых обнаружены слабые места или которые не может поддерживать одна из сторон;
- _Аутентификация сервера_ выполняется при любом соединении. Это не позволяет выполнить подмену сервера или подмену трафика;
- _Аутентификация клиента_ может выполняться одним из нескольких доступных способов. Это с одной стороны может повысить надежность аутентификации, с другой -- делает систему более гибкой и упрощает ее использование;
- _Проверка целостности пакетов_ позволяет отследить любые незаконные изменения в трафике соединения. При обнаружении таких изменений, соединение немедленно разрывается;
- _Временные параметры аутентификации_ не позволяют воспользоваться данными соединения в том, случае, если спустя некоторое время после перехвата оно все-таки было расшифровано. Устаревание обычно происходит через час;

### Аутентификация сервера

Аутентификация сервера производится при помощи инфраструктуры открытых ключей. Клиент, который хочет установить соединение с сервером шифрует данные известным ему открытым ключом сервера и отправляет их серверу. Сервер должен расшифровать их при помощи известного только ему секретного ключа, и отправить их назад. Так клиент может быть уверен в том, является ли хост тем, за кого себя выдает.

Аутентификация сервера по протоколу SSH выполняется при помощи инфраструктуры открытых ключей. Открытый ключ сервера клиент получает при первом соединении с ним.

Аутентификация сервера дает возможность не полагаться на службу имен и маршрутизацию пакетов. В том случае, если нарушителю удалось подменить запись в DNS или перенаправить IP-пакеты на свой хост, аутентификация не пройдет, поскольку хост не обладает необходимыми секретными ключами.

S_sh_ защищает от:

- _Подмены IP-адресов (IP-spoofing),_ когда удаленный хост посылает пакеты от имени другого хоста;
- _Подмены DNS-записей (DNS-spoofing),_ когда изменяется запись на сервере DNS и в результате соединение устанавливается не с желаемым хостом, а с тем, на который указывает новая запись;
- _Перехвата открытых паролей и прочих данных_, которые передаются в открытом виде и любой, кто имеет физический доступ к каналу, может их узнать.

### Аутентификация клиента

Методы аутентификации клиентов, которые использует SSH:

- Host-based аутентификация
- Аутентификация с помощью открытых ключей
- Kerberos-аутентификация
- Парольная аутентификация.

_**По хостам**._ Метод аналогичный используемому в r-командах. В том случае, если соединение устанавливается с привилегированного порта, и файл .rhosts позволяет вход в систему, он разрешается. Этот метод является потенциально небезопасным, рекомендуется не использовать его. Для повышения уровня своей безопасности метод может быть дополнен ls /devRSA-аутентификацией клиентского хоста.

_**Открытый ключ**._ Клиент отправляет серверу открытый ключ. Если сервер знает его, он просит клиента доказать, что тот знает и секретный ключ тоже. Если клиент может это доказать, значит аутентификация считается успешной.

_**Керберос**._ Аутентификация проводится по схеме v5 Kerberos.

_**Пароль**._ В самом крайнем случае, если не удалось провести аутентификацию не одним из перечисленных способов, используется традиционная аутентификация при помощи пароля. Принцип аутентификации аналогичен тому, какой, например, используется в Telnet с той разницей, что пароль передается по зашифрованному каналу.

## OpenSSH

OpenSSH — это реализация с открытым исходным кодом протокола SSH, позволяющая шифровать соединение в сети посредством набора программ. Состоит из сервера OpenSSH и клиентских пакетов.

Технология работает по принципу сервер-клиент. То есть на удалённой машине, на которой вы хотите выполнять команды, нужно запустить сервер OpenSSH. К этому серверу можно подключаться с помощью клиентов OpenSSH. На одном компьютере могут быть одновременно установлены и сервер и клиент. Их запуск и настройка выполняется независимо друг от друга.

**Сервер sshd**

Сервер SSH реализован в виде программы sshd. Сервер _sshd_ является независимой программой, поэтому его запуск нужно производить во время загрузки компьютера стартовыми скриптами. То есть, вызов _sshd_ либо должен осуществляться явно одним из rc-скриптов, либо ссылки на скрипт запуска следует включить в иерархию /etc/rc?.d/.

Для того чтобы сервер sshd автоматически стартовал при запуске компьютера, необходимо добавить его вызов в скрипты загрузки.

Будучи запущенным, демон работает в фоновом режиме и обрабатывает все входящие запросы по порту 22. Для каждого соединения создается новая копия демона, который занимается только его обслуживанием.

**Настройка сервера sshd**

Конфигурация демона определяется файлом /etc/ssh/sshd_config. Он представляет собой набор действующих строк, пустых строк и строк-комментариев. Действующие строки файла содержат название параметра и его значение. Например, строка

```
Port 22
```

заставляет демон вести прослушивание на 22 порту. В конфигурационном файле указывается большое количество параметров, которые можно отнести к нескольким категориям:

- _Адреса._ Интерфейс и порт, к которым привязан демон;
- _Журнализация._ Опции, определяющие то, какая именно информация о работе демона должна регистрироваться и заноситься в журналы системы;
- _Управление ключами._ Информация о том, в каких файлах находятся ключи, участвующие в аутентификации.
- _Аутентификация._ Допустимые схемы аутентификации.
- _Дополнительные параметры._ Опции, управляющие дополнительными функциями SSH, такими как переадресация портов, переадресация X11 и другие

Некоторые конфигурационные параметры могут быть переопределены опциями командной строки при вызове _sshd_.

### **Конфигурационный файл /etc/ssh/sshd_config**

Служба **sshd** считывает данные о конфигурации из файла **/etc/ssh/sshd_config** (или из файла. указанного в командной строке при помощи параметра **-f**). Файл содержит пары параметр-значение, по одной на строку. Пустые и строки, начинающиеся с «**#**». интерпретируются как комментарии. Если аргументы содержат пробелы, они должны быть заключены в двойные кавычки (**' '**).

### Клиент ssh

Программа _ssh_ предназначена для регистрации на удаленном хосте с использование протокола _ssh_ и удаленного выполнения команд. Кроме того _ssh_ позволяет выполнять туннелирование любых TCP-соединений внутри _ssh_-канала (port forwarding).

Синтаксис _ssh_:

```html
*ssh опции хост* *пользователь*@*хост* *команда*
```

_ssh_ подключается к удаленному _хост_у, используя для этого текущее имя пользователя или, если указано явно, имя _пользователя_. После этого происходит двусторонняя аутентификация, т.е. удаленный хост доказывает, что он именно тот, за кого себя выдает, а регистрирующийся пользователь в свою очередь доказывает это удаленному хосту.

После этого удаленный хост, выполняет заданную команду, либо если _команда_ отсутствует, запускает командный интерпретатор и предоставляет к нему доступ. После того, как команда выполнена, либо оболочка командного интерпретатора завершила свою работу, соединение завершается.

Программа ssh имеет свой собственный конфигурационный файл, точно такого же формата, как и конфигурационный файл сервера sshd, только в котором используются другие директивы.

**Некоторые опции командной строки программы ssh**

- _v_ -- Выводить отладочную информацию о ходе процесса установки соединения. Настоятельно рекомендуется использовать ключ во время настройки службы.
- _f_ -- Перейти в фоновый режим, сразу же после того, как пройден этап регистрации
- _l_ пользователь ** -- Регистрироваться на удаленной системе как _пользователь_. Вместо ключа имяможно указывать перед именем хоста в форме _пользователь_@_хост_
- _p_ порт ** -- Порт удаленного хоста, на котором доступен сервис SSH. По умолчанию используется порт 22.
- _L_ порт*:_хост_:*хостпорт ** -- Перенаправить _порт_ локального хоста на _хостпорт_ удаленного _хост_а.
- _R_ порт*:_хост_:*хостпорт ** -- Перенаправить _порт_ удаленного локального хоста на _хостпорт_ локального хоста.
- _o_ опции ** -- Явно указать _опции_, которые перекрывают опции, заданные в конфигурационных файлах _ssh_.

### Пример использования клиента _ssh_

Для удаленной регистрации на компьютере remote_srv.com нужно использовать команду:

```
user$ ssh remote_srv.com
```

Следует обратить внимание на то, что для входа на remote_srv.com будет использоваться локальное имя пользователя user.

Если имя пользователя на удаленном хосте не совпадает с локальным именем, его нужно указать явно:

```
user$ ssh -l master remote_srv.com
user$ ssh master@remote_srv.com
```

Зарегистрироваться на удаленном компьютере remote_srv.com под именем пользователя master. Обе команды эквивалентны.

_Примечание: зачастую вместо имени компьютера используется его IP-адрес, команда будет выглядеть следующим образом_

```html
user$ ssh master@192.168.1.1
```

## Утилиты SSH

К серверным утилитам OpenSSH относятся:

- **sshd** (OpenSSH Daemon) — программа демон для ssh. sshd ожидает подключений от клиентов.
- **sftp-server** (серверная подсистема SFTP) — это программа, которая участвует в передачи файлов по протоколу SFTP. sftp-server не предназначен для прямого вызова, обычно она задействуется автоматически демоном sshd.

Итак, на сервере основного внимания требует sshd, а программа sftp-server будет запущена автоматически по мере необходимости.

К клиентским утилитам OpenSSH относятся:

- **ssh** (клиентская программа SSH) — это программа для выполнения входа на удалённую машину и выполнения команд на этой удалённой машине.
- **scp** — программа для копирования файлов на удалённую машину с локальной, или в обратном направлении — с локальной на удалённую. При передаче данных используется зашифрованный канал.
- **sftp** — это тоже программа для передачи файлов по безопасному каналу. Эта программа похожа на **ftp**.
- **ssh-keygen** — утилита для создания ключей аутентификации и управления ими. Также она может использоваться для отзыва ключей.

Это основные программы, которые могут понадобиться большинству пользователей для создания ключей, подключения к удалённой машине и при удалённом копировании файлов.

В Debain и производных (Kali Linux, Linux Mint, Ubuntu), программы OpenSSH можно установить по отдельности, например, имеются пакеты для клиента и для сервера **openssh-client** и **openssh-server**. Либо можно установить метапакет **ssh**, который содержит и клиентскую, и серверную часть.

```html
$ sudo apt install ssh
```

Клиент **ssh** запускается самим пользователем по мере необходимости.

Запуск службы OpenSSH требуется только на сервере. Для запуска службы и добавления её в автозагрузку наберите следующие команды:

```html
$ sudo systemctl start sshd.service
$ sudo systemctl enable sshd.service
```

Проверка статуса службы:

```html
$ systemctl status sshd.service
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/0cc55272-659a-4d47-a2d8-e9efd3256f1e/Untitled.png)

### Создание и установка асимметричных ключей SSH

Аутентификация с использованием открытых ключей проходит следующим образом. Хост, на котором выполняется удаленная регистрация предлагает пользователю аутентифицировать себя. Для этого он пересылает сообщение, зашифрованное известным ему открытым ключом пользователя. Если пользователь расшифрует сообщение, значит он знает секретный ключ, следовательно, является тем за кого себя выдает.

Секретные ключи хранятся в файлах identity, id_dsa и id_rsa в локальном каталоге ~/.ssh (разные файлы для разных алгоритмов шифрования). Открытые ключи должны быть в файлах authorized_keys и authorized_keys2 в каталоге ~/.ssh на удаленном компьютере, на котором производится регистрация. В качестве домашнего рассматривается каталог пользователя, под именем которого выполняется регистрация. Файл authorized_keys используется для хранения открытых ключей для SSH1, а в authorized_keys2 — для SSH2.

Ssh дает возможность использования одного из трех различных алгоритмов асимметричного шифрования RSA или DSA.

**Типы ключей**

- _rsa1_ -- Тип ключа RSA1, используемый в SSH версии 1
- _rsa_ -- Тип ключа RSA, используемый в SSH версии 2
- _dsa_ -- Тип ключа DSA, используемый в SSH версии 2

Для создания, преобразования и управления ключами аутентификации используется утилита ssh-keygen. Синтаксис:

```html
*ssh-keygen* *опции*
```

Программа генерирует пару открытый ключ - секретный ключ. При этом она спрашивает, в какие файлы нужно записать ключи. По умолчанию секретный ключ записывается в ~/.ssh/identity (или ~/.ssh/id_rsa, ~/.ssh/id_dsa), а открытый в ~/.ssh/identity.pub.

Сгенерированный секретный ключ защищается при помощи парольной фразы (passphrase), которую нужно обязательно знать, для того чтобы воспользоваться ключом. Секретная фраза вводится в момент генерирования ключей. Она может быть затем изменена, без повторного копирования ключей.

Можно сгенерировать секретные ключи, в которых парольная фраза будет отсутствовать. Хотя это и упрощает использование ключей, делать этого не рекомендуется, поскольку в этом случае файл с секретным ключом автоматически влечет за собой полный беспрепятственный доступ ко всем системам, где установлена его открытая пара.

Полученный открытый ключ нужно добавить в файлы authorized_keys удаленных хостов, к которым будет производится доступ.

```html
$ cat ~/.ssh/identity.pub |  ssh user@host 'cat >> ~/.ssh/authorized_keys'
```

Аналогично для второй версии SSH:

```
$ cat ~/.ssh/id_dsa.pub |  ssh user@host 'cat >> ~/.ssh/authorized_keys2'
```

или воспользоваться утилитой ssh-copy-id

```
~/.ssh$ ssh-copy-id -i identity.pub user@host
```

Можно ограничиться только второй версией SSH, однако в том случае, если SSH-сервер на удаленной машине не поддерживает SSH-протокол версии 2, аутентификацию с использованием открытых ключей провести не удастся.

После того, как аутентификация с использование открытых ключей настроена, доступ к удаленному компьютеру можно получить без пароля. Однако для того чтобы воспользоваться локальным секретным ключом нужно ввести парольную фразу.

```
$ ssh user@host
Enter passphrase for key '/home/user/.ssh/id_rsa':
```

## Удаленное копирование файлов

### _scp_

Набор программ SSH позволяют не только выполнять удаленную регистрацию на компьютере для доступа к удаленной строке. Программа scp копирует файлы между хостами, полагаясь при этом на протоколы SSH и используя те же методы аутентификации, что и ssh.

Синтаксис программы _scp_:

```html
*scp* *опции*  *пользователь*@*хост*1:*файл*1... *пользователь*@*хост*2:*файл*2
```

Команда устанавливает защищенное соединение между _хост_ом1 и _хост_ом2 и копирует _файл_1 _хост_а1 в _файл_2 _хост_а2. Любой из _хост_ов может быть локальным. Если имя хоста не указано, подразумевается локальный хост.

Синтаксис использования команды _scp_ напоминает синтаксис cp. Она так же обрабатывает большое количество аргументов, использует аналогичные ключи для рекурсивного копирования, для копирования атрибутов и т.д.

**Опции программы _scp_**

- _r_ -- Выполнить рекурсивное копирование каталогов
- _p_ -- Сохранить по возможности атрибуты файлов (права доступа, время модификации, время доступа) при копировании
- _C_ -- Выполнять сжатие файлов при передаче
- _P_ порт ** -- Соединяться с удаленным компьютером по порту _порт_
- _v_ -- Сообщать отладочную информацию о ходе SSH-соединения
- _q_ -- Не выдавать индикатор прогресса

Например с удаленного хоста source на локальный хост dest нужно скопировать домашний каталог пользователя batman. Команда выполняющая копирование будет выглядеть так:

```
dest$ scp -rp source:/home/batman /home
.login               100% |*****************************|   255       00:00
.login_conf          100% |*****************************|   160       00:00
.mailrc              100% |*****************************|   331       00:00
.profile             100% |*****************************|   789       00:00
.shrc                100% |*****************************|   852       00:00
.mail_aliases        100% |*****************************|   371       00:00
.cshrc               100% |*****************************|   771       00:00

```

Строки, которые программа выводит на экран говорят о названии файла, его размере и времени копирования. Кроме этого строка содержит индикатор прогресса, которой показывает какая часть файла успешно скопирована.

**События SSH** можно разделить на события:

- запуска и остановки этой службы
- события, связанные с подключением пользователей

Просмотреть логи SSH можно различными способами, один из вариантов (помните, что в некоторых системах служба называется **ssh.service**, без буквы **d**):

`journalctl -u sshd.service`

Например, для вывода последних 100 записей:

`journalctl -u sshd.service | tail` `-n 100`

Также можно просмотреть события SSH с помощью:

`journalctl -u "sshd@*"`

или:

`journalctl /usr/bin/sshd`

Универсальная команда в независимости от имени службы:

`journalctl -u "ssh*"`

Для вывода событий, связанных с подключением пользователей, другой информации, в том числе отладочной (зависит от настройки уровня подробности сообщений), можно посмотреть следующим образом:

`journalctl | grep` `-i ssh`

Если настроен вход по паролю, то для **вывода неудачных попыток** наберите команду:

`journalctl | grep` `-i 'Failed password for'`

Если настроен вход по публичному ключу, но не отключена возможность входа по паролю, то после неверного ключа, будет предоставлена возможности войти по паролю. Такие неудачные попытки входа по паролю можно найти такой же командой:

`journalctl | grep` `-i 'Failed password for'`