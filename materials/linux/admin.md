# Дополнительный материал

# Лекционный материал:

## 1. Базовые настройки системы

**Установка**

Устновить Linux - задачка несложная, однако требующая от пользователя понимания того, что и зачем он делает. Далее следует подробное описания всех необходимых шагов.

Первое, что нам нужно сделать - создать носитель (флешка, CD-диск, твердотельный накопитель), содержащий образ системы (файл формата .iso скачанный с официального сайта выбранного нами дистрибутива), которую мы собираемся установить. Для этого можно воспользоваться специальными утилитами записи образа - Rufus (для Windows), Etcher (для macOS).

Затем необходимо создать раздел диска, на котором впоследствии будет установлен Linux. Как это сделать?

_**Если у вас Windows, то:**_

Откройте проводник и нажмите на “Этот компьютер” правой кнопкой мыши, выберите пункт управление. Далее откройте «Средство управления дисками» Windows.

Выберите диск или раздел, от которого вы планируете отрезать немного места для установки Linux. Большинству дистрибутивов с лихвой хватит 15 ГБ. Но если вы планируете устанавливать много приложений, возьмите больше. Щёлкните по разделу правой кнопкой мыши и выберите «Сжать том». Введите размер и нажмите ОК. Процесс может занять довольно много времени, так что запаситесь терпением.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/5d7e1627-a4e3-4c20-a8d9-8fe914b6ad81/Untitled.png)

Когда «Средство управления дисками» закончит изменять размеры разделов, на диске появится пустое неразмеченное пространство, отмеченное чёрным цветом. Туда мы и установим Linux. Позже, если Linux вам не понадобится, можно будет удалить разделы с ним и отдать освободившееся место обратно Windows при помощи всё того же «Средства управления дисками».

_**Если у вас macOS, то:**_

Выделить место для установки Linux можно через «Дисковую утилиту» macOS. Выберите ваш диск и щёлкните по значку «+», чтобы создать раздел для Linux. Создание нового раздела может занять некоторое время.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/a8216999-cf75-4cd3-bcae-4ebe6d3f1862/Untitled.png)

Следующий шаг - загрузиться в систему с созданного носителя. Для этого в меню BIOS, в разделе Boot Priority необходимо выставить приоритет соответсвующему устройству. Чтобы попасть в меню BIOS, подключите флешку, перезагрузите компьютер и сразу (до загрузки Windows) после включения нажмите клавишу F12, F11 или Esc — какую именно, зависит от производителя оборудования. Обычно комбинация указана на экране, главное успеть прочитать её. Попав в BIOS используйте стрелки, клавишу Enter и Esc для навигации, и переместитесь в раздел Boot Priority. Затем следуйте указаниям на экране для того чтобы переместить нужное устройство на первое место в списке. У разных производителей меню BIOS может отличаться, смотрите документацию к вашему устройству. На Mac для настройки приоритета загрузки удерживайте клавишу Option.

Если вы пользуетесь Windows 8 и новее, то загрузчик UEFI не позволит вам загрузить какую бы то ни было систему, кроме Windows. Чтобы это исправить, зайдите в настройки BIOS вашего компьютера и отключите опцию Secure Boot. Затем перезагрузитесь. Готово, теперь вы можете загружать и устанавливать другие системы рядом со своей Windows.

Если вы пользователь macOS, то вам придется также отключить SIP. После перезагрузите Mac и нажмите Cmd + R. Появится меню Recovery. Выберите в нём «Терминал» и введите `csrutil disable`. Перезагрузите Mac ещё раз. SIP отключён. Загрузите и установите rEFInd. Встроенная утилита Boot Camp может помочь вам установить только Windows. rEFInd умеет загружать и macOS, и Windows, и Linux. Так что вы сможете выбирать, какая система будет загружаться при старте. Распакуйте rEFInd. Затем откройте «Терминал» и введите `diskutil list`. Найдите в появившемся списке, как называется ваш загрузчик EFI. Чаще всего это /dev/disk0s1. Введите `mount /dev/disk0s1` и запустите установку rEFInd, перетащив [install.sh](http://install.sh) из распакованной папки в окно «Терминала».

Когда вы загрузитесь с созданного носителя, Вас поприветствует мастер установки Linux. Выглядеть это будет примерно так (у разных дистрибутивов разное оформление, но суть одинакова):

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/d548f213-1726-44d6-a970-595eeda4c642/Untitled.png)

Теперь следуйте инструкциям установщика. В большинсвте дистрибутивов Вам будет предложено выбрать язык системы, используемые раскладки клавиатуры, часовой пояс и тд.

Отдельного внимания заслуживает разметка диска. По началу Вам будет достаточно автоматической разметки, следует лишь выбрать как вы хотите установить Linux: вместо уже установленной на диске ОС или рядом с ней. Однако впоследствии вы столкнетесь с необходимостью самостоятельно выбирать размеры для ваших разделов или, например, создавать отдельные раздел для тех или иных задач. Для этого выбирайте ручную разметку. Выберите пункт создать раздел. Укажите его размер, вид, файловую систему и точку монтирования. Рассмотрим некоторые пункты подробнее.

### Виды разделов

**Первичный (основной) раздел**

Первичный раздел обязательно должен быть на физическом диске. Этот раздел всегда содержит либо одну файловую систему, либо другие логические разделы. На физическом диске может быть до четырёх первичных разделов. Некоторые старые операционные системы — например, MS-DOS и Windows — могли быть установлены только на первичный раздел.

**Расширенный и Логические разделы**

Таблица разделов может содержать не более 4 первичных разделов, поэтому были изобретёны расширенный разделы. В расширенном разделе можно создать несколько логических разделов. Логические разделы выстраиваются в цепочку где информация о первом логическом разделе храниться в MBR, а информация о последующем хранится в первом секторе логического раздела. Такая цепочка позволяет (в теории) создавать неограниченное количество разделов, но (на практике) число логических разделов ограничивается утилитами и, обычно, больше 10 логических разделов не создать.

Важно отметить что некоторые версии Windows не могут загрузиться с логического раздела (нужен обязательно первичный раздел), тогда как для Linux никакой разницы в виде разделов - нет, Linux загружается и работает с разделами совершенно независимо от их вида (первичный или логический).

### Файловые системы

Файловая система – это инструмент, позволяющий операционной системе и программам обращаться к нужным файлам и работать с ними. При этом программы оперируют только названием файла, его размером и датой созданий. Все остальные функции по поиску необходимого файла в хранилище и работе с ним берет на себя файловая система накопителя.

Основные функции файловой системы:

- Фрагментация файлов и их распределение на носителе.
- Поиск файла при запросе программ.
- Участие в создании, чтении и удалении файлов.
- Работа с атрибутами файлов: изменение названия, размера, времени последнего изменения, доступ к файлу и многое другое.
- Каталогизация и организация файлов.
- Защита файлов от несанкционированного доступа и сбоев системы.
- Определение права доступа к файлам.
- Восстановление информации в случае сбоев.

Таким образом, файловая система устанавливает правила эксплуатации и организацию данных на накопителе, и тем самым экономит ресурсы операционной системы и рабочих программ. К тому же наличие файловой системы позволяет использовать накопитель на разных компьютерах без каких-либо предварительных настроек и оптимизации.

### **FAT32**

Исходный код файловой системы, получившей название FAT, был разработан по личной договоренности владельца Microsoft Билла Гейтса с первым наемным сотрудником компании Марком Макдональдом в 1977 году. Основной задачей FAT была работа с данными в операционной системе Microsoft 8080/Z80 на базе платформы MDOS/MIDAS. Файловая система FAT претерпела несколько модификаций – FAT12, FAT16 и, наконец, FAT32, которая используется сейчас в большинстве внешних накопителей. Основным отличием каждой версии является преодоление ограниченного объема доступной для хранения информации. В дальнейшем были разработаны еще две более совершенные системы обработки и хранения данных – NTFS и ReFS. Современная версия FAT32 вышла в 1995 году. Она может работать с томами размером до 32 ГБ и файлами размером до 4 ГБ. При этом система не работает с накопителями объемом более 8 Тб. Поэтому сегодня FAT32 используется в основном только на флешках, картах памяти фотоаппаратов и музыкальных плееров.

Структура накопителя с FAT32 имеет три области:

- Служебный сектор, который зарезервирован системой.
- Таблица указателей для поиска файлов.
- Область записи данных.

Благодаря отсутствию шифрования, современных систем защиты информации и журнала данных, накопители с файловой системой FAT32 могут работать быстрее, но только с единичными файлами. Работа с массивом небольших файлов может затянуться надолго. Причиной является иерархическая структура, которая подразумевает многоуровневый доступ к файлам, в отличие от бинарного дерева, где доступ к файлам открывается напрямую, независимо от других.

Однако несмотря на очевидные недостатки, система все еще востребована, и даже предоставляет некоторые преимущества:

- Накопители меньше изнашиваются, благодаря отсутствию журнала.
- Флешки с FAT32 распространены в рабочей среде. На них удобно переносить документы, фотографии, небольшие видеоролики, презентации.
- Флешки с FAT32 используются в качестве установочных.

Числа в FAT12, FAT16 и FAT32 обозначают количество бит, используемых для перечисления блока файловой системы. FAT32 является фактическим стандартом и устанавливается на большинстве видов сменных носителей по умолчанию. Одной из особенностей этой версии ФС является возможность применения не только на современных моделях компьютеров, но и в устаревших устройствах и консолях, снабженных разъемом USB.

С целью устранения ограничений, присущих FAT32, корпорация Microsoft разработала обновленную версию файловой системы exFAT (расширенная таблица размещения файлов). Новая ФС очень схожа со своим предшественником, но позволяет пользователям хранить файлы намного большего размера, чем четыре гигабайта. В exFAT значительно снижено число перезаписей секторов, ответственных за непосредственное хранение информации. Функция очень важна для твердотельных накопителей ввиду необратимого изнашивания ячеек после определенного количества операций записи. Продукт exFAT совместим с операционными системами Mac, Android и Windows. Для Linux понадобится вспомогательное программное обеспечение.

### **NTFS**

NTFS, или новая технология файловой системы была создана, чтоб устранить недостатки FAT32.

Структура системы хранения данных имеет вид бинарного дерева. В отличие от иерархической, как у FAT32, доступ к информации осуществляется по запросу, а поиск ведется по названию файла. При этом система имеет каталог, отсортированный по названиям. Массив делится на 2 части и отсекается та, в которой данного файла не будет, оставшаяся часть также делиться на 2, и так далее до тех пор, пока не будет найден нужный файл.

Особенности файловой системы NTFS:

- Имена файлов размером до 255 символов.
- Журналирование – действия с файлами выполняются полностью, или не совершается вовсе. Например, если во время копирования файлов отключается питание, то при включении по журналу система проверит, какие файлы были скопированы полностью, а результаты незавершенных процессов удаляются.

Использование шифрования для защиты данных. Использование системы шифрования Encryption File System (метод «прозрачного шифрования») осуществляет разграничение доступа к данным для различных пользователей, предотвращает несанкционированный доступ к содержимому файла. Файловая система позволяет использовать расширенные имена файлов, включая поддержку многоязычности в стандарте юникода UTF, в том числе в формате кириллицы. Встроенное приложение проверки жесткого диска или внешнего накопителя на ошибки файловой системы chkdsk повышает надежность работы диска, но отрицательно влияет на производительность.

В отличие от предыдущей файловой системы, NTFS может работать с томами объемом 8 ПБ (1 петабайт – 10^15 байт), и оперировать более чем 4 миллиардами файлов.

### **ReFS (Resilient File System)**

Последняя разработка Microsoft, доступная для серверов Windows 8 и 10. Архитектура файловой системы в основном организована в виде B-tree. Файловая система ReFS обладает высокой отказоустойчивостью благодаря реализации новых функций:

- Copy-on-Write (CoW) – никакие метаданные не изменяются без копирования;
- данные записываются на новое дисковое пространство, а не поверх существующих файлов;
- при модификации метаданных новая копия хранится в свободном дисковом пространстве, затем система создает ссылку из старых метаданных на новую версию.

Все это позволяет повысить надежность хранения файлов, обеспечивает быстрое и легкое восстановление данных.

### **Файловые системы macOS**

Для операционной системы macOS компания Apple использует собственные разработки файловых систем:

1. HFS+, которая является усовершенствованной версией HFS, ранее применяемой на компьютерах Macintosh, и ее более соверешенный аналог APFS. Стандарт HFS+ используется во всех устройствах под управлением продуктов Apple, включая компьютеры Mac, iPod, а также Apple X Server.
2. Кластерная файловая система Apple Xsan, созданная из файловых систем StorNext и CentraVision, используется в расширенных серверных продуктах. Эта файловая система хранит файлы и папки, информацию Finder о просмотре каталогов, положениях окна и т.д.

### **Файловые системы Linux**

В отличие от ОС Windows и macOS, ограничивающих выбор файловой системы предустановленными вариантами, Linux предоставляет возможность использования нескольких ФС, каждая из которых оптимизирована для решения определенных задач. Файловые системы в Linux используются не только для работы с файлами на диске, но и для хранения данных в оперативной памяти или доступа к конфигурации ядра во время работы системы. Все они включены в ядро и могут использоваться в качестве корневой файловой системы.

Основные файловые системы, используемые в дистрибутивах Linux:

- Ext2;
- Ext3;
- Ext4;
- JFS;
- ReiserFS;
- XFS;
- Btrfs;
- ZFS.

**Ext2, Ext3, Ext4** или **Extended Filesystem** – стандартная файловая система, первоначально разработанная для Minix. Содержит максимальное количество функций и является наиболее стабильной в связи с редкими изменениями кодовой базы. Начиная с ext3 в системе используется функция журналирования. Сегодня версия ext4 присутствует во всех дистрибутивах Linux.

**JFS** или **Journaled File System** разработана в IBM в качестве альтернативы для файловых систем ext. Сейчас она используется там, где необходима высокая стабильность и минимальное потребление ресурсов (в первую очередь в многопроцессорных компьютерах). В журнале хранятся только метаданные, что позволяет восстанавливать старые версии файлов после сбоев.

**ReiserFS** также разработана в качестве альтернативы ext3, поддерживает только Linux. Динамический размер блока позволяет упаковывать несколько небольших файлов в один блок, что предотвращает фрагментацию и улучшает работу с небольшими файлами. Недостатком является риск потери данных при отключении энергии.

**XFS** рассчитана на файлы большого размера, поддерживает диски до 2 терабайт. Преимуществом системы является высокая скорость работы с большими файлами, отложенное выделение места, увеличение разделов на лету, незначительный размер служебной информации. К недостаткам относится невозможность уменьшения размера, сложность восстановления данных и риск потери файлов при аварийном отключении питания.

**Btrfs** или **B-Tree File System** легко администрируется, обладает высокой отказоустойчивостью и производительностью. Используется как файловая система по умолчанию в OpenSUSE и SUSE Linux.

Другие ФС, такие как NTFS, FAT, HFS, могут использоваться в Linux, но корневая файловая система на них не устанавливается, поскольку они для этого не предназначены.

### Точки монтирования

Linux не назначает буквы каждому диску и разделу, как в Windows и DOS. Вместо этого вы должны задать точку монтирования для каждого диска и раздела. Linux работает по принципу иерархического дерева каталогов, где корневой каталог ( / ) является основной точкой монтирования, в которую по умолчанию входят все остальные. В отличии от Windows в Linux все используемые разделы дисков монтируются в подкаталоги корня, а не как отдельные устройства (C:, D: …). К примеру, в _/home_ хранятся все ваши персональные файлы. Если вы хотите разместить эти данные в отдельном от корня разделе, то создадите новый раздел и установите точку монтирования на _/home_. Это можно сделать для любого подкаталога. Например во время установки Ubuntu у вас возможность задать следующие точки монтирования: _/boot_ (начальный загрузчик и заголовки ядра), _/dev_ (драйверы и устройства), _/home_ (пользовательские файлы), _/opt_ (дополнительное программное обеспечение), _/srv_ (системные сервисы) _/tmp_ (временные файлы), _/usr_ (приложения), _/usr/local_ (данные, доступные всем пользователям) и _/var_ (server spool и логи). Также при установке можно создать и свои точки монтирования с произвольными именами. Для типичной настольной системы нет никакого смысла выделять собственные разделы для _/dev_, _/opt_, _/srv_, _/tmp_, _/usr/local_ и _/var_. Если вы планируете запускать более двух операционных систем или использовать шифрование корневого раздела, то возможно потребуется отдельный раздел для _/boot_. Иногда стоит также создать раздел для _/usr_, но только если вы уже имеете чёткое представление о том, сколько места займут приложения. Желательно создать отдельный раздел для _/home_. Это предоставит вам дополнительные удобства при обновлении и переустановке системы.

Минимально можно ограничится только двумя разделами: «root» и «swap», тогда _/boot_, _/home_, _/usr_ и все остальные будут просто храниться в корневом разделе ( / ).

Вернемся к процессу установки. Когда вы закончите с разметкой диска, останется лишь создать нового пользователя и дождаться завершения установки. Теперь можно приступать к работе с системой.

### Настройка сети

Прежде чем Вы начнете, убедитесь, что:

- Различные сетевые утилиты, предназначенные для автоматического конфигурирования сети выключены. .
- Различные сетевые фильтры (например iptables), и утилиты их конфигурирования (например, Firestarter) отключены/правильно настроены и не вмешиваются в работу сети.
- У Вас есть все необходимые параметры для подключения в Вашей сети (например, IP-адрес, маска подсети и шлюз по умолчанию для соединения с использованием статического IP).
- Устройства сети осуществляющие фильтрацию по MAC-адресу правильно настроены и «знают» Ваш сетевой интерфейс.
- Драйвер Вашего сетевого устройства корректно установлен, кабель (при проводном соединении) исправен и подсоединен.

Для настроек вам обязательно потребуется имя вашего сетевого адаптера. Его можно узнать из вывода команды:

`$ sudo lshw -C network`

Она позволяет посмотреть подключенные сетевые устройства.

Пример вывода команды:

```
ubuntu@ubuntu:~$ sudo lshw -C network
  *-network
       description: Ethernet interface                 # Тип устройства
       product: L2 100 Mbit Ethernet Adapter           # Название адаптера
       vendor: Attansic Technology Corp.               # Производитель устройства
       physical id: 0
       bus info: pci@0000:03:00.0
       logical name: eth0                              # Имя сетевого интерфейса
       version: a0
       serial: 00:00:00:00:00:00                       # Физический mac-адрес устройства
       size: 100MB/s
       capacity: 100MB/s
       width: 64 bits
       clock: 33MHz
       capabilities: pm msi pciexpress vpd bus_master cap_list
ethernet physical tp 10bt 10bt-fd 100bt 100bt-fd autonegotiation
       configuration: autonegotiation=on broadcast=yes
                      driver=atl2                                 # Используемый драйвер
                      driverversion=2.2.3                         # Версия драйвера
                      duplex=full firmware=L2 ip=192.168.0.5 latency=0
                      link=yes                                     # Наличие линка
                      module=atl2 multicast=yes port=twisted pair
                      speed=100MB/s                      # Текущая скорость подключения.
```

Обратите внимание на строку:

```
 logical name: eth0
```

eth0 - это и есть искомое имя сетевого интерфейса.

Имя `eth0` будет далее применяться для настройки именно данной сетевой карты. Где `eth` обозначает что используется Ethernet интерфейс, а `0` - номер устройства. Если у вас установлено несколько сетевых устройств, то, соответственно, им будут присвоены имена: `eth0`, `eth1`, `eth2` и т.д.

Давайте посмотрим, какие сетевые интерфейсы подключены к системе. Есть несколько способов это сделать, ниже приведены два (команда ip link show и команда ifconfig):

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/a9f1a61a-7a56-46b0-8fee-afea0ca4b0bb/Untitled.png)

Видим, что у нас два сетевых интерфейса - enp0s3 (физический интерфейс, который мы и будем настраивать) и lo (loopback, виртуальный интерфейс, указывающий на нашу машину)

Настройки сети находятся в файле /etc/network/interfaces. Откроем его с помощью текстового редактора (например nano)

```jsx
$ nano /etc/network/interfaces
```

Нас будут интересовать в этом файле строчки auto и iface. Первая указывает, что нужно активировать интерфейс при загрузке, вторая же определяет настройки самого интерфейса.

### Настройка динамического получения IP-адреса

Добавьте в файл следующие строки, чтобы запускать интерфейс при загрузке и получать IP-адрес автоматически по DHCP:

`auto enp0s3 iface enp0s3 inet dhcp`

Синтаксис строки auto прост. Он состоит из самой команды и имени сетевого интерфейса. Рассмотрим подробнее:

**iface интерфейс inet тип**

Тип получения IP-адреса может иметь несколько значений, но нас в этой статье будут интересовать только два: dhcp и static.

После завершения настройки сохраните файл (для этого используйте комбинацию клавиш ctrl + 0, подтвердите путь, по которому вы сохраняете файл, и затем ctrl + x для выхода из текстового редактора) и перезапустите сетевой сервис:

`sudo service networking restart`

Всё, если сетевой кабель подключён, и вы всё сделали правильно, Сеть будет работать.

### Настройка статического адреса

При настройке статического IP-адреса компьютер не будет связываться с DHCP-сервером, поэтому здесь придётся указать намного больше параметров.

Содержимое нашего конфигурационного файла будет выглядеть вот так:

```jsx
auto eth0
iface eth0 inet static
address 192.168.1.7
gateway 192.168.1.1
netmask 255.255.255.0
network 192.168.1.0
broadcast 192.168.1.255
```

С первыми двумя строчками все понятно, а следующие задают параметры настройки интерфейса:

- **address** - наш IP-адрес;
- **gateway** - шлюз, через который будем получать доступ в интернет;
- **netmask** - маска сети;
- **network** - адрес сети, имеет тот же адрес, что и шлюз, только с нулем вместо единицы;
- **broadcast** - широковещательный адрес сети, отправленный на него пакет придет всем компьютерам локальной сети.

Как видите, network и broadcast - это первый и последний IP-адреса сети. Теперь сохраните файл и перезапустите сеть:

`sudo service networking restart`

Если все параметры были указаны правильно, всё будет работать. Но если допущена хоть одна ошибка, доступ к сети вы не получите.

### Настройка сети с использованием команды ip

Для начала, как и в предыдущем примере, смотрим сетевые интерфейсы. Узнав название нашего интерфейса, следует его включить. Для этого выполняем такую команду:

`sudo ip link set enp0s3 up`

Затем с помощью команды **dhclient** запрашиваем ip:

`sudo dhclient enp0s3`

Готово, теперь остается лишь настроить DNS, но сначала рассмортим пример со статическим ip.

Первым делом опять же включаем интерфейс (см. выше). Затем устанавливаем IP-адрес, маску сети и broadcast-адрес для нашего интерфейса:

`sudo ip addr add 192.168.1.7/255.255.255.0 broadcast 192.168.1.255 dev enp0s3`

Указываем IP-адрес шлюза:

`sudo ip route add default via 192.168.1.1`

Здесь 192.168.1.7 - наш IP-адрес, 255.255.255.0 - маска сети, 192.168.1.255 - широковещательный адрес. Замените эти значения на свои.

Теперь можем пропинговать какой либо адрес в сети, к примеру 8.8.8.8 (ip - адрес Google):

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/420d0d36-bcaf-4ff4-9643-441a5c2bffd3/Untitled.png)

Отлично, перейдем к настройке DNS.

Служба DNS используется для преобразования доменных имен сайтов в IP-адреса. При получении IP-адреса автоматически через DHCP мы используем правильные DNS-серверы, но если мы выбрали статический IP, то DNS можно и не получить, поэтому придётся сделать всё вручную. Для этого откройте файл /etc/network/interfaces и добавьте в него строчку:

`dns-nameservers 8.8.8.8 4.4.4.4`

Здесь 8.8.8.8 и 4.4.4.4 это IP-адреса DNS серверов, можете заменить их на свои. И можно использовать один, а не два. Дальше сохраните файл и перезапустите сеть:

`sudo service networking restart`

На этом базовые настройки сети можно считать выполненными.

### Создание привилегированного пользователя

Ещё одним этапом базовой настройки системы является создание пользователя, который обладает привилегиями root. Разделение привилегий — одна из основных парадигм безопасности в операционных системах семейства Linux и Unix, и более подробно эта тема будет рассмотрена через несколько абзацев, а пока нам нужно понять, что обычные пользователи работают с ограниченными привилегиями и могут влиять только на собственную рабочую среду, но не на операционную систему в целом.

Специальный пользователь с именем **root**, имеет привилегии _суперпользователя_. Это административная учетная запись без ограничений, действующих для обычных пользователей. Пользователи могут выполнять команды с привилегиями суперпользователя или **root** разными способами.

Постоянно использовать учётную запись root не рекомендуется, поскольку, имея абсолютные права доступа, можно совершенно случайно нанести системе непоправимый вред. Поэтому в системе существует команда su (сокращение от substitute user), позволяющая обычному пользователю получать root-права в любой момент.

Итак, чтобы получить root-права, просто введите:

`su`

Система запросит пароль root-пользователя, после чего откроет доступ к сессии оболочки root-пользователя.

Выполнив все задачи, требующие прав root, можно вернуться в предыдущую сессию:

`exit`

Другой способ получения привилегий root – команда sudo.

Команда sudo позволяет выполнять отдельные команды с правами root без необходимости открывать новую сессию.

`sudo command_to_execute`

В отличие от su, команда sudo запрашивает не пароль root, а пароль пользователя, который вызывает команду.

Первое, что стоит сделать с командой sudo - отучить её от плохой привычки запоминать наш пароль. По умолчанию sudo запоминает ваш пароль в течение 15 минут после его ввода. Вот почему вам нужно ввести пароль только один раз при быстром выполнении нескольких команд с помощью sudo. Если вы собираетесь позволить кому-то другому использовать ваш компьютер и хотите, чтобы sudo запрашивал пароль при следующем запуске, выполните следующую команду:

```jsx
$ sudo -k
```

Если вы предпочитаете получать подсказки при каждом использовании sudo - например, если другие люди регулярно имеют доступ к вашему компьютеру - вы можете полностью отключить запоминание пароля. Все настройки sudo находятся в файле /etc/sudoers. Здесь можно настроить очень много параметров, начиная от кому будет позволено выполнять команды от имени суперпользователя и заканчивая ограничением набора доступных команд.

Чтобы открыть файл для редактирования наберите такую команду от имени суперпользователя:

`visudo`

Откроется специальный редактор, отличительная особенность которого в том, что при сохранении он проверяет, соответсвует ли файл установленному формату (в противном случае отменяет изменения).

Рассмотрим его содержимое:

```
Defaults        env_reset
Defaults        mail_badpass
Defaults        secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"

root    ALL=(ALL:ALL) ALL

%admin ALL=(ALL) ALL
%sudo   ALL=(ALL:ALL) ALL

#includedir /etc/sudoers.d
```

### Строки по умолчанию

Первая строка Defaults env_reset сбрасывает среду терминала для удаления переменных пользователя. Эта мера безопасности используется для сброса потенциально опасных переменных среды в сеансе `sudo`.

Вторая строка, `Defaults mail_badpass`, предписывает системе отправлять уведомления о неудачных попытках ввода пароля `sudo` для настроенного пользователя `mailto`. По умолчанию это учетная запись **root**.

Третья строка, начинающаяся с “Defaults secure_path=…”, задает переменную `PATH` (места в файловой системе, где операционная система будет искать приложения), которая будет использоваться для операций `sudo`. Это предотвращает использование пользовательских путей, которые могут быть вредоносными.

### Строки пользовательских привилегий

Четвертая строка, которая определяет для пользователя **root** привилегии `sudo`, отличается от предыдущих строк. Давайте посмотрим, что означают различные поля:

- `root ALL=(ALL:ALL) ALL` Первое поле показывает имя пользователя, которое правило будет применять к (**root**).
- `root ALL=(ALL:ALL) ALL` Первое “ALL” означает, что данное правило применяется ко всем хостам.
- `root ALL=(ALL:ALL) ALL` Данное “ALL” означает, что пользователь **root** может запускать команды от лица всех пользователей.
- `root ALL=(ALL:ALL) ALL` Данное “ALL” означает, что пользователь **root** может запускать команды от лица всех групп.
- `root ALL=(ALL:ALL) ALL` Последнее “ALL” означает, что данные правила применяются всем командам.

Это означает, что наш пользователь **root** сможет выполнять любые команды с помощью `sudo` после ввода пароля.

Соответственно, для того чтобы дать пользователю права на исполнение команд от имени root, нужно добавить следующую строку:

```jsx
username  ALL=(ALL) ALL
```

Для отключения запоминания пароля добавьте следующую строку под другими строками defaults:

```jsx
defaults timestamp_timeout = 0
```

Это лишь малая часть настроек команды sudo, помимо этого вы можете изменить время ожидания пароля, включить функцию “никогда не спрашивать пароль”, настроить запуск определенных команды без пароля, разрешить пользователю запускать только определенные команды, сделать логирование доступа к sudo и т.д.

# Модель прав доступа

Многопользовательская архитектура - одна из первых особенностей Linux, которая существует еще с зарождения системы. В системе могут работать одновременно множество пользователей благодаря удаленному входу, а также пользователи используются для запуска определенных сервисов. Основу управления правами доступа в Linux и уровнем привилегий в Linux составляют именно пользователи. Изначально, еще при проектировании системы существовал пользователь root, которому позволено выполнять любые действия и другие пользователи, права которых настраиваются с помощью вступления их в группы Linux [](https://losst.ru/gruppy-polzovatelej-linux)и установки прав на каталоги.

### Создание пользователей

Вся информация о пользователях находится в файле /etc/passwd. Мы могли бы создать пользователя linux просто добавив его туда, но так делать не следует, поскольку для этой задачи существуют специальные утилиты. Одна из таких утилит, это useradd. Это довольно простая команда, которая есть во всех дистрибутивах Linux. Она позволяет зарегистрировать нового пользователя или изменить информацию об уже имеющемся. Во время создания можно даже создать домашний каталог пользователя и скопировать в него системные файлы. Рассмотрим синтаксис команды:

```
$ sudo useradd [options] username
```

Все довольно просто, дальше нам нужно рассмотреть основные опции команды, с помощью которых вы будете настраивать нового пользователя:

- **b** - базовый каталог для размещения домашнего каталога пользователя, по умолчанию /home;
- **c** - комментарий к учетной записи;
- **d** - домашний каталог, в котором будут размещаться файлы пользователя;
- **e** - дата, когда учетная запись пользователя будет заблокирована, в формате ГГГГ-ММ-ДД;
- **f** - заблокировать учетную запись сразу после создания;
- **g** - основная группа пользователя;
- **G** - список дополнительных групп;
- **k** - каталог с шаблонами конфигурационных файлов;
- **l** - не сохранять информацию о входах пользователя в lastlog и faillog;
- **m** - создавать домашний каталог пользователя, если он не существует;
- **M** - не создавать домашнюю папку;
- **N** - не создавать группу с именем пользователя;
- **o** - разрешить создание пользователя linux с неуникальным идентификатором UID;
- **p** - задать пароль пользователя;
- **r** - создать системного пользователя, не имеет оболочки входа, без домашней директории и с идентификатором до SYS_UID_MAX;
- **s** - командная оболочка для пользователя;
- **u** - идентификатор для пользователя;
- **D** - отобразить параметры, которые используются по умолчанию для создания пользователя. Если вместе с этой опцией задать еще какой-либо параметр, то его значение по умолчанию будет переопределено.

Для того чтобы создать минимального пользователя с минимальными настройками и именем test:

```
$ sudo useradd test
```

Усложним задачу и создадим пользователя с паролем и оболочкой /bin/bash:

```
$ sudo useradd -p password -s /bin/bash test1
```

Для того чтобы получать доступ к системным ресурсам пользователю нужно быть участником групп, у которых есть доступ к этим ресурсам. Дополнительные группы пользователя задаются с помощью параметра -G. Например, разрешим пользователю читать логи, использовать cdrom и пользоваться sudo:

```
$ sudo useradd -G adm,cdrom,wheel -p password -s /bin/bash test2
```

Также, можно установить дату, когда аккаунт пользователя будет отключен автоматически, это может быть полезно для пользователей, которые будут работать временно:

```
$ sudo useradd -G adm,cdrom,wheel -p password -s /bin/bash -e 01:01:2018 test2
```

Для того чтобы создать пользователя с правами root, нужно разрешить создавать пользователя с неуникальным uid, установить идентификатор в 0 и идентификатор основной группы тоже в 0. Команда будет выглядеть вот так:

```
$ sudo useradd -o -u 0 -g 0 -s /bin/bash newroot
```

Команда для изменения данных пользователя - usermod. Поскольку вы имеете дело с управлением учетными записями пользователей, вы должны иметь права root или sudo для запуска команды usermod.

Синтаксис

```
$ sudo usermod [options] username
```

Изменить имя пользователя с помощью опции -l:

```
$ sudo usermod -l new_username old_username
```

Имейте в виду, что кроме имени пользователя, ничего не меняется само по себе. Вам придется вручную изменить домашний каталог и почтовую папку.

Изменить домашний каталог пользователя на другой каталог:

```
$ sudo usermod -d new_home_dir user_name
```

Имейте в виду, что он изменит домашний каталог, даже если каталог не существует, но он не будет создавать его самостоятельно.

Наиболее распространенное использование команды usermod - добавление пользователей в другие группы. Если вы хотите добавить пользователя в список sudoer, все, что вам нужно сделать, это добавить пользователя в группу sudo.

```
$ sudo usermod -aG group_name username
```

Вы заметили, что мы использовали здесь опцию -aG, а не только -G. Это потому, что если вы используете только опцию -G, она заменит пользовательские группы новой группой, которую вы указали.

Вот почему вы должны использовать опцию добавления -a, чтобы пользователь был добавлен в новую группу дополнительно, а не удален из ее предыдущих групп.

Вы можете заблокировать учетную запись пользователя в Linux с помощью опции команды usermod -L. Заблокированный пользователь не может войти в систему.

```
$ sudo usermod -L username
```

Вы также можете разблокировать пользователя с помощью опции -U:

```
$ sudo usermod -U username
```

Чтобы установить срок действия для учетной записи пользователя, вы можете использовать опцию -e с датой в формате YYYY-MM-DD.

```
$ sudo usermod -e 2020-04-01 username
```

Вы можете изменить UID (идентификатор пользователя) пользователя с помощью опции -u:

```
$ sudo usermod -u UID username
```

### Смена пароля

Пароли пользователей хранятся в отдельном файле /etc/shadow. Этот файл можно открыть только с правами суперпользователя, и, более того, пароли здесь хранятся в зашифрованном виде, поэтому узнать пароль Linux не получится.

В большинстве случаев смена пароля выполняется с помощью утилиты **passwd**. Это очень мощная утилита, она позволяет не только менять пароль, но и управлять сроком его жизни. У неё такой синтаксис:

```
$ passwd [options] username
```

Рассмотрим опции, чтобы лучше ориентироваться в использовании утилиты:

- **d** - удалить пароль пользователя, после этого он не сможет войти
- **e** - сделать пароль устаревшим
- **i** - через сколько дней после того, как пароль устарел, отключить аккаунт, если пользователь не сменил пароль
- **l** - запретить пользователю входить в систему
- **n** - минимальное количество дней между сменами пароля
- **S** - отобразить информацию об аккаунте
- **u** - отменяет действие параметра **l**
- **x** - максимальное количество дней, пока пароль можно использовать.
- **w** - количество дней, после которых нужно предупреждать пользователя о том, что надо сменить пароль.

Вы можете сменить свой пароль, когда захотите. Для этого вам не нужно особых прав суперпользователя, только знать свой текущий пароль. Просто откройте терминал и выполните утилиту **passwd** без параметров. Далее следует ввести текущий пароль, затем новый.

Пароль кодируется с помощью необратимого шифрования и сохраняется в файле /etc/shadow. Но заметьте, что вы не можете использовать здесь любой пароль. Система Linux заботится о том, чтобы пользователи выбирали достаточно сложные пароли. Если он будет очень коротким или будет содержать только цифры, вы не сможете его установить.

Общие требования для пароля такие: должен содержать от 6 до 8 символов, причём один или несколько из них должны относиться как минимум к двум из таких множеств:

- Буквы нижнего регистра
- Буквы верхнего регистра
- Цифры от нуля до девяти
- Знаки препинания и знак

Вы можете удалить пароль Linux для пользователя, тогда он не сможет войти в систему:

```
$ sudo passwd -d user
```

Наверное вы видели в своей системе файл /etc/gshadow. Этот файл эквивалентен /etc/shadow, только содержат пароли для групп. Вы не можете войти от имени группы, но зато, зная её пароль, можете получить доступ к предоставляемым ею функциям в отдельной командной оболочке с помощью команды **newgrp.**

Для установки пароля на группу используется утилита очень похожая на passwd - **gpasswd**. Естественно, нам нужны права суперпользователя. Например:

```
$ sudo gpasswd disk
```

Если вы администратор, у вас есть возможность заставить пользователей выполнять смену пароля время от времени, а также автоматически отсылать им предупреждения о том, что пора сменить пароль пользователя Linux.

Всё это позволяет сделать утилита **passwd**. Сначала давайте рассмотрим, как посмотреть информацию о пароле в **passwd**. Для этого используется опция **-S**:

```
$ passwd -S user
$ user P 10/10/2010 0 99999 7 -1
```

- Первое поле - имя пользователя
- Второе поле показывает одно из значений: **P** - пароль установлен, **L** - пользователь заблокирован, **NP** - пароля нет.
- **10/10/2010** - дата последнего изменения пароля.
- **0** - минимальное время до смены пароля
- **99999** - максимальное время действия пароля
- **7** - за сколько дней нужно предупреждать об истечении срока действия пароля
- **1** - через сколько дней пароль нужно деактивировать.

Например, чтобы через тридцать дней после смены пароль пользователя стал устаревшим испольузется команда:

```
$ sudo passwd -x 30 user
```

Пароль для root пользователя меняется аналогично, нужны лишь права суперпользователя.

### /etc/passwd

/etc/passwd представляет собой простую текстовую базу данных, которая содержит информацию обо всех учетных записях пользователей в системе. Она принадлежит пользователю root и имеет разрешение 644 (о значении этих цифр вы узнаете чуть позже). Файл может быть изменен только пользователем root или пользователями с правами sudo и доступен для чтения всем пользователям системы.

Обычно первая строка описывает пользователя root, за которым следуют системные и обычные учетные записи пользователей. Новые записи добавляются в конец файла.

Каждая строка файла /etc/passwd содержит семь полей:

1. Username. Строка, которую вы вводите при входе в систему. Каждое имя пользователя должно быть уникальной строкой на компьютере. Максимальная длина имени пользователя ограничена 32 символами.
2. Password. В старых системах Linux зашифрованный пароль пользователя хранился в файле /etc/passwd. В большинстве современных систем это поле имеет значение x, и пароль пользователя сохраняется в файле /etc/shadow.
3. UID. Идентификатор пользователя – это номер, назначенный каждому пользователю. Он используется операционной системой для обращения к пользователю.
4. GID. Номер идентификатора группы пользователя, относящийся к основной группе пользователя. Когда пользователь создает файл, группа файла устанавливается на эту группу. Как правило, имя группы совпадает с именем пользователя. Пользователя вторичные группы перечислены в файле /etc/groups.
5. GECOS или полное имя пользователя. Это поле содержит список значений через запятую со следующей информацией:
    - Полное имя пользователя или название приложения.
    - Номер комнаты.
    - Рабочий номер телефона.
    - Домашний телефон.
    - Другая контактная информация.
6. Home directory. Абсолютный путь к домашнему каталогу пользователя. Он содержит файлы пользователя и конфигурации. По умолчанию домашние каталоги пользователей именуются по имени пользователя и создаются в каталоге /home.
7. Login shell. Абсолютный путь к оболочке входа пользователя. Это оболочка, которая запускается, когда пользователь входит в систему. В большинстве дистрибутивов Linux оболочкой входа по умолчанию является [Bash](https://andreyex.ru/tag/bash).

### /etc/shadow

Это зашифрованный файл паролей, в котором хранится зашифрованная информация о паролях для учетных записей пользователей. В дополнение к хранению зашифрованного пароля файл **/etc/shadow** хранит дополнительную информацию о сроке действия или истечении срока действия пароля. Появление **теневого** файла (shadow) произошло из-за необходимости отделить зашифрованные пароли от файла **/etc/passwd**. Это было необходимо, потому что легкость, с которой можно было взломать зашифрованные пароли, росла с увеличением вычислительной мощности обычных компьютеров (домашних ПК). Идея заключалась в том, чтобы сделать файл **/etc/passwd** доступным для чтения всем пользователям, не сохраняя в нем зашифрованные пароли, а затем сделать **/etc/shadow** файл доступным для чтения только root или другим привилегированным программам, которым требуется доступ к этой информации. Примером такой программы может быть программа _входа_  в _систему_.

Как и в **файле /etc/passwd**, каждая строка в **файле /etc/shadow** представляет информацию о пользователе. Строки состоят из различных стандартных полей, показанных ниже, каждое из которых разделено двоеточием:

1. Логин
2. Зашифрованный пароль
3. Количество дней, прошедших с 1 января 1970 г., когда последний раз меняли этот пароль.
4. Дней до того, как пароль может быть изменен
5. Кол-во дней, по истечении которых пароль необходимо изменить
6. За сколько дней до истечения срока действия пароля пользователь получает предупреждение
7. Через сколько дней после истечения срока действия пароля эта учетная запись будет отключена
8. Дней с 1 января 1970 г., когда эта учетная запись была отключена
9. Зарезервированное поле

Здесь показан образец записи из файла **/etc/shadow** для учетной записи пользователя MrRobot*:*

```
MrRobot:$l$HEWdPIJ.$qX/RbB.TPGcverAVDlF4g.:12830:0:99999:7:::
```

Зашифрованный пароль соответсвует формату $type$salt$hashed. где $type является методом криптографического алгоритма хеширования и может иметь следующие значения:

- $1$ – MD5
- $2a$ – Blowfish
- $2y$ – Eksblowfish
- $5$ – SHA-256
- $6$ – SHA-512

Если поле пароля содержит звездочку ( *) или восклицательный знак ( !), пользователь не сможет войти в систему с использованием аутентификации по паролю. Другие методы входа, такие как аутентификация на основе ключей или переключение на пользователя, по-прежнему разрешены.

### Права доступа

Согласно модели прав доступа, каждый файл в Linux системах принадлежит одному пользователю и одной группе. Вы можете узнать, какому пользователю и группе принадлежит файл в выводе команды ls -l “путь к файлу”. Он выглядит следующим образом:

```
$ ls -l /bin/bash

$ -rwxr-xr-x l root wheel 430540 Oct 23 19:24 /bin/bash
```

В данном случае мы получили информацию о том, что исполняемый файл /bin/bash принадлежит пользователю root и группе wheel. Модель прав доступа позволяет задать три независимых уровня прав на каждый объект файловой системы — для владельца, для группы и для всех остальных пользователей. Резберем подробнее. Первый знак (-) содержит информацию о типе файла, в данном случае значение “-” свидетельствует о том что перед нами обычный файл. Другие возможные значения:

```
'd' директория

'l' символическая ссылка

'c' устройство символьного ввода-вывода

'b' устройство блочного ввода-вывода

'p' FIFO

's' сокет
```

Оставшиеся до пробела символы определяют какие действия те или иные пользователи могут совершать с файлом. Для удобства восприятия перепишем 2-10 символы, разбив их на тройки:

```
rwx | r-x | r-x
```

Три блока соответсвуют трем типам пользователей. Первый блок - права владельца файла, второй - группы файла, третий - все остальные. В нашем случае владелец файла имеет право на чтение (r - read), запись (w - write), исполнение (x - execute). Оставшиеся два блока отличаются лишь тем, что вместо права записи стоит знак “-”, что говорит о том что данного права у пользователя нет. Таким образом, группа файла и все остальные пользователи могут читать и испольнять файл, однако им не доступна редакция файла. Обратите внимание, что права всегда идут в таком порядке - чтение | запись | исполнение.

Чтобы узнать, под каким пользователем вы сейчас работаете, используйте команду whoami. Для вывода информации о группах, которым вы принадлежите - команда groups. Если вы хотите посмотреть, в каких группах состоит другой пользователь, то передайте его имя в качестве аргумента

```
$ groups root daemon

root : root bin daemon sys adm disk wheel floppy dialout tape video

daemon : daemon bin adm
```

Чтобы изменить владельца или группу файла (или другого объекта) используется команды _chown_ или _chgrp_ соответственно. Сначала нужно передать имя группы или владельца, а потом список файлов.

```
# chown root /etc/passwd
# chgrp wheel /etc/passwd
```

Вы также можете изменить пользователя и группу одновременно используя команду _chown_ в другой форме:

```
# chown root:wheel /etc/passwd
```

Вы не можете использовать команду _chown_ без прав суперпользователя, но _chgrp_ может быть использована всеми, чтобы изменить группу-владельца файла на ту группу, к которой они принадлежат.

### Рекурсивное изменение прав

Команды _chown_ и _chgrp_ могут быть использованы с параметром -R, что позволяет рекурсивно изменить владельца или группу у всех объектов в данной директории и ниже. Пример:

```
# chown -R drobbins /home/drobbins
```

### Знакомство с chmod

C_hown_ и _chgrp_ используются для изменения владельца и группы объекта файловой системы, но кроме них существует и другая программа, называемая _chmod_, которая используется для изменения прав доступа на чтение, запись и исполнение, которые мы видим в выводе команды _ls -l._

C_hmod_ использует два и более аргументов: метод, описывающий как именно необходимо изменить права доступа с последующим именем файла или списком файлов, к которым необходимо применить эти изменения:

```
$ chmod +x **"имя файла"**
```

В примере выше в качестве метода указано +x. Метод +x указывает _chmod_, что файл необходимо сделать исполняемым для пользователя, группы и для всех остальных. Если мы решим отнять все права на исполнение файла, то сделаем вот так:

```
$ chmod -x **"имя файла"**
```

Чтобы изменить права для конкретного типа пользователя, а не для всех, используйте перед -x специальный символ обозначения категории пользователей, который вам необходимо изменить, со знаком + или - перед ним. Используйте u для пользователя, g для группы и o для остальных пользователей.

```
$ chmod go-w **"имя файла"**
```

Командой выше мы удалили право на запись для группы и всех остальных пользователей, но оставили права владельца нетронутыми.

Помимо переключения бит, отвечающих за права доступа, в состояние вкл/выкл, мы можем задать конкретные значения для всех сразу. Используя оператор равенства мы можем указать _chmod_, что хотим задать только указанные права доступа:

```
$ chmod =rx **"имя файла"**
```

Этой командой мы установили все биты чтения и исполнения и сбросили все биты записи. Если вы хотите задать значения конкретной тройки бит, то можете сделать это, указав ее символьное наименование перед оператором равенства:

```
$ chmod u=rx **"имя файла"**
```

### Числовые режимы

До сих пор, мы использовали то что называется символическим способом указания прав доступа для команды _chmod_. Однако есть еще один достаточно распространенный способ указания прав: использование четырехзначных восьмеричных чисел. Этот синтаксис, называется числовым синтаксисом прав доступа, где каждая цифра представляет тройку разрешений. Эта таблица показывает как транслируются права доступа на числовые значения.

**`Режим Число`**

```
rwx     7
rw-     6
r-x     5
r--     4
-wx     3
-w-     2
--x     1
---     0
```

### Числовой синтаксис прав доступа

Числовой синтаксис прав доступа особенно полезен когда требуется указать все разрешения для файла, как показано в следующем примере:

```
$ chmod 0755 **"имя файла"**
```

В этом примере мы назначили права доступа 0755, что равносильно комбинации прав -rwxr-xr-x.

### **suid и sgid**

Расшифровываются эти аббревиатуры как _Set User Identifier_ и _Set Group Identifier_ соответственно. Так называются биты, указывающие особые права доступа к файлам и каталогам, наряду с обычными правами – _rwx_. Проверить наличие такого бита можно с помощью команды ls -l. Если бит установлен, то в выводе вы увидите такую картину:

```
$ -rwxr-***s***r-x  1 root ...
```

Кроме привычных _rwx_ в описании прав доступа к файлу присутствует буква _**s**_ – это и есть идентификатор установленного **SUID** на этот файл.

Зачем нужны SUID и SGID? Есть достаточно много программ и файлов, которые должны принадлежать пользователю root, и в то же время – простые пользователи должны иметь возможность выполнять его. Для примера – утилита passwd (предназначена для управления паролями пользователей), которая находится в каталоге _/usr/bin/passwd_ и которая имеет дело с файлом _/etc/passwd_, редактировать который может только пользователь root. Для того, что бы дать пользователям возможность менять свои пароли – на файл утилиты установлен бит **suid**:

```
$ ls -l /usr/bin/passwd
$ -rw**s**r-xr-x 1 root root 41284 2011-06-24 12:36 /usr/bin/passwd
```

**Suid** даёт возможность на время выполнения файла (запущенного им процесса) непривелигированному пользователю получить права пользователя – владельца файла, в данном случае – root.

Бит **sgid** аналогичен **suid**, но устанавливаются права не пользователя файла, а группы – владельца файла. Так же, все файлы, создаваемые в каталоге с установленным **sgid** будут получать идентификатор группы – владельца каталога, а не владельца файла. Новые каталоги, создаваемые в каталоге с установленным **sgid** будут его наследовать от каталога-родителя.

Так же, следует учитывать, что **suid** установленный, установленный на файл перекрывает **sgid**, установленный на каталог.

### Изменение suid и sgid

Способ установки и удаления битов suid и sgid чрезвычайно прост. Вот так мы задаем бит suid:

```
# chmod u+s /usr/bin/myapp
```

А в следующем примере мы снимаем флаг sgid с директории. Вы увидите, как бит sgid работает с директориями немного ниже:

```
# chmod g-s /home/drobbins
```

### Права и директории

До текущего момента мы рассматривали права доступа с точки зрения обычных файлов. Когда речь заходит о директориях, появляются некоторые отличия. Директории используют те же флаги прав доступа, но их интерпретация имеет немного другой смысл.

Если для директории задан флаг чтения, то вы можете просматривать список содержимого директории; флаг записи означает, что вы можете создавать файлы в директории; и флаг исполнения означает, что вы можете войти в директорию и обращаться ко всем поддиректориям внутри. Без флага исполнения у вас не будет доступа к объектам файловой системы внутри директории. Без флага чтения объекты файловой системы внутри директории нельзя просмотреть, но к объектам внутри директории все еще можно обратиться, если вы знаете полный путь к объекту на диске.

### Директории и флаг sgid

В случае же, если для директории установлен бит sgid, все объекты файловой системы, создаваемые внутри, наследуют группу директории. Эта возможность бывает кстати, когда вам необходимо создать дерево директорий и все они должны принадлежать одной группе. Это можно сделать вот так:

```
# mkdir /home/groupspace

# chgrp mygroup /home/groupspace

# chmod g+s /home/groupspace
```

Теперь любые пользователи группы mygroup могут создавать файлы и директории внутри /home/groupspace и им также будет автоматически задана принадлежность группе mygroup.

### umask

Когда процесс создает новый файл, он указывает, какие права доступа нужно задать для данного файла. Зачастую запрашиваются права 0666 (чтение и запись всеми), что дает больше разрешений, чем необходимо в большинстве случаев. К счастью, каждый раз, когда в Linux создается новый файл, система обращается к параметру, называемому umask. Система использует значение umask чтобы понизить изначально задаваемые разрешения на что-то более разумное и безопасное. Вы можете просмотреть текущие настройки umask набрав _umask_ в командной строке:

```
$ umask

0022
```

В Linux-системах значением по умолчанию для umask является 0022, что позволяет другим читать ваши новые файлы (если они могут до них добраться), но не изменять их. Чтобы автоматически обеспечивать больший уровень защищенности для создаваемых файлов, можно изменить настройки umask:

```
$ umask 0077
```

Такое значение umask приведет к тому, что группа и прочие не будут иметь совершенно никаких прав доступа для всех, вновь созданных файлов. Итак, как работает umask? В отличие от «обычного» назначения прав доступа к файлу, umask задает какие права доступа должны быть отключены. Снова посмотрим на таблицу соответствия значений чисел и методов:

**`Режим Число`**

```
rwx     7
rw-     6
r-x     5
r--     4
-wx     3
-w-     2
--x     1
---     0
```

Воспользовавшись этой таблицей мы видим, что последние три знака в 0077 обозначают ---rwxrwx. Теперь вспомните, что _umask_ показывает системе, какие права доступа отключить. Совместив первое и второе становится видно, что все права для группы и остальных пользователей будут отключены, в то время как права владельца останутся нетронутыми. В зависимости от настроек umask для данного пользователя новые объекты файловой системы могут быть или не быть читаемыми, изменяемыми или исполняемыми другими пользователями группы mygroup.

## Сервисы

### Что такое сервисы в Linux

Сервисы или службы — это программы, которые работают в системе Linux в фоновом режиме. Обычно они запускаются при загрузке системы. Большинство сервисов необходимы для полноценной работы системы, то есть они являются своего рода кирпичиками, из которых строится работающая система.

При запуске системы загружается целый ряд сервисов, которые включены для автозагрузки. Сервисы работают пока система запущена, и выгружаются при выключении системы.

Чаще всего в Linux дистрибутивах для инициализации сервисов используется демон Systemd. К Systemd-дистрибутивам относятся Ubuntu, Debian, Linux Mint, Fedora, openSUSE, Solus и другие.

Есть дистрибутивы, которые не используют Systemd. Вместо Systemd могут использоваться такие системы инициализации, как Upstart, SysV.

В качестве примеров сервисов можно привести: веб-сервер Apache, Network Manager, файрвол Ufw и другие.

**Apache** — это кроссплатформенное программное обеспечение для гибкой настройки надежных веб-серверов. На базе Apache строится огромное количество веб-сервисов и сайтов.

Этот инструмент для создания серверов очень популярен в мире за счет высокого уровня безопасности и обширного количества модулей, которые можно подключить, чтобы упростить управление веб-ресурсами.

Apache считается свободным программным обеспечением, поэтому разрабатывается и поддерживается сообществом, а не отдельной компанией. Соответственно, и распространяется он бесплатно.

**TELNET** — сетевой протокол для реализации текстового терминального интерфейса по сети (в современной форме — при помощи транспорта TCP). Название «telnet» имеют также некоторые утилиты, реализующие клиентскую часть протокола. Выполняет функции протокола прикладного уровня модели OSI. Протокол telnet использовался для удалённого администрирования различными сетевыми устройствами и программными серверами, но уступил ssh из-за безопасности. Тем не менее может являться единственной возможностью взаимодействовать через cli с embedded systems, например, router, т.к. на них отсутствует ssh.

**SSH** (Secure Shell) - это сетевой протокол, который обеспечивает безопасное удаленное соединение между двумя системами. Системные администраторы используют утилиты SSH для управления компьютерами, копирования или перемещения файлов между системами. Поскольку SSH передает данные по зашифрованным каналам, безопасность находится на высоком уровне.

**FTP** (англ. File Transfer Protocol) — протокол передачи файлов по сети, появившийся в 1971 году задолго до HTTP и даже до TCP/IP, благодаря чему является одним из старейших прикладных протоколов. Изначально FTP работал поверх протокола NC (nc - реализация подключений и ожиданий входящих соединений, через TCP и UDP), на сегодняшний день широко используется для распространения ПО и доступа к удалённым хостам. В отличие от TFTP, гарантирует передачу (либо выдачу ошибки) за счёт применения квотируемого протокола.Протокол построен на архитектуре «клиент-сервер» и использует разные сетевые соединения для передачи команд и данных между клиентом и сервером. Пользователи FTP могут пройти аутентификацию, передавая логин и пароль открытым текстом.

**Samba** — это программа, которая позволяет компьютерам UNIX/Linux имитировать машины Windows. При помощи Samba компьютеры могут обмениваться файлами или управлять заданиями на печать как файл-серверы или серверы печати под Windows. Подобно операционной системе UNIX/Linux, на которой она работает, Samba представляет собой разработанное множеством программистов ПО с открытым исходным кодом. Протокол SMB используется Microsoft Windows 2000, NT и 95/98 для организации доступа к дискам и принтерам.

**SFTP** протокол передачи файлов по SSH, или безопасный протокол передачи файлов, — это отдельный протокол, поддерживающий SSH, который работает схожим образом, но использует защищенное подключение. Его преимуществом является возможность использования защищенного подключения для передачи файлов и просмотра файловой системы как на локальной, так и на удаленной системе.Практически во всех случаях использование SFTP будет более предпочтительным по сравнению с FTP из-за имеющихся у первого функций безопасности и возможности использования подключения SSH. FTP — это небезопасный протокол, который следует использовать в отдельных случаях или в сетях, которым вы доверяете.

Теперь рассмотрим **управление сервисами**.

### **systemd**

`*systemd` -* это система инициализации и системный диспетчер. Позволяет запускать/останавливать службы, а также следить за их состоянием (это лишь часть функционала systemd, помимо этого утилита предоставляет пользователю широкий инструментарий для контроля и тонкой настройки работы служб).

Чтобы запустить тот или иной сервис, воспользуйтесь следующей командой:

```jsx
$ sudo systemctl start application.service
```

Вместо “application” укажите сервис, который вы хотите запустить.

Суффикс .service указывает на то, чтобы вы работаете со службой, однако systemd достаточно умна чтобы знать, что вы хотите работать со службой при использовании команд по управлению службами, следовательно его можно опустить.

В следующем примере демонстрируется остановка службы, обратите внимание что суффикс отсутсвтует:

```jsx
$ sudo systemctl stop application
```

Чтобы перезапустить работающую службу, можно использовать команду `restart`:

```
$ sudo systemctl restart application
```

Если данное приложение может перезагрузить файлы конфигурации (без перезапуска), вы можете выдать команду `reload` для инициализации этого процесса:

```
$ sudo systemctl reload application
```

Если вы не уверены, есть ли у службы функция перезагрузки своей конфигурации, можно использовать команду `reload-or-restart`. Это перезагрузит необходимую конфигурацию при наличии. В противном случае будет перезагружена служба для выбора новой конфигурации:

```jsx
$ sudo systemctl reload-or-restart application
```

Указанные выше команды полезны для запуска или остановки служб во время текущего сеанса. Чтобы дать команде `systemd` автоматически запускать службы при загрузке, их необходимо включить. Для запуска службы во время загрузки используйте команду `enable`:

```
$ sudo systemctl enable application
```

При этом будет создана символическая ссылка из системной копии служебного файла (обычно в `/lib/systemd/system` или `/etc/systemd/system`) в месте на диске, где `systemd` ищет файлы для автозапуска.

Чтобы отключить автоматический запуск службы, можно ввести следующее:

```
$ sudo systemctl disable application
```

При этом будет удалена символическая ссылка, что укажет на то, что служба не должна запускаться автоматически.

Помните, что включение службы не запустит ее в текущем сеансе. Если вы хотите запустить службу и включить ее при загрузке, необходимо дать обе команды, `start` и `enable`.

### Проверка статуса служб

Чтобы проверить статус службы в вашей системе, можно использовать команду `status`:

```
$ systemctl status application.service
```

При этом вы получите статус службы, иерархию контрольных групп и первые несколько строк журнала.

Например, при проверке статуса сервера Nginx вы можете видеть следующий вывод:

```
Output
● nginx.service - A high performance web server and a reverse proxy server
   Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled)
   Active: active (running) since Tue 2015-01-27 19:41:23 EST; 22h ago
 Main PID: 495 (nginx)
   CGroup: /system.slice/nginx.service
           ├─495 nginx: master process /usr/bin/nginx -g pid /run/nginx.pid; error_log stderr;
           └─496 nginx: worker process
Jan 27 19:41:23 desktop systemd[1]: Starting A high performance web server and a reverse proxy server...
Jan 27 19:41:23 desktop systemd[1]: Started A high performance web server and a reverse proxy server.

```

Это дает вам хороший обзор текущего статуса приложения и уведомляет о наличии каких-либо проблем или необходимости выполнения каких-либо действий.

### Обзор состояния системы

Команды до сих пор были полезны для управления отдельными службами, но они не очень подходят для понимания текущего состояния системы. Существует ряд команд `systemctl`, предоставляющих эту информацию.

Чтобы увидеть список всех активных модулей, о которых знает `systemd`, можно использовать команду `list-units`:

```
$ systemctl list-units
```

Это покажет вам список всех модулей, которые у `systemd` активны в системе. Результат будет выглядеть примерно так:

```
Output
UNIT                                      LOAD   ACTIVE SUB     DESCRIPTION
atd.service                               loaded active running ATD daemon
avahi-daemon.service                      loaded active running Avahi mDNS/DNS-SD Stack
dbus.service                              loaded active running D-Bus System Message Bus
dcron.service                             loaded active running Periodic Command Scheduler
dkms.service                              loaded active exited  Dynamic Kernel Modules System
getty@tty1.service                        loaded active running Getty on tty1
. . .

```

Вывод содержит следующие столбцы:

- **UNIT**: имя модуля `systemd`
- **LOAD**: указывает на то, парсила ли `systemd` конфигурацию модуля. Конфигурация загруженных модулей сохраняется в памяти.
- **ACTIVE**: краткое состояние активности модуля. Обычно это довольно стандартный способ сообщить, запущен модуль или нет.
- **SUB**: это состояние более низкого уровня, которое указывает более подробную информацию о модуле. Это часто зависит от типа модуля, состояния и фактического метода работы модуля.
- **DESCRIPTION**: краткое текстовое описание того, чем является модуль/что делает.

Поскольку команда `list-units` показывает по умолчанию только активные модули, для всех вводов выше отобразится `loaded` в столбце LOAD и `active` в столбце ACTIVE. Это отображение фактически является поведением по умолчанию `systemctl` при вызове без дополнительных команд, поэтому вы увидите то же, что и при вызове `systemctl` без аргументов.

### Команда **service**

Вы также можете использовать другой способ мониторинга служб Linux - команду service. Однако systemctl является основным инструментом в инструменте управления сервисами и содержит в себе функцию service, другими словами принципиальной разницы в вышеописанных способах нет, это лишь разные обращения к одному и тому же инструменту. Тем не менее Вы должны владеть разными подходами, поэтому ниже представлены основные варианты использования команды service на примере работы с некоторыми распространеннными сервисами.

Чтобы посмотреть какие сервисы у нас работают, необходимо ввести команду

`service --status-all`

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/40d1215d-802e-4d4a-90fa-2d5e984835ab/Untitled.png)

**Мониторинг Apache с помощью service**

Прежде всего установим Apache:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/f502c7f0-2cff-489e-be77-4752be9fb276/Untitled.png)

Просмотр статуса:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/6b6db986-12bd-4dff-9083-e94f37b64119/Untitled.png)

Как видим, в данный момент сервис не активен, следует его запустить:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/2512da15-c682-4d83-a2f3-0b32d40d2941/Untitled.png)

Снова проверим статус:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/722a4a9f-1881-4a8e-acc1-6ff4c200c745/Untitled.png)

Отлично, Apache присвоен статус _active._ Давайте убедимся в этом, зайдя на старницу сервиса в браузере. Для этого перейдем по адресу 127.0.0.1 (это так называемый локальный адрес):

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/6fd23ceb-8c5c-4413-a536-0b1498ff1b54/Untitled.png)

Такая страница свидетельствует о том, что мы всё сделали правильно.

Теперь давайте отключим web-сервер и посмотрим какой вывод нам даст браузер:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/0ab8f723-c4b4-486b-8014-b98a346deaa2/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/47ded24c-a1a9-4df6-bf61-23488023f019/Untitled.png)

**Мониторинг Telnet с помощью service**

Если данный сервис не установлен, то делаем следующее:

```html
$ sudo apt-get install telnet
```

У Telnet есть несколько режимов работы:

- Режим «Тестирование». Клиентская машина обрабатывает только текст, без загрузки графики. Например, введём в терминале: **telnet [opennet.ru](http://opennet.ru/) 80.** Утилита отправит запрос сайту [opennet.ru](http://opennet.ru/) на порт под номером 80. Далее вводим ключ: GET / для показа кода страницы. Результат представится в виде текстового сообщения с нечитаемыми символами, поскольку утилита не работает с русскими шрифтами

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/1b0bbf95-e11a-4cc7-adf1-2d37683a2699/Untitled.png)

С помощью telnet можно узнать есть ли на хосте ssh сервер:

```html
$ telnet -d ip-адрес 22
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/70c53b9b-eaf3-4dc4-be66-e2c51a9fc8e0/Untitled.png)

Вуаля, мы зашли на удаленный сервер (подробнее работа с удаленными хостами будет рассмотрена несколько позже).

_**ОБРАТИТЕ ВНИМАНИЕ, TELNET - ПРОТОКОЛ БЕЗ ШИФРОВАНИЯ, ИСПОЛЬЗУЙТЕ ЕГО С ОСТОРОЖНОСТЬЮ**_

**SSH** (англ. Secure SHell — «безопасная оболочка») – протокол передачи данных, позволяющий производить безопасное и защищенное управление операционной системой и данными. Это сетевой протокол прикладного уровня, который дает возможность шифрования передаваемых данных и паролей. К тому же позволяет передавать любой другой протокол. Первая версия протокола SSH была разработана аж в 1995 году. С тех пор были обнаружены некоторые слабые места и программа претерпела ряд существенных изменений. Таким образом, уже через год, в 1996 году, в свет вышла вторая версия SSH – 2. Она не совместима с первой версией и, говоря о SSH сегодня, всегда подразумевается SSH – 2. С тех пор SSH не изменила значительно стандарты своей работы и широко используется по сей день. SSH является сугубо коммерческим продуктом и предоставляется на платной основе. Однако повсеместно доступна и ее бесплатная версия, которая носит название OpenSSH. Не смотря на то, что OpenSSH является лишь одной из версий SSH, она намного чаще используется программистами.

Установка:

```html
$ sudo apt-get install openssh-server
```

Основные команды управления службой:

- sudo service ssh restart
- sudo service ssh stop
- sudo service ssh start

Подробнее мы вернемся к этому протоколу ниже в разделе Удаленное Администрирование Linux.

## Мониторинг системы

Отслеживание состояние системы и запущенных процессов - важная часть администрирования Linux. В обязанности администратора входит отслеживать различные параметры работы сервера Linux, нагрузку на процессор, диск, доступное дисковое пространство и оперативную память.

---

### **htop**

Продвинутый монитор процессов, написанный для Linux. Он был задуман заменить стандартную программу top. Htop показывает динамический список системных процессов, список обычно выравнивается по использованию ЦПУ. В отличие от top, htop показывает все процессы в системе. Также показывает время непрерывной работы, использование процессоров и памяти.

Установка:

```jsx
$ sudo apt-get install htop
```

Запускаем:

```jsx
$ sudo htop
```

Вывод:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/71d334a2-b948-4647-aef6-589a0d2e9390/Untitled.png)

Расшифровка:

**PID** - идентификатор процесса.

**USER** - владелец процесса.

**PRI** - текуший приоритет (влияет на процессорное время, отводимое процессу, значение по умолчанию - 20; чем меньше приоритет, тем больше времени отводится процессу, следовательно он выполняется быстрее).

**NI** - величина изменения приоритета относительно значения PRI (клавиши F7, F8).

**VIRT** - общий объем виртуальной памяти, используемой процессом. Включает в себя: область кода (CODE), данные (DATA), разделяемые библиотеки (SHARED) и страницы, перемещенные в swap-область памяти. Если  
приложение потребовало от ядра выделить ему 100Мб памяти, а  
использует всего 5 Мб, данный столбец всё равно будет показывать цифру 100.

**CODE** - объем памяти, содержащий исполняемый код процесса.

**DATA** - объем памяти, занятой данными, используемыми процессом в ходе выполнения.

**SWAP** - объем памяти, используемой процессом, но перемещенной в swap-область.**)**

**RES** - количество резидентной (не перемещаемой в swap) памяти в килобайтах. Если приложение потребовало от ядра выделить ему 100Мб памяти, а  
использует всего 5 Мб, то данный столбец покажет 5. Но здесь есть два ньюанса: а) RES не показывает сколько данных было перемещено в swap, б) часть RES-памяти может быть разделяемой.

**SHR** - количество разделяемой (shared) памяти программы в килобайтах,  
т.е. памяти, которая может быть использована другими приложениями.

**S** - состояние процесса:

**S** — так называемое состояние сна;

**R** — состояние выполнения;

**D** — состояние ожидания.

**CPU%** - использование процессора в процентном отношении.

**MEM%** - использование процессом памяти в процентном отношении.

**TIME+** - время работы процесса.

**Command** - указывает на команду, которой был запущен процесс.Через настройки (F2) можно добавить еще некоторые полезные параметры:

**IO RATE** - Операции ввода\вывода. Чтение + запись. Если нужно отдельно на чтение и на запись, то можно добавить: **IO READ RATE** и **IO WRITE RATE**.

Также на экран выводятся следующие параметры:

**Load average** - отражает число блокирующих процессов в очереди на исполнение в определенный временной интервал, а именно 1 минута, 5 минут и 15 минут, соответственно. Блокирующий процесс — это процесс, который ожидает ресурсов для продолжения работы.

**Uptime** - время работы системы.

### Управление:

**F1** - справка; **F2** - настройки; **F3** - поиск процесса; **F4** - сортировка списка процессов (от большего к меньшему или от меньшего к большему); **F5** - устанавливает древовидное отображение (корни - родительские процессы, а листья - дочерние) и наоборот; **F6** - открывает панель с выбором параметра сортировки процессов; **F7** - увеличить приоритет выполнения текущего процесса; **F8** - уменьшить приоритет выполнения текущего процесса; **F9** - убить процесс; **F10** - выйти из программы.

---

### Free

Вы можете использовать команду `free` для получения подробного отчета об использовании памяти системой.

Команда `free` предоставляет информацию об общем объеме физической и подкачки памяти, а также о свободной и используемой памяти и пространстве подкачки в системе.

При выполнении без каких либо опций вывод будет включать три строки, заголовок, одну строку для памяти и одну для подкачки:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/9ec399e3-365b-4717-af82-9a4712e6349e/Untitled.png)

Вот что означает каждый столбец:

- **total** - это число представляет собой общий объем памяти, который может использоваться приложениями.
- **used** - использованная память Он рассчитывается как: `used = total - free - buffers - cache`
- **free** - Свободная / Неиспользуемая память.
- **shared** - этот столбец можно игнорировать, так как он не имеет смысла. Это здесь только для обратной совместимости.
- **buff / cache** - объединенная память, используемая буферами ядра, кешем страниц и слэбами. Эта память может быть восстановлена в любое время, если это необходимо приложениям. Если вы хотите, чтобы буферы и кеш отображались в двух отдельных столбцах, используйте эту `w` опцию.
- **available** - оценка объема памяти, доступной для запуска новых приложений без замены.

Для вывода более удобочитаемых значений (обычно мегабайты и гигабайты) воспользуйтесь опцией -h

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/cc3afff4-4100-4f9a-9177-49227f050626/Untitled.png)

---

## Аудит безопасности (auditd)

В дистрибутивах Linux предусмотрена утилита для сбора системных событий и анализа полученных данных. Имя ей - **auditd.**

Auditd (сокращение от Linux Audit Daemon) — нативный инструмент предназначенный для мониторинга событий операционной системы и записи их в журналы событий. Был создан для тесного взаимодействия с ядром операционной системы — во время своей работы наблюдает за системными вызовами и может записывать события — чтение, запись, выполнение, изменение прав - связанные с файлами ОС. Таким образом, с его помощью можно отслеживать практически любые события, происходящие в операционной системе.

Установка:

`$ sudo apt-get install auditd`

Файлы конфигурации хранятся в /etc/audit/auditd.conf. Правила желательно хранить в /etc/audit/rules.d/*.rules, по умолчанию доступ к этой директории только у root'а. Обратите внимание на то, что файл с правилами в этой директории должен иметь название *.rules, иначе auditd не прочитает его без явного указания. Если вы решили хранить правила в другом месте, то владелец файла должен быть root. Помимо этого рекомендую выставить группу файла root и права 600, чтобы никто кроме root'а не мог работать с файлом конфигурации auditd, т.к. зная что логируется, атакующий может избежать обнаружения. То же самое касается и файлов с правилами для других инструментов.

Конфигурационный файл содержит следующие параметры:

- log_file — файл, в котором будут храниться логи подсистемы аудита;
- log_format — формат, в котором будет сохранены логи;
- freq — максимальное число записей протокола, которые могут храниться в буфере;
- flush — режим синхронизации буфера с диском (none — ничего не делать, incremental — переносить данные из буфера на диск с частотой, указанной в значении параметра freq; data — синхронизировать немедленно, sync — синхронизировать как данные, так и метаданные файла при записи на диск);
- max_log_file — максимальный размер файла лога в мегабайтах;
- max_log_file_action — действие при превышении максимального размера файла лога;
- space_left — минимум свободного пространства в мегабайтах, по достижении которого должно быть осуществлено действие, указанное в следующем параметре;
- space_left_admin — указывает, что делать, когда на диске недостаточно свободного места (ignore — ничего не делать; syslog — отправлять в syslog, email — отправлять уведомление по почте; suspend — прекратить запись логов на диск; single — перейти в однопользовательский режим; halt — выключить машину)
- disk_full_action — действие, которое нужно осуществить при переполнении диска (этот параметр может принимать те же значения, что и space_left_admin).

## Создание правил

Для добавления и настройки правил используется команда auditctl. Вот список её опций:

- l — вывести список имеющихся правил;
- а — добавить новое правило;
- d — удалить правило из списка;
- D — удалить все имеющиеся правила.

Чтобы создать новое правило, нужно выполнить команду вида:

```
$ auditctl -a <список>, <действие> -S <имя системного вызова> -F <фильтры>
```

Сначала после опции -а указывается список, в который нужно добавить правило. Всего существует 5 таких списков:

- task — события, связанные с созданием новых процессов;
- entry — события, которые имеют место при входе в системный вызов;
- exit — события, которые имеют место при выходе из системного вызова;
- user — события, использующие параметры пользовательского пространства;
- exclude — используется для исключения событий.

Затем указывается, что нужно делать после наступления события. Здесь возможны два варианта: always (события будут записываться в журнал) и never (не будут).

После опции -S идёт имя системного вызова, при котором событие нужно перехватить (open, close и т.п.).

После опции -F указываются дополнительные параметры фильтрации. Например, если нам требуется вести аудит обращений к файлам из каталога /etc, правило будет выглядеть так:

```
$ auditctl -a exit,always -S open -F path =/etc/
```

Можно установить и дополнительный фильтр:

```
$ auditctl -a exit,always -S open -F path =/etc/ -F perm = aw
```

Аббревиатура aw означает следующее: а — изменение атрибута (attribute change), w — запись (write). Формулировка perm = aw указывает, что для директории /etc нужно отслеживать все факты изменения атрибутов (а — attribute change) и w (w — write).

При настройке слежения за отдельными файлами можно опустить опцию -S, например:

```
$ auditctl -a exit,always -F path =/etc/ -F perm = aw
```

## Файлы правил

Правила можно не только задавать через командную строку, но и прописывать в файле etc/audit/audit.rules.

Начинается этот файл с так называемых метаправил, в которых задаются общие настройки журналирования:

```
# удаляем все ранее созданные правила
-D

# задаём количество буферов, в которых будут храниться сообщения
-b 320

# указываем, что делать в критической ситуации (например, при переполнении буферов):
0 - ничего не делать; 1 - отправлять сообщение в dmesg, 2 -  отправлять ядро в панику
-f 1
```

Далее следуют пользовательские правила. Их синтаксис предельно прост: достаточно просто перечислить соответствующие опции команды auditctl. Рассмотрим пример типового файла правил:

```
# отслеживать системные вызовы unlink () и rmdir()
-a exit,always -S unlink -S rmdir

# отслеживать системные вызовы open () от пользователя с UID 1001
-a exit,always -S open -F loginuid=1001

# отслеживать доступ к файлам паролей и групп и попытки их изменения:
-w /etc/group -p wa
-w /etc/passwd -p wa
-w /etc/shadow -p wa
-w /etc/sudoers -p wa

# отслеживать доступ к следующей директории:
-w /etc/my_directory -p r

# закрыть доступ к конфигурационному файлу для предотвращения изменений
-e 2

```

Изменения конфигурации вступят в силу после перезапуска демона auditd:

```
$ sudo service auditd restart

```

## Анализ журнальных файлов: утилита aureport

Все журнальные файлы сохраняются в директории /var/log/audit в машиночитаемом формате. Их можно сделать человекопонятными c помощью утилиты aureport.

Если ввести команду aureport без аргументов, мы увидим общую системную статистику (количество пользователей системы, общее количество системных вызовов, число открытых терминалов и т.п.):

```
$ sudo aureport

Summary Report
======================
Range of time in logs: 07/31/2015 14:04:23.870 - 08/04/2015 09:37:13.200
Selected time for report: 07/31/2015 14:04:23 - 08/04/2015 09:37:13.200
Number of changes in configuration: 0
Number of changes to accounts, groups, or roles: 3
Number of logins: 0
Number of failed logins: 0
Number of authentications: 0
Number of failed authentications: 61205
Number of users: 2
Number of terminals: 5
Number of host names: 73
Number of executables: 6
Number of files: 0
Number of AVC's: 0
Number of MAC events: 0
Number of failed syscalls: 0
Number of anomaly events: 0
Number of responses to anomaly events: 0
Number of crypto events: 0
Number of keys: 0
Number of process IDs: 17858
Number of events: 61870
```

Она не имеет особой практической ценности. Гораздо больший интерес представляют специализированные отчёты. Вот так, например, можно просмотреть информацию обо всех системных вызовах:

```
$ sudo aureport -s

Syscall Report
=======================================
# date time syscall pid comm auid event
=======================================
1. 08/03/2015 15:45:03 313 10285 modprobe -1 52501
2. 08/03/2015 15:45:03 313 10290 modprobe -1 52502
3. 08/03/2015 15:45:03 54 10296 iptables -1 52503
4. 08/03/2015 15:45:03 54 10302 iptables -1 52504
5. 08/03/2015 15:45:03 54 10305 iptables -1 52505
6. 08/03/2015 15:45:03 54 10313 iptables -1 52506
7. 08/03/2015 15:45:03 54 10325 iptables -1 52507
8. 08/03/2015 15:45:03 54 10329 iptables -1 52508
9. 08/03/2015 15:45:03 54 10343 iptables -1 52509
10.08/03/2015 15:45:03 54 10345 iptables -1 52510
11.08/03/2015 15:45:03 54 10349 iptables -1 52511

```

Воспользовавшись опцией -au (или −−auth), можно просмотреть информацию обо всех попытках входа в систему:

```
$ sudo aureport -au

Authentication Report
============================================
# date time acct host term exe success event
============================================
1. 08/31/2015 18:00:19 ubnt static-166-6-249-80.stalowa.pilicka.pl ssh /usr/sbin/sshd no 333
2. 08/31/2015 18:01:38 root 59.63.188.31 ssh /usr/sbin/sshd no 334
3. 08/31/2015 18:01:41 root 59.63.188.31 ssh /usr/sbin/sshd no 335
4. 08/31/2015 18:01:45 root 59.63.188.31 ssh /usr/sbin/sshd no 336
5. 08/31/2015 18:01:53 root 59.63.188.31 ssh /usr/sbin/sshd no 337
6. 08/31/2015 18:01:57 root 59.63.188.31 ssh /usr/sbin/sshd no 338
7. 08/31/2015 18:01:59 root 59.63.188.31 ssh /usr/sbin/sshd no 339

```

В аureport поддерживается фильтрация по дате и времени:

```
$ sudo aureport -s --start 07/31/15 12:00 --end 07/31/15 13:00
```

Можно указывать как конкретные время и дату, так и специальные человекопонятные конструкции:

- now — текущий момент;
- yesterday — вчерашнее сутки;
- recent — 10 минут назад;
- this-week (или this-month, this-year) — текущая неделя (месяц, год).

С помощью aureport можно просмотреть информацию о действиях любого пользователя системы. Для этого нужно сначала узнать id этого пользователя:

```
$ id user
uid=1000(user) gid=1000(andrei) groups=1000(andrei),27(sudo)

```

и затем выполнить следующую команду:

```
$ sudo ausearch -ui 1000 --interpret

```

## Ausearch: поиск и анализ событий

Для просмотра детальной информации о событии используется утилита ausearch:

```
$ sudo ausearch -a <номер события>

```

Вывод приведённой выше команды выглядит так:

```
type=SYSCALL msg=audit(1364481363.243:24287): arch=c000003e
syscall=2 success=no exit=-13 a0=7fffd19c5592 a1=0 a2=7fffd19c4b50 a3=a
items=1 ppid=2686 pid=3538 auid=500 uid=500 gid=500 euid=500 suid=500
fsuid=500 egid=500 sgid=500 fsgid=500 tty=pts0 ses=1 comm="cat"
exe="/bin/cat"
subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
key="sshd_config"

```

Рассмотрим его структуру более подробно. В поле type указывается тип записи; type = syscall означает, что запись была сделана после выполнения системного вызова. В поле msg указано время события в формате Unix Timestamp и его уникальный идентификационный номер.

В поле arch содержится информация об используемой архитектуре системы (c000003e означает x86_84), представленная в закодированном шестнадцатеричном формате. Чтобы она выводилась в человекочитаемом виде, можно воспользоваться опцией -i или −−interpret.

В поле syscall указан тип системного вызова — в нашем случае это 2, то есть вызов open. Параметр success сообщает, был ли вызов обработан успешно или нет. В нашем примере вызов был обработан неудачно (success = no). Вывести на консоль информацию о любом параметре в человекочитаемой форме можно получить при помощи упомянутой выше опции -i или −−interpret, например:

```
$ sudo ausearch --interpet --exit  -13
```

Опция -sc позволяет включать в список события, относящиеся к указанному системному вызову, например:

```
$ sudo ausearch -sc ptrace
```

Опция -ui служит для поиска событий по идентификатору пользователя:

```
$ ausearch -ui 33
```

Поиск по именам демонов осуществляется с помощью опции -tm:

```
$ ausearch -x -tm cron
```

Для поиска нужных событий можно также использовать ключи, например:

```
$ sudo auditctl -k root-actions
```

Приведённая команда выведет список всех действий, совершённых от имени root-пользователя. Поддерживается также фильтрация по дате и времени, аналогичная той, что была описана выше. Вывести список событий, завершившихся неудачно, можно с помощью опции −−failed.

## Анализ процессов с помощью утилиты autrace

В некоторых случаях бывает полезным получить информацию о событиях, связанных с одним конкретным процессом. Для этой цели можно воспользоваться утилитой autrace. Предположим, нам нужно отследить процесс date и узнать, какие системные вызовы и файлы он использует. Выполним команду:

```
$ sudo autrace /bin/date
```

На консоли появится следующий текст:

```
Waiting to execute: /bin/date
Mon Aug 31 17:06:32 MSK 2015
Cleaning up...
Trace complete. You can locate the records with 'ausearch -i -p 29234'
```

Обратим внимание на последнюю строку вывода: в ней указана команда, с помощью которой можно получить более подробную информацию. Выполним эту команду и передадим вывод утилите aureport, которая преобразует его в человекочитаемый формат:

```
$ sudo ausearch -p 29215 --raw | aureport -f -i
```

В результате мы получим вот такой отчёт:

```
File Report
===============================================
# date time file syscall success exe auid event
===============================================
1. 08/31/2015 16:52:16 /bin/date execve yes /bin/date root 25
2. 08/31/2015 16:52:16 /etc/ld.so.nohwcap access no /bin/date root 27
3. 08/31/2015 16:52:16 /etc/ld.so.preload access no /bin/date root 29
4. 08/31/2015 16:52:16 /etc/ld.so.cache open yes /bin/date root 30
5. 08/31/2015 16:52:16 /etc/ld.so.nohwcap access no /bin/date root 34
6. 08/31/2015 16:52:16 /lib/x86_64-linux-gnu/libc.so.6 open yes /bin/date root 35
7. 08/31/2015 16:52:16 /usr/lib/locale/locale-archive open yes /bin/date root 52
8. 08/31/2015 16:52:16 /etc/localtime open yes /bin/date root 56

```

## Централизованное хранение логов

Для отправки логов подсистемы аудита в централизованное хранилище используется плагин audisp-remote. Он входит в пакет audisp-plugins, который нужно устанавливать дополнительно:

```
$ sudo apt-get install audisp-plugins
```

Конфигурационные файлы всех плагинов хранятся в директории /etc/audisp/plugins.d.

Настройки удалённого логгирования прописываются в конфигурационном файле /etc/audisp/plugins.d/audisp-remote.conf. По умолчанию этот файл выглядит так:

```
active = no
direction = out
path = /sbin/audisp-remote
type = always
#args =
format = string
```

Чтобы активировать отправку логов в удалённое хранилище, заменим значение параметра active на yes. Затем откроем файл etc/audisp/audisp-remote.conf и в качестве значения параметра remote_server укажем буквенный или IP-адрес cервера, на котором будут храниться логи.

Чтобы принимать логи с удалённых хостов и сохранять их на сервере, в файле /etc/audit/auditd.conf нужно прописать следующие параметры:

```
tcp_listen_port = 60

tcp_listen_queue = 5

tcp_max_per_addr = 1

##tcp_client_ports = 1024-65535 #optional

tcp_client_max_idle = 0
```

---

## Работа с менеджерами пакетов

Ранее мы неоднократно устанавливали те или иные утилиты (скачивая их пакеты), однако не рассматривали команду, которой для этого пользовались - apt. APT - один из самых распространенных менеджеров пакетов. Менеджер пакетов - программа, выполняющая установку, удаление или обновление любого пакета или группы пакетов, и автомитически выполняющая все необходимые для этого процедуры (доставку пакетов из удалённых репозиториев, вычисление зависимостей и установку требуемых по ним пакетов, удаление замещаемых пакетов и т. п.).

### Категории пакетных менеджеров

- **Высокоуровневые менеджеры.** Применяются для поиска и скачивания пакетов из репозиториев. В процессе работы могут задействовать низкоуровневые менеджеры для инсталляции загруженных программ.
- **Низкоуровневые менеджеры.** Используются для установки локальных пакетов, загруженных вручную пользователем, или высокоуровневым пакетным менеджером.

### Распространенные форматы пакетов

- **DEB (.deb)**. Самый популярный формат пакетов дистрибутива Debian и его ближайших родственников — Ubuntu, MX Linux, Pop!_OS, elementary OS и других.
- **RPM (.rpm)**. Разработан компанией Red Hat и внедрен в дистрибутив RHEL. Также применяется в таких системах как Fedora и CentOS.
- **PKG.TAR.XZ**. Стандартный тип пакетов для дистрибутива ArchLinux и его производных — Manjaro, ARCOLINUX и других.
- **Ebuild (.ebuild).** Скрипт bash-сценария для компиляции программ в дистрибутивах Gentoo и Calculate Linux.

Для корректного функционирования пакетных менеджеров необходимо корректное отслеживание пакетных зависимостей. Зависимости – список дополнительных пакетов и библиотек, участвующие в работе программы. Во время установки приложения пакетный менеджер или компилятор считывают специальный файл со списком зависимостей, а после проверяют их наличие в системе.

Если важная зависимость будет не удовлетворена при установке программы низкоуровневым менеджером, то будет выдана ошибка с названием отсутствующего пакета. В подобной ситуации проблема решается отдельной установкой недостающего пакета.

При использовании высокоуровнего пакетного менеджера для установки программы, зависимые пакеты будут установлены в автоматическом режиме, без вмешательства пользователя.

Самые распростанённые пакетные менеджеры:

### APT

APT (Advanced Packaging Tool) – консольная утилита, выполняющая роль «поисковика» и загрузчика пакетов из репозиториев. Установка скачанных пакетов производится утилитой DPKG. Благодаря эффективному разрешению зависимостей, пакетный менеджер APT используется по умолчанию в дистрибутивах с архитектурой Debian и поддерживает систему в актуальном состоянии.

Синтаксис команды apt следующий:

```
$ sudo apt <действие> <пакет(ы)> <доп. параметры>
```

С примением apt install вы уже хорошо знакомы, эта команда позволяет скачать и установить тот или иной пакет. Однако у apt есть и другие применения:

```
$ sudo apt update
```

У APT есть список репозиториев, из которых происходит установка пакетов. Список хранится в текстовом файле _/etc/apt/sources.list_, а также в директории _/etc/apt/sources.list.d/_. При выполнении команды _apt update_, APT проходит по списку репозиториев и из каждого репозитория в списке получает информацию о пакетах, находящихся в репозитории. Вся эта информация сохраняется в системе.

Если выходит новая версия какого-нибудь пакета, то APT не узнает об этом, пока не будет выполнена команда _apt update_. Поэтому, если установить данный пакет (не выполнив предварительно apt update), то будет установлена та версия пакета, информация о которой хранится в системе в данный момент.

Чтобы выполнить обновление пакетов, установленных в системе, используется команда:

```
$ sudo apt upgrade
```

Данная команда только обновляет пакеты до новых версий, но никогда не удаляет и не устанавливает другие пакеты.

Есть еще одна команда для **обновления** пакетов:

```
$ sudo apt full-upgrade
```

Данная команда выполняет обновление пакетов, а также удаляет или устанавливает новые пакеты, если это потребуется для разрешения зависимостей.

Чтобы **установить** пакет используется команда:

```
$ sudo apt install <пакет>
```

Для **установки нескольких** пакетов их имена записываются через пробел:

```
$ sudo apt install <пакет1> <пакет2> <пакет3>
```

Чтобы установить **определенную версию** пакета нужно после названия пакета, через знак равенства, указать требуемую версию:

```
$ sudo apt install <пакет>=<версия>
```

Для **удаления**, установленного пакета, используется команда:

```
$ sudo apt remove <пакет>
```

Удалить пакет и его конфигурационные файлы:

```
$ sudo apt purge <пакет>
```

_apt purge_ работает аналогично _apt remove_, но удаляет еще и конфигурационные файлы, относящиеся к пакету. Это означает, что если вы установили какую-нибудь программу, настроили ее, а потом удалили командой _apt remove_, то конфигурационный файл этой программы останется в системе. Если вы теперь установите эту программу снова, то можно будет использовать предыдущий конфигурационный файл, так как он не был удален.

_apt purge_ не удаляет конфигурационные файлы, хранящиеся в вашей домашней директории.

Если вы удалили пакет командой _apt remove_, то вы можете выполнить _apt purge_ для данного, уже удаленного пакета, чтобы «доудалить» его конфигурационные файлы.

Удалить неиспользуемые пакеты

```
$sudo apt autoremove
```

Когда вы устанавливаете пакет, то часто устанавливаются дополнительные пакеты, являющиеся его зависимостями. Если теперь вы удалите этот пакет, то зависимости останутся в системе. _apt autoremove_ удаляет эти зависимости, но только те, которые не нужны другим установленным пакетам.

### Список пакетов

Команда apt list используется для вывода списка пакетов по какому-то критерию.

Вывести список установленных в системе пакетов:

```
$ apt list --installed
```

Вывести список пакетов, которые требуют обновления (у которых вышла новая версия):

```
$ apt list --upgradable
```

Вывести список всех пакетов доступных для вашей системы:

```
$ apt list --all-versions
```

Если Вас интересует количество установленных пакетов, то его Вам выведет следующая команда:

```html
$ apt list --installed | wc -l
```

**Поиск** пакетов:

```
$ apt search <слово>
```

Данная команда выполняет поиск указанного _слова_ в названии пакетов и в описании пакетов. Поддерживаются регулярные выражения.

Можно выполнять поиск только по названиям пакетов для этого используется опция --names-only:

```
$ apt search --names-only <слово>
```

Поиск пакета с использованием регулярных выражений:

```
$ apt search --names-only '^python'
```

**Информация** о пакете:

```
$ apt show <пакет>
```

Выводит информацию о пакете. Отображается версия, размер, описание, зависимости и другая информация.

Редактирование списка репозиториев:

```
$ sudo apt edit-sources
```

Открывает файл _/etc/apt/sources.list_ в текстовом редакторе для редактирования, после сохранения изменений и закрытия редактора, выполняет проверку файла на предмет ошибок. В случае наличия ошибок, выводит предложение на повторное редактирование файла, чтобы исправить ошибки.

Вы могли заметить, что ранее помимо apt мы пользовались также утилитой apt-get, и может возникнуть резонный вопрос - в чем разница?

Apt это утилита, которая появилась, как альтернатива apt-get. Она выполняет практически все те же функции, что и apt-get, но с ней проще и понятнее работать.

Например, все команды apt имеют простой синтаксис: _apt название_команды_. А у apt-get есть дополнительные команды, например, _apt-cache_. Таким образом, при использовании apt, пользователю не нужно запоминать дополнительные наборы команд.

Помимо упрощения работы с командами, apt нагляднее выводит информацию, вроде бы мелочи, но работать удобнее. Например, apt умеет показывать прогресс бар, а при выполнении _apt update_ можно увидеть сколько пакетов можно обновить.

Стоит отметить, что утилита apt-get более функциональна, чем apt.

### **dpkg**

DPKG (Debian Package) – система управления пакетами в Debian и дистрибутивах на его основе, например Ubuntu. Утилита DPKG появилась в дистрибутиве Debian в 1995 году. Низкоуровневый пакетный менеджер создан только для работы с локальными DEB пакетами и не может самостоятельно разрешать зависимости, а также скачивать пакеты из репозиториев

- Для получения списка пакетов, установленных в системе, в терминале наберите:

```
$ dpkg -l
```

- В зависимости от количества пакетов в вашей системе, эта команда может породить большой объем вывода. Пропустите выходной поток через `grep` чтобы увидеть установлен ли определенный пакет:

```
$ dpkg -l | grep apache2
```

Замените `apache2` на любое имя пакета, часть имени или иное регулярное выражение.

- Для получения списка файлов, установленных пакетом (в нашем случае ufw), введите:

```
$ dpkg -L ufw
```

- Если вы не уверены каким пакетом установлен файл, dpkg -S может подсказать вам. Например:

```
$ dpkg -S /etc/host.conf
base-files: /etc/host.conf
```

Вывод указывает, что /etc/host.conf принадлежит пакету base-files.

Многие файлы автоматически создаются в процессе установки пакета, но несмотря на то, что они находятся на файловой системе, dpkg -S может не знать какому пакету они принадлежат.

- Вы можете установить локальный .deb файл, набрав:

```
$ sudo dpkg -i zip_3.0-4_i386.deb
```

Замените zip_3.0-4_i386.deb на реальное имя локального .deb файла, который вы собираетесь установить.

- Удаление пакета может быть выполнено так:

```
$ sudo dpkg -r zip
```

Удаление пакетов с использованием dpkg в большинстве случаев не рекомендуется. Лучше использовать менеджер пакетов, отслеживающий зависимости, чтобы гарантировать, что система находится в связанном состоянии. Например, использование dpkg -r zip удалит пакет zip, однако любые пакеты, зависящие от него, останутся установленными и более не смогут работать правильно.

Для дополнительной информации смотрите страницу описания:

```
$ man dpkg
```

### **RPM**

**RPM (Red Hat Package Manager)** - это популярная утилита управления пакетами для Linux систем на базе Red Hat, таких как (RHEL, CentOS и Fedora). Она используется для установки, удаления, обновления, запроса и проверки пакетов программного обеспечения. Пакет состоит из архива файлов и информации о пакете, включая имя, версию и описание. Формат файлов также называется RPM.

В RPM используется несколько основных режимов команд:

**Install** (используется для установки любого пакета RPM),

**Remove** (используется для удаления, стирания или деинсталляции пакета),

**Upgrade** (используется для обновления существующего пакета),

**Query** (используется для запроса пакета),

**Verify** (используется для проверки пакетов RPM).

Применение:

установить RPM пакет:

`$ sudo rpm -ivh GeoIP-1.5.0-11.el7.x86_64.rpm`

проверить установленный пакет RPM:

`$ sudo rpm -q GeoIP`

вывести список всех файлов для определенного установленного пакета RPM:

`$ sudo rpm -ql GeoIP`

вывести список недавно установленных пакетов RPM:

`$ sudo rpm -qa --last`

установить RPM пакет без зависимостей:

`$ sudo rpm -ivh --nodeps GeoIP-1.5.0-11.el7.x86_64.rpm`

заменить установленный пакет RPM:

`$ sudo rpm -ivh --replacepkgs GeoIP-1.5.0-11.el7.x86_64.rpm`

удалить пакет RPM:

`$ sudo rpm -e --nodeps GeoIP`

обновить установленный пакет RPM:

`$ sudo rpm -Uvh GeoIP-1.5.0-11.el7.x86_64.rpm`

запросить все установленные пакеты:

`$ sudo rpm -qa`

получить информацию для конкретного пакета:

`$ sudo rpm -qi GeoIP`

Перечень других популярных менеджеров с кратким описанием:

### YUM

YUM (Yellowdog Updater, Modified) – высокоуровневый пакетный менеджер, написанный на языке Python для систем RED HAT (RHEL, CentOS, Fedora). Программа представляет собой своеобразную оболочку для утилиты RPM. В задачу YUM входит скачивание и обновление пакетов из репозиториев, а также удовлетворение зависимостей во время установки программы.

### Pacman

Pacman – высокоуровневый пакетный менеджер системы Arch Linux и его родственных дистрибутивов (Manjaro, EndeavourOS и др.). Программа написана на языке C# и совмещает высокую функциональность, легкость и производительность. В качестве пакетов используются архивы pkg.tar.xz*.*

### Synaptic

Synaptic — графический менеджер пакетов, работающий на основе APT. Программа пригодится новичкам, плохо знакомым с командной строкой. Несмотря на простоту интерфейса, утилита предоставляет весь необходимый функционал пакетного менеджера APT (установка, удаление, обновление и поиск пакетов).

### GIT

Git - это очень популярная система контроля версий и совместной разработки проектов с открытым исходным кодом. С помощью Git вы можете отслеживать изменения в исходном коде своих проектов, возвращать предыдущие версии в случае критических ошибок, а также делиться своим кодом со всеми желающими и принимать от них исправления.Это мощная система, которая позволяет оптимизировать работу над вашими проектами. Здесь нет каких-либо требований к языку или структуре файлов, поэтому у разработчиков полная свобода действий.

Установка:

`sudo apt install git`

![https://i.imgur.com/kQiFjP6.png](https://i.imgur.com/kQiFjP6.png)

С помощью этой системы контоля версии мы можем получать исходные коды приложений, например мы хотим скачать сканнер BlackWidow ([https://github.com/1N3/BlackWidow](https://github.com/1N3/BlackWidow)). Для этого с помощью команды **git clone** склонируем проект из неофициального репозитория в нашу директорию (предварительно создадим её командой mkdir git и перейдем в неё командой cd git):

```html
$ git clone <https://github.com/1N3/BlackWidow>
```

![https://i.imgur.com/jRNYbtY.png](https://i.imgur.com/jRNYbtY.png)

## Удаленное администрирование Linux

Когда Вы занимаетесь администрированием одного единственного сервера, то можете выполнять все действия непосредственно на нём, зачастую имея к нему физический доступ. Но на практике корпоративная инфраструктура состоит из множества объединенных в сеть серверов, которые могут располагаться на разных этажах, в разных офисах, или даже городах. Что делать в таком случае? Не покупать же билет до Мурманска каждый раз, когда на расположенном там сервере вдруг перестал работать Apache. Для решения подобных задач существуют протоколы удаленного доступа, такие как Telnet и SSH. Мы уже рассматривали их в контексте управления сервисами, теперь же погрузимся в них более детально.

---

**TELNET** - одна из самых старых информационных технологий. Основным назначением протокола является реализация сетевого терминала для доступа к ресурсам удаленного компьютера. Протокол telnet ****обеспечивает двунаправленный восьмибитный канал передачи данных. Его главной задачей является создание стандартного метода взаимодействия терминальных устройств и терминал-ориентированных процессов через сеть telnet **** использует TCP-соединение для передачи данных вперемешку с управляющей информацией протокола. В принципе, для работы протокола передавать какую-либо управляющую информацию не обязательно. Таким образом, протокол может использоваться для соединения с любым сервисом, использующим TCP в качестве транспортного протокола, и обмену данными между участниками соединения.

Протокол telnet ****находится на сеансовом уровне модели **OSI/ISO**. Для обеспечения удаленного доступа к терминалу сервера стандартом резервируется порт 23. Основу протокола составляют три базовые концепции:

1. _**Концепция "Сетевого Виртуального Терминала"**_

**Сетевой виртуальный терминал, Network Virtual Terminal, NVT**

Когда устанавливается соединение, предполагается, что оно начинается и завершается на "Сетевом Виртуальном Терминале" (Network Virtual Terminal, NVT). NVT - это воображаемое устройство, которое создает промежуточное стандартное представление канонического терминала. NVT является стандартным описанием наиболее широко используемых возможностей реальных физических терминальных устройств. NVT позволяет описать и преобразовать в стандартную форму способы отображения и ввода информации.

Терминальная программа и работающий с ней процесс преобразовывают характеристики физических устройств в спецификацию **NVT**, что позволяет, с одной стороны, унифицировать характеристики физических устройств, а с другой обеспечить совместимость устройств с различными возможностями.

Характеристики диалога определяются устройством с меньшими возможностями. В результате, "пользовательскому" и "серверному" узлам не нужно хранить информацию о характеристиках терминалов друг друга. Все узлы отображают характеристики своих устройств так, чтобы другой стороне казалось, что она имеет дело с NVT. Обычно, под "пользовательским" понимают узел, к которому подключен реальный терминал, а под "серверным" - который предоставляет некоторый сервис. Можно считать "пользовательским" тот узел, который инициирует соединение.

2. _**Принцип согласования параметров**_

**Option negotiation**

NVT - это минимально необходимый набор параметров, который позволяет работать даже самым примитивным устройствам. Реальные современные устройства обладают гораздо большими возможностями представления информации. Принцип согласования параметров позволяет использовать эти возможности. Например, NVT является терминалом, который не может использовать функции управления курсором, а реальный терминал, с которого осуществляется работа, возможно умеет это делать. Используя согласование параметров, терминальная программа предлагает обслуживающему процессу использовать управляющие последовательности для управления выводом информации. Получив такую команду процесс начинает вставлять управляющие последовательности в данные, предназначенные для отображения.

Протокол предлагает структуру дополнительных параметров "DO, DON'T, WILL, WON'T", позволяющую пользователю и серверу более точно договориться об используемых в соединении соглашениях.

Команда **WILL** XXX указывает на предложение отправляющей стороны использовать параметр XXX. **DO** XXX и **DON'T** XXX являются, соответственно, положительным и отрицательным ответом. Аналогично, **DO** XXX посылается как предложение получающей стороне использовать параметр XXX**. WILL** XXX и **WON'T** XXX суть положительный и отрицательный ответы. Так как **NVT** это то, что остается, когда никакие параметры не используются, ответы **DON'T** и **WON'T** гарантируют, что соединение останется в состоянии, которое подходит обеим сторонам. В отличие от других протоков сеансового уровня, таких как **FTP** или **SMTP**, команды передаются не английскими словами (или их сокращениями), а в виде восьмибитных последовательностей (байтов).

Так, команде **DO** соответствует байт 253, **WON'T** - 252, и т.д.

Установка определенного параметра происходит так: один из участников соединения посылает другому запрос, предлагая использовать в сеансе работы определенный параметр. Если другая сторона соглашается, параметр немедленно вступает в силу. Если приходит отказ, используется то значение параметра, которое определяется для **NVT**. Обычно параметры согласуются вначале при установке соединения, хотя при работе одна из сторон может вновь изменить какие-либо параметры.

3. _**Симметрия терминалов и процессов**_

Симметрия терминалов и процессов отражает тот факт, что все управляющие команды протокола могут даваться любой стороной, участвующей в соединении. Разделения на "клиент" и "сервер" здесь нет.

Вспомним команду установки telnet:

```html
$ sudo apt install telnet
```

**Синтаксис** telnet:

```html
$ telnet опции хост порт
```

Хост - это домен удаленного компьютера, к которому следует подключиться, а порт - порт на этом компьютере.

Мы можем использовать telnet для проверки доступности хоста (в случае, если наша идеология по той или иной причине презирает утилиту ping):

```html
$ telnet 192.168.1.243
```

Можно проверить доступность порта (в команде ниже проверяем порты 123 и 22 на localhost):

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/6b77eda5-b7bc-41d0-9972-a6ef4415a880/Untitled.png)

В первом случае мы видим, что соединение никто не принимает, во втором же выводится сообщение об успешном подключении и приветствие SSH сервера (SSH по умолчанию висит на 22 порту, однако для повышения уровня защиты системы следует его “перевесить” на какой-либо нестандартный порт).

А теперь давайте рассмотрим основные опции:

- **4** - принудительно использовать адреса ipv4;
- **6** - принудительно использовать адреса ipv6;
- **8** - использовать 8-битную кодировку, например, Unicode;
- **E** - отключить поддержку Escape последовательностей;
- **a** - автоматический вход, берет имя пользователя из переменной окружения USER;
- **b** - использовать локальный сокет;
- **d** - включить режим отладки;
- **р** - режим эмуляции rlogin;
- **e** - задать символ начала Escape последовательности;
- **l** - пользователь для авторизации на удаленной машине.

После установки подключения telnet может работать в двух режимах:

- **Построчный** - это предпочтительный режим, здесь строка текста редактируется на локальном компьютере и отправляется только тогда, когда она будет полностью готова. На такая возможность есть не всегда и не у всех сервисов;
- **Посимвольный** - все набираемые вами символы отправляются на удаленный сервер. Тут будет сложно что-либо исправить, если вы допустили ошибку, потому что Backspace тоже будет отправляться в виде символа и стрелки движения тоже.

Использование telnet заключается в передаче специальных команд. У каждого сервиса свои команды, но у протокола есть свои команды telnet, которые можно применять в консоли telnet.

- **CLOSE** - закрыть соединение с сервером;
- **ENCRYPT** - шифровать все передаваемые данные;
- **LOGOUT** - выйти и закрыть соединение;
- **MODE** - переключить режим, со строчного на символьный или с символьного на строчный;
- **STATUS** - посмотреть статус соединения;
- **SEND** - отправить один из специальных символов telnet;
- **SET** - установить значение параметра;
- **OPEN** - установить подключение через telnet с удаленным узлом;
- **DISPLAY** - отобразить используемые спецсимволы;
- **SLC** - изменить используемые спецсимволы.

### Консоль telnet

Использование консоли telnet тоже важный момент в разборе как пользоваться telnet. В основном режиме вы можете выполнять команды, на удаленном сервере, если же вы хотите адресовать команду именно telnet, например, для настройки ее работы, необходимо использовать спецсимвол для открытия консоли, обычно утилита сразу говорит вам что это за символ. По умолчанию используется символ, соответсвующий очетанию клавиш Ctrl+[

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/fe20e415-ca6f-412d-a30f-87a24d7a895e/Untitled.png)

Чтобы посмотреть все доступные команды, вы можете набрать ?. Например, вы можете посмотреть статус подключения:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/af8a5728-7d91-429f-84d0-3dfb162cafd8/Untitled.png)

Настоятельно не рекомендуется использовать небезопасный telnet для удаленного управления, потому что все команды и пароли могут быть прослушаны сторонним пользователем. Но иногда, например, для роутеров, telnet все же используется для удаленного управления. Все работает точно так же, как и для других подключений, только нужно использовать порт 23, а на удаленном компьютере должен быть установлен telnet-server:

```html
$ telnet localhost 23
```

Далее, вам нужно ввести логин и пароль, а затем вы сможете выполнять команды в удаленной системе.

## **SSH**

Средство номер один для организации удаленного доступа - протокол SSH.

SSH (от англ. _s_ecure _sh_ell -- безопасная оболочка) это набор программ, которые позволяют регистрироваться на компьютере по сети, удаленно выполнять на нем команды, а также копировать и перемещать файлы между компьютерами. SSH организует защищенное безопасное соединение поверх небезопасных каналов связи.

SSH предоставляет замены традиционным r-командам удаленного доступа с тем отличием, что они обладают повышенной безопасностью. Они выполняются поверх защищенных зашифрованных соединений, которые не позволяет прослушивать или подменять трафик. Кроме того, SSH может обеспечивать безопасное соединение для передачи любого другого трафика: например, почтовых сообщений или файлов.

Протокол SSH возник как попытка обезопасить открытые незащищенные соединения. Впоследствии его функции были значительно расширены. Наиболее важными из них являются:

- _Безопасные команды доступа к хосту._ SSH дает возможность выполнять безопасные команды доступа к хосту, такие как ssh (удаленная оболочка), slogin (удаленный вход в систему), scp (удаленное копирование);
- _X11 Forwarding._ SSH предоставляет встроенный механизм для выполнения удаленных клиентов X Window.
- _Port forwarding._ SSH может выполнять переадресацию портов, передавая трафик c одного порта одной машины на другой порт другой машины. При этом передаваемый трафик шифруется;

### Обеспечение безопасности SSH

Безопасность протокола достигается использованием нескольких решений, которые сводят к минимуму риск использования соединения:

- _Шифрование соединение_, которое может выполняться одним из методов, выбранных в процессе переговоров. Шифрованное соединение не позволяет просто перехватить и использовать трафик. Выбор алгоритма шифрования делает систему более гибкой, позволяя не использовать алгоритмы, в которых обнаружены слабые места или которые не может поддерживать одна из сторон;
- _Аутентификация сервера_ выполняется при любом соединении. Это не позволяет выполнить подмену сервера или подмену трафика;
- _Аутентификация клиента_ может выполняться одним из нескольких доступных способов. Это с одной стороны может повысить надежность аутентификации, с другой -- делает систему более гибкой и упрощает ее использование;
- _Проверка целостности пакетов_ позволяет отследить любые незаконные изменения в трафике соединения. При обнаружении таких изменений, соединение немедленно разрывается;
- _Временные параметры аутентификации_ не позволяют воспользоваться данными соединения в том, случае, если спустя некоторое время после перехвата оно все-таки было расшифровано. Устаревание обычно происходит через час;

### Аутентификация сервера

Аутентификация сервера производится при помощи инфраструктуры открытых ключей. Клиент, который хочет установить соединение с сервером шифрует данные известным ему открытым ключом сервера и отправляет их серверу. Сервер должен расшифровать их при помощи известного только ему секретного ключа, и отправить их назад. Так клиент может быть уверен в том, является ли хост тем, за кого себя выдает.

Аутентификация сервера по протоколу SSH выполняется при помощи инфраструктуры открытых ключей. Открытый ключ сервера клиент получает при первом соединении с ним.

Аутентификация сервера дает возможность не полагаться на службу имен и маршрутизацию пакетов. В том случае, если нарушителю удалось подменить запись в DNS или перенаправить IP-пакеты на свой хост, аутентификация не пройдет, поскольку хост не обладает необходимыми секретными ключами.

S_sh_ защищает от:

- _Подмены IP-адресов (IP-spoofing),_ когда удаленный хост посылает пакеты от имени другого хоста;
- _Подмены DNS-записей (DNS-spoofing),_ когда изменяется запись на сервере DNS и в результате соединение устанавливается не с желаемым хостом, а с тем, на который указывает новая запись;
- _Перехвата открытых паролей и прочих данных_, которые передаются в открытом виде и любой, кто имеет физический доступ к каналу, может их узнать.

### Аутентификация клиента

Методы аутентификации клиентов, которые использует SSH:

- Host-based аутентификация
- Аутентификация с помощью открытых ключей
- Kerberos-аутентификация
- Парольная аутентификация.

_**По хостам**._ Метод аналогичный используемому в r-командах. В том случае, если соединение устанавливается с привилегированного порта, и файл .rhosts позволяет вход в систему, он разрешается. Этот метод является потенциально небезопасным, рекомендуется не использовать его. Для повышения уровня своей безопасности метод может быть дополнен ls /devRSA-аутентификацией клиентского хоста.

_**Открытый ключ**._ Клиент отправляет серверу открытый ключ. Если сервер знает его, он просит клиента доказать, что тот знает и секретный ключ тоже. Если клиент может это доказать, значит аутентификация считается успешной.

_**Керберос**._ Аутентификация проводится по схеме v5 Kerberos.

_**Пароль**._ В самом крайнем случае, если не удалось провести аутентификацию не одним из перечисленных способов, используется традиционная аутентификация при помощи пароля. Принцип аутентификации аналогичен тому, какой, например, используется в Telnet с той разницей, что пароль передается по зашифрованному каналу.

## OpenSSH

OpenSSH — это реализация с открытым исходным кодом протокола SSH, позволяющая шифровать соединение в сети посредством набора программ. Состоит из сервера OpenSSH и клиентских пакетов.

Технология работает по принципу сервер-клиент. То есть на удалённой машине, на которой вы хотите выполнять команды, нужно запустить сервер OpenSSH. К этому серверу можно подключаться с помощью клиентов OpenSSH. На одном компьютере могут быть одновременно установлены и сервер и клиент. Их запуск и настройка выполняется независимо друг от друга.

**Сервер sshd**

Сервер SSH реализован в виде программы sshd. Сервер _sshd_ является независимой программой, поэтому его запуск нужно производить во время загрузки компьютера стартовыми скриптами. То есть, вызов _sshd_ либо должен осуществляться явно одним из rc-скриптов, либо ссылки на скрипт запуска следует включить в иерархию /etc/rc?.d/.

Для того чтобы сервер sshd автоматически стартовал при запуске компьютера, необходимо добавить его вызов в скрипты загрузки.

Будучи запущенным, демон работает в фоновом режиме и обрабатывает все входящие запросы по порту 22. Для каждого соединения создается новая копия демона, который занимается только его обслуживанием.

**Настройка сервера sshd**

Конфигурация демона определяется файлом /etc/ssh/sshd_config. Он представляет собой набор действующих строк, пустых строк и строк-комментариев. Действующие строки файла содержат название параметра и его значение. Например, строка

```
Port 22
```

заставляет демон вести прослушивание на 22 порту. В конфигурационном файле указывается большое количество параметров, которые можно отнести к нескольким категориям:

- _Адреса._ Интерфейс и порт, к которым привязан демон;
- _Журнализация._ Опции, определяющие то, какая именно информация о работе демона должна регистрироваться и заноситься в журналы системы;
- _Управление ключами._ Информация о том, в каких файлах находятся ключи, участвующие в аутентификации.
- _Аутентификация._ Допустимые схемы аутентификации.
- _Дополнительные параметры._ Опции, управляющие дополнительными функциями SSH, такими как переадресация портов, переадресация X11 и другие

Некоторые конфигурационные параметры могут быть переопределены опциями командной строки при вызове _sshd_.

### **Конфигурационный файл /etc/ssh/sshd_config**

Служба **sshd** считывает данные о конфигурации из файла **/etc/ssh/sshd_config** (или из файла. указанного в командной строке при помощи параметра **-f**). Файл содержит пары параметр-значение, по одной на строку. Пустые и строки, начинающиеся с «**#**». интерпретируются как комментарии. Если аргументы содержат пробелы, они должны быть заключены в двойные кавычки (**' '**).

### Клиент ssh

Программа _ssh_ предназначена для регистрации на удаленном хосте с использование протокола _ssh_ и удаленного выполнения команд. Кроме того _ssh_ позволяет выполнять туннелирование любых TCP-соединений внутри _ssh_-канала (port forwarding).

Синтаксис _ssh_:

```html
*ssh опции хост* *пользователь*@*хост* *команда*
```

_ssh_ подключается к удаленному _хост_у, используя для этого текущее имя пользователя или, если указано явно, имя _пользователя_. После этого происходит двусторонняя аутентификация, т.е. удаленный хост доказывает, что он именно тот, за кого себя выдает, а регистрирующийся пользователь в свою очередь доказывает это удаленному хосту.

После этого удаленный хост, выполняет заданную команду, либо если _команда_ отсутствует, запускает командный интерпретатор и предоставляет к нему доступ. После того, как команда выполнена, либо оболочка командного интерпретатора завершила свою работу, соединение завершается.

Программа ssh имеет свой собственный конфигурационный файл, точно такого же формата, как и конфигурационный файл сервера sshd, только в котором используются другие директивы.

**Некоторые опции командной строки программы ssh**

- _v_ -- Выводить отладочную информацию о ходе процесса установки соединения. Настоятельно рекомендуется использовать ключ во время настройки службы.
- _f_ -- Перейти в фоновый режим, сразу же после того, как пройден этап регистрации
- _l_ пользователь ** -- Регистрироваться на удаленной системе как _пользователь_. Вместо ключа имяможно указывать перед именем хоста в форме _пользователь_@_хост_
- _p_ порт ** -- Порт удаленного хоста, на котором доступен сервис SSH. По умолчанию используется порт 22.
- _L_ порт*:_хост_:*хостпорт ** -- Перенаправить _порт_ локального хоста на _хостпорт_ удаленного _хост_а.
- _R_ порт*:_хост_:*хостпорт ** -- Перенаправить _порт_ удаленного локального хоста на _хостпорт_ локального хоста.
- _o_ опции ** -- Явно указать _опции_, которые перекрывают опции, заданные в конфигурационных файлах _ssh_.

### Пример использования клиента _ssh_

Для удаленной регистрации на компьютере remote_srv.com нужно использовать команду:

```
user$ ssh remote_srv.com
```

Следует обратить внимание на то, что для входа на remote_srv.com будет использоваться локальное имя пользователя user.

Если имя пользователя на удаленном хосте не совпадает с локальным именем, его нужно указать явно:

```
user$ ssh -l master remote_srv.com
user$ ssh master@remote_srv.com
```

Зарегистрироваться на удаленном компьютере remote_srv.com под именем пользователя master. Обе команды эквивалентны.

_Примечание: зачастую вместо имени компьютера используется его IP-адрес, команда будет выглядеть следующим образом_

```html
user$ ssh master@192.168.1.1
```

## Утилиты SSH

К серверным утилитам OpenSSH относятся:

- **sshd** (OpenSSH Daemon) — программа демон для ssh. sshd ожидает подключений от клиентов.
- **sftp-server** (серверная подсистема SFTP) — это программа, которая участвует в передачи файлов по протоколу SFTP. sftp-server не предназначен для прямого вызова, обычно она задействуется автоматически демоном sshd.

Итак, на сервере основного внимания требует sshd, а программа sftp-server будет запущена автоматически по мере необходимости.

К клиентским утилитам OpenSSH относятся:

- **ssh** (клиентская программа SSH) — это программа для выполнения входа на удалённую машину и выполнения команд на этой удалённой машине.
- **scp** — программа для копирования файлов на удалённую машину с локальной, или в обратном направлении — с локальной на удалённую. При передаче данных используется зашифрованный канал.
- **sftp** — это тоже программа для передачи файлов по безопасному каналу. Эта программа похожа на **ftp**.
- **ssh-keygen** — утилита для создания ключей аутентификации и управления ими. Также она может использоваться для отзыва ключей.

Это основные программы, которые могут понадобиться большинству пользователей для создания ключей, подключения к удалённой машине и при удалённом копировании файлов.

В Debain и производных (Kali Linux, Linux Mint, Ubuntu), программы OpenSSH можно установить по отдельности, например, имеются пакеты для клиента и для сервера **openssh-client** и **openssh-server**. Либо можно установить метапакет **ssh**, который содержит и клиентскую, и серверную часть.

```html
$ sudo apt install ssh
```

Клиент **ssh** запускается самим пользователем по мере необходимости.

Запуск службы OpenSSH требуется только на сервере. Для запуска службы и добавления её в автозагрузку наберите следующие команды:

```html
$ sudo systemctl start sshd.service
$ sudo systemctl enable sshd.service
```

Проверка статуса службы:

```html
$ systemctl status sshd.service
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/798789ad-4b55-48f1-b123-6e01faf398f1/0cc55272-659a-4d47-a2d8-e9efd3256f1e/Untitled.png)

### Создание и установка асимметричных ключей SSH

Аутентификация с использованием открытых ключей проходит следующим образом. Хост, на котором выполняется удаленная регистрация предлагает пользователю аутентифицировать себя. Для этого он пересылает сообщение, зашифрованное известным ему открытым ключом пользователя. Если пользователь расшифрует сообщение, значит он знает секретный ключ, следовательно, является тем за кого себя выдает.

Секретные ключи хранятся в файлах identity, id_dsa и id_rsa в локальном каталоге ~/.ssh (разные файлы для разных алгоритмов шифрования). Открытые ключи должны быть в файлах authorized_keys и authorized_keys2 в каталоге ~/.ssh на удаленном компьютере, на котором производится регистрация. В качестве домашнего рассматривается каталог пользователя, под именем которого выполняется регистрация. Файл authorized_keys используется для хранения открытых ключей для SSH1, а в authorized_keys2 — для SSH2.

Ssh дает возможность использования одного из трех различных алгоритмов асимметричного шифрования RSA или DSA.

**Типы ключей**

- _rsa1_ -- Тип ключа RSA1, используемый в SSH версии 1
- _rsa_ -- Тип ключа RSA, используемый в SSH версии 2
- _dsa_ -- Тип ключа DSA, используемый в SSH версии 2

Для создания, преобразования и управления ключами аутентификации используется утилита ssh-keygen. Синтаксис:

```html
*ssh-keygen* *опции*
```

Программа генерирует пару открытый ключ - секретный ключ. При этом она спрашивает, в какие файлы нужно записать ключи. По умолчанию секретный ключ записывается в ~/.ssh/identity (или ~/.ssh/id_rsa, ~/.ssh/id_dsa), а открытый в ~/.ssh/identity.pub.

Сгенерированный секретный ключ защищается при помощи парольной фразы (passphrase), которую нужно обязательно знать, для того чтобы воспользоваться ключом. Секретная фраза вводится в момент генерирования ключей. Она может быть затем изменена, без повторного копирования ключей.

Можно сгенерировать секретные ключи, в которых парольная фраза будет отсутствовать. Хотя это и упрощает использование ключей, делать этого не рекомендуется, поскольку в этом случае файл с секретным ключом автоматически влечет за собой полный беспрепятственный доступ ко всем системам, где установлена его открытая пара.

Полученный открытый ключ нужно добавить в файлы authorized_keys удаленных хостов, к которым будет производится доступ.

```html
$ cat ~/.ssh/identity.pub |  ssh user@host 'cat >> ~/.ssh/authorized_keys'
```

Аналогично для второй версии SSH:

```
$ cat ~/.ssh/id_dsa.pub |  ssh user@host 'cat >> ~/.ssh/authorized_keys2'
```

или воспользоваться утилитой ssh-copy-id

```
~/.ssh$ ssh-copy-id -i identity.pub user@host
```

Можно ограничиться только второй версией SSH, однако в том случае, если SSH-сервер на удаленной машине не поддерживает SSH-протокол версии 2, аутентификацию с использованием открытых ключей провести не удастся.

После того, как аутентификация с использование открытых ключей настроена, доступ к удаленному компьютеру можно получить без пароля. Однако для того чтобы воспользоваться локальным секретным ключом нужно ввести парольную фразу.

```
$ ssh user@host
Enter passphrase for key '/home/user/.ssh/id_rsa':
```

## Удаленное копирование файлов

### _scp_

Набор программ SSH позволяют не только выполнять удаленную регистрацию на компьютере для доступа к удаленной строке. Программа scp копирует файлы между хостами, полагаясь при этом на протоколы SSH и используя те же методы аутентификации, что и ssh.

Синтаксис программы _scp_:

```html
*scp* *опции*  *пользователь*@*хост*1:*файл*1... *пользователь*@*хост*2:*файл*2
```

Команда устанавливает защищенное соединение между _хост_ом1 и _хост_ом2 и копирует _файл_1 _хост_а1 в _файл_2 _хост_а2. Любой из _хост_ов может быть локальным. Если имя хоста не указано, подразумевается локальный хост.

Синтаксис использования команды _scp_ напоминает синтаксис cp. Она так же обрабатывает большое количество аргументов, использует аналогичные ключи для рекурсивного копирования, для копирования атрибутов и т.д.

**Опции программы _scp_**

- _r_ -- Выполнить рекурсивное копирование каталогов
- _p_ -- Сохранить по возможности атрибуты файлов (права доступа, время модификации, время доступа) при копировании
- _C_ -- Выполнять сжатие файлов при передаче
- _P_ порт ** -- Соединяться с удаленным компьютером по порту _порт_
- _v_ -- Сообщать отладочную информацию о ходе SSH-соединения
- _q_ -- Не выдавать индикатор прогресса

Например с удаленного хоста source на локальный хост dest нужно скопировать домашний каталог пользователя batman. Команда выполняющая копирование будет выглядеть так:

```
dest$ scp -rp source:/home/batman /home
.login               100% |*****************************|   255       00:00
.login_conf          100% |*****************************|   160       00:00
.mailrc              100% |*****************************|   331       00:00
.profile             100% |*****************************|   789       00:00
.shrc                100% |*****************************|   852       00:00
.mail_aliases        100% |*****************************|   371       00:00
.cshrc               100% |*****************************|   771       00:00

```

Строки, которые программа выводит на экран говорят о названии файла, его размере и времени копирования. Кроме этого строка содержит индикатор прогресса, которой показывает какая часть файла успешно скопирована.

**События SSH** можно разделить на события:

- запуска и остановки этой службы
- события, связанные с подключением пользователей

Просмотреть логи SSH можно различными способами, один из вариантов (помните, что в некоторых системах служба называется **ssh.service**, без буквы **d**):

`journalctl -u sshd.service`

Например, для вывода последних 100 записей:

`journalctl -u sshd.service | tail` `-n 100`

Также можно просмотреть события SSH с помощью:

`journalctl -u "sshd@*"`

или:

`journalctl /usr/bin/sshd`

Универсальная команда в независимости от имени службы:

`journalctl -u "ssh*"`

Для вывода событий, связанных с подключением пользователей, другой информации, в том числе отладочной (зависит от настройки уровня подробности сообщений), можно посмотреть следующим образом:

`journalctl | grep` `-i ssh`

Если настроен вход по паролю, то для **вывода неудачных попыток** наберите команду:

`journalctl | grep` `-i 'Failed password for'`

Если настроен вход по публичному ключу, но не отключена возможность входа по паролю, то после неверного ключа, будет предоставлена возможности войти по паролю. Такие неудачные попытки входа по паролю можно найти такой же командой:

`journalctl | grep` `-i 'Failed password for'`