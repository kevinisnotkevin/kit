# Безопасность баз данных

## 1 Репликация

**Репликация** - одна из техник масштабирования баз данных. Состоит эта техника в том, что данные с одного сервера базы данных постоянно копируются (реплицируются) на один или несколько других (называемые репликами). Для приложения появляется возможность использовать не один сервер для обработки всех запросов, а несколько. Таким образом появляется возможность распределить нагрузку с одного сервера на несколько.

Одной из основных причин использования репликации является улучшение производительности системы. Распределение нагрузки между репликами позволяет увеличить пропускную способность и снизить задержки при выполнении запросов. Например, репликация может использоваться для отделения операций чтения и записи данных, что увеличивает производительность.

Репликация также позволяет обеспечить отказоустойчивость системы. При сбое одного из серверов или узлов базы данных, другие реплики могут продолжать работу и обеспечивать доступ к данным. Это позволяет избежать простоев в работе системы и потери данных.

Репликация базы данных играет решающую роль в современном управлении данными. Это фундаментальный метод, используемый организациями для обеспечения целостности, надежности и доступности данных. Это упрощает доступ к данным для нескольких групп и, создавая копии, защищает данные от подделки и уничтожения.

Репликация базы данных - это непрерывный процесс. Непрерывная репликация гарантирует, что изменения в основной базе данных оперативно распространяются на реплики, гарантируя глобальную актуальность данных. Это позволяет организациям добавлять новые реплики и адаптировать развивающиеся схемы. Непрерывная репликация также облегчает автоматическое переключение при сбое и восстановление, обеспечивая плавный переход при сбоях основной базы данных.

Благодаря репликации возможно:

1. **Непрерывная доступность данных:** Если основная база данных отказывает, вы можете переключиться на реплику, минимизируя простой в обслуживании и потерю данных.
2. **Балансировка нагрузки:** Вы можете отправлять запросы только на чтение к репликам, чтобы уменьшить нагрузку на основную базу данных.
3. **Бэкапы**: Реплики могут служить как места для бэкапа.
4. **Отказоустойчивость:** Репликация может помочь восстановить данные в случае повреждения или потери данных.

### 1.1 В чем разница между репликацией данных и репликацией баз данных?

Прежде чем углубляться в репликацию базы данных, важно понять разницу между репликацией данных и репликацией базы данных.

Репликация данных означает копирование определенных данных с одного устройства хранения на другое, часто в целях резервного копирования. Этот процесс гарантирует, что в случае аппаратного сбоя или потери данных реплицированные данные можно будет использовать для восстановления исходных данных.

С другой стороны, репликация базы данных предполагает репликацию _всей_ базы данных, включая ее схему, таблицы и хранимые процедуры, на несколько серверов. В отличие от репликации данных, которая фокусируется исключительно на копировании данных, репликация базы данных направлена на создание идентичных копий всей структуры базы данных и ее содержимого.

Естественно, репликация базы данных требует большей сложности и замысловатости по сравнению с простой репликацией данных. Это требует тщательного рассмотрения таких факторов, как согласованность данных, синхронизация и разрешение конфликтов.

### 1.2 Процесс репликации

Репликация базы данных использует набор методов для копирования и синхронизации данных между несколькими базами данных или серверами. Система отслеживания измененных данных (CDC) - один из таких методов. Он фиксирует изменения в исходной базе данных и обновляет реплику в режиме реального времени.

В общем, репликация включает в себя первичную базу данных, которая служит источником достоверных данных, и одну или несколько реплик, которые поддерживают копии первичной базы данных. Когда в основной базе данных происходит изменение, оно фиксируется механизмом репликации и распространяется на реплики. Это гарантирует, что данные в репликах соответствуют основной базе данных.

### 1.3 Типы репликации базы данных

Технология репликации баз данных достаточно гибкая и может быть настроена под конкретную задачу. Основное разделение идет по трем принципам:

- **Способ синхронизации данных.**
- **Способ передачи данных.**
- **Тип серверной архитектуры.**

Первый подразумевает под собой алгоритм или правило, по которому данные синхронизируются между оригиналом и репликами. В SQL-сервере основными типами являются:

- **Транзакционная** - любые изменения в оригинале фиксируются и доставляются в реплики. Обновление информации происходит практически моментально.
- **Репликация моментальных снимков** - данные обновляются периодически. В определенные моменты времени делается снимок базы данных, который накладывается на реплики. Это один из самых простых способов. Его большим преимуществом является периодичность, то есть он не несет постоянной нагрузки на систему.
- **Слияние** - является промежуточным вариантом между транзакционным способом и репликацией моментальных снимков. Метод отслеживает изменения, фиксирует и периодически передает их. Если за отслеживаемый период было внесено всего два изменения, то именно они будут переданы. Это намного быстрее и проще, чем обновлять всю таблицу.
- **Одноранговая** - изменения согласуются на уровне транзакций и передаются между несколькими копиями СУБД. Все процессы происходят практически в режиме реального времени. Возможно небольшое запаздывание.
- **Двунаправленная** - технология позволяет двум серверам обмениваться данными между собой.

По способу передачи данных выделяют:

- **Асинхронную репликацию** - после записи в оригинал информация дублируется в реплику. Такой механизм подразумевает, что копия всегда отстает от главной СУБД. Главное преимущество заключается в простоте развертывания и инертности к увеличению расстояния канала передачи данных.
- **Синхронную репликацию** - данные дублируются в реальном времени. Это позволяет иметь несколько актуальных копий, поэтому полная потеря данных практически невозможна. Способ требует высоких вычислительных мощностей, так как несет постоянную нагрузку на основное приложение.
- **Полусинхронная репликация** - компромисс между вышеописанными способами. Все изменения фиксируются локально. При этом изменения поступают на реплики, но не обновляют значения моментально.
- **Физическая репликация** - мастер передает на реплику журнальные записи. Реплика применяет их к своим файлам данных. Все процессы носят чисто «механический» характер. Поэтому это возможно только для одинаковых платформ, в которых есть двоичная совместимость.
- **Логическая журнальная репликация** - является более «умным» методом, чем физическое копирование. Кроме журнальных записей на реплику поступает информация высокого уровня. Она позволяет декодировать журнальную информацию для внесения изменений в целевые таблицы.

По типу серверной архитектуры бывают:

- **Однолидерные** - реплики считывают данные с одного сервера. Стандартная структура.
- **Многолидерные** - реплики считывают данные с нескольких серверов. Актуальна для рассредоточенной структуры.
- **Без лидеров** - любой сервер служит моделью для реплик. Максимально гибкая структура. Но могут возникнуть проблемы с синхронизацией данных.

### 1.4 Репликация в PostgreSQL

PostgreSQL предлагает два основных типа репликации:

1. **Физическая репликация:** Настроенная на уровне блока диска, и она копирует и сохраняет состояние каждого байта данных с основного сервера на реплику. Это наиболее простая форма репликации и обеспечивает полную копию данных с мастера на реплику.
2. **Логическая репликация:** Она передает изменения данных на уровне отдельных изменений состояния. Это позволяет, например, реплицировать только определенные таблицы или даже отдельные строки и столбцы, что дает большую гибкость, но влечет за собой дополнительную сложность.

Оба типа репликации имеют свои преимущества и недостатки, и выбор между ними зависит от ваших конкретных требований.

## 2 SQL-инъекции

Все чаще клиентам предоставляется доступ к базам данных компании в целях управления счетами, получения поддержки клиентов или размещения и отслеживания заказов. Хотя это обеспечивает большое удобство для конечного пользователя, это также открывает базу данных для определенных уязвимостей. Любая функция, которая позволяет пользователю искать или редактировать контент в базе данных, рискует использовать эту функцию злоумышленником для получения дополнительного доступа к информации компании. Когда пользователь нарушает первоначальную цель ваших операторов SQL, это называется атакой с помощью SQL-инъекции.

### 2.1 Что такое атаки с использованием SQL-инъекций?

Атаки с помощью SQL-инъекций - это злонамеренные атаки, при которых данные «внедряются» в ваш SQL-запрос с использованием определенных деструктивных фраз или неэкранированных параметров. Хакеры используют эту технику, чтобы получить доступ к бизнес-данным и личной информации, а также изменить или удалить содержимое вашей базы данных. Одним из последних примеров атаки SQL-injection является атака «Meow», в результате которой в июле 2020 года было уничтожено почти 4000 незащищенных баз данных.

Обычно атаки происходят через веб-интерфейс, например веб-страницу или приложение, которое позволяет пользователям выполнять поиск в базе данных или входить в учетную запись. Зачастую это делается с помощью автоматизированных сценариев. Если входные данные вашего веб-приложения не проверяются и не экранируются должным образом, злоумышленники могут использовать эти функции для изменения вашей базы данных с помощью деструктивных фраз, таких как `DROP TABLE`, `DELETE FROM`, `INSERT`, `UPDATE`, последовательность двух тире `--` или точку с запятой `;`, также они могут выгрузить всю базу данных с помощью операторов `SELECT`.

Излишне говорить, что последствия подобных атак могут оказаться разрушительными не только для содержимого вашей базы данных, но также для целостности и репутации вашей компании.

### 1.2.2 Типы атак с использованием SQL-инъекций

Атаки с помощью SQL-инъекций делятся на три основные категории: In-band (также известные как «классические» или «простые» атаки), inferential атаки (или «слепые») и out-of-band атаки.

1. _**In-band атаки**_

При простой или In-band атаке в базу данных отправляются команды для извлечения контента и возврата результатов непосредственно конечному пользователю. Даже сообщения об ошибках из-за неверных входных данных могут использоваться для определения базовой структуры базы данных, которую затем можно использовать для извлечения данных из других таблиц в базе данных путем реструктуризации исходного запроса. Например, если веб-сайт позволяет клиентам отслеживать свои заказы онлайн, вызывая базу данных с помощью оператора SQL, такого как следующий:

```sql
SELECT * FROM orders WHERE order_id='USER_INPUT'
```

Где вместо значения `USER_INPUT`, подразумевается передача пользовательского значения. Можно использовать этот оператор для извлечения дополнительной информации из базы данных, добавляя простой оператор `UNION SELECT` к номеру заказа. Например:

```sql
SELECT * FROM orders WHERE order_id= ‘123 UNION SELECT username, password from customers --’
```

вернет информацию о заказе номер 123, а также имена пользователей и пароли всех клиентов в базе данных.

2. _**Inferential (Слепые) атаки**_

При этом типе атак злоумышленник отправляет команды в базу данных, но не получает обратно никакого содержимого базы данных. Вместо этого этот метод используется для того, чтобы узнать как можно больше о поведении системы. Существует два основных типа Inferential атак: логические и временные. Атаки на основе логических значений используют истинные или ложные утверждения для извлечения информации в зависимости от того, перезагружается ли веб-браузер с пустым или непустым ответом. Атаки на основе времени могут использовать такие функции, как pg_sleep, или использоваться в сочетании с атаками на основе логических значений для сбора информации из базы данных на основе времени, которое требуется веб-браузеру для перезагрузки.

3. _**Out-of-band атаки**_

**Out-of-band** атаки предназначены для случаев, когда данные не могут быть извлечены через тот же канал, по которому собирается информация о системе, например, при работе с медленными, нестабильными системами или системами с большими нагрузками. Хакеры используют эту технику для отправки данных на внешний сервер, которым управляет хакер, с помощью DNS-запросов или пакетов UTL_HTTP.

### 2.3 Предотвращение атак типа SQL-инъекция

Теперь, когда мы знаем, что такое атаки с использованием SQL-инъекций, возникает вопрос: как их предотвратить? К счастью, есть несколько простых шагов, которые вы можете предпринять, чтобы защитить себя и свою систему от атак.

1. _**Проверка входных данных**_

Прежде всего, входные данные операторов SQL должны быть проверены или «очищены» перед отправкой в базу данных. Это можно сделать с помощью параметризованных операторов SQL, которые отделяют операторы запроса от данных. Параметризованные операторы используют сохраненные запросы с маркерами, называемыми параметрами, для представления входных данных. Вместо того, чтобы анализировать запрос и данные как одну строку, база данных считывает только сохраненный запрос как язык запросов, позволяя отправлять вводимые пользователем данные в виде списка параметров, которые база данных может обрабатывать исключительно как данные.

В качестве дополнительной меры предосторожности можно настроить параметризованные операторы, запрещающие вызывающей стороне выполнять определенные команды, такие как `DROP TABLE`. Вы также можете пропустить все входные данные через фильтр, чтобы отсеять определенные деструктивные фразы, такие как `DROP TABLE`, `DELETE FROM`, `SELECT * FROM`, последовательность двух тире «`--`» или точку с запятой `;`.

2. _**Аудит базы данных**_

Регулярный аудит способствует поддержанию рабочего состояния среды PostgreSQL. Расширения, такие как pg_audit, обеспечивают более тщательное журналирование сеансов и объектов, чем стандартное журналирование в PostgreSQL. Такой уровень детализации может помочь выявить любые нетипичные запросы, например, запросы к системным таблицам. Системные таблицы, такие как те, которые находятся в information_schema, редко используются пользователями, и к ним следует относиться с осторожностью. Аудит также предоставляет информацию о том, какие таблицы, представления, процедуры и функции больше не используются. Удаление этих элементов снижает вероятность внедрения вредоносного кода злоумышленником, который может остаться незамеченным на протяжении долгого времени.

3. _**Изменение настроек по умолчанию**_

Рассмотрите возможность изменения настроек PostgreSQL по умолчанию, чтобы максимизировать информацию, записываемую в файлы журналов. Лучше всего начать с параметров `log_statement` и `log_min_error_statement` в файле `postgresql.conf`.

```
log_statement = all
log_min_error_statement = ERROR
```

Поскольку эти настройки увеличат размер файлов журналов, вам необходимо будет соответствующим образом настроить параметры хранилища и процедуры резервного копирования журналов. Если для параметра `log_statement` установить значение «`all`», файлы журналов будут фиксировать все операторы `SQL`, выполняемые в базе данных. Единственным исключением могут быть операторы, содержащие простые синтаксические ошибки, поскольку эти операторы завершаются неудачей до фазы выполнения. Эти операторы можно фиксировать, установив для параметра `log_min_error_statement` значение «`ERROR`».

4. _**Защита вашей системы**_

Хотя мониторинг вашей системы и проверка входных данных являются лучшими способами защиты от атак, есть несколько дополнительных шагов, которые вы можете предпринять для защиты вашей системы.

- Отключите видимость ошибок базы данных для внешних пользователей на рабочих системах, чтобы избежать раскрытия информации о структуре и поведении системы.
- Убедитесь, что все приложения, подключающиеся к базе данных, не используют учетные записи с правами администратора, особенно веб-приложения.
- Поддерживайте операционную систему и PostgreSQL в актуальном состоянии с помощью последних обновлений безопасности.
- Используйте сканеры уязвимостей и брандмауэры веб-приложений (`WAF`), чтобы убедиться в безопасности приложений перед их выпуском на рабочие серверы.

### 2.4 Обнаружение атак

Хотя описанные выше шаги помогут защитить вашу систему от атак, нет ничего неуязвимого. Злоумышленники неустанно совершенствуют свои методы, и все системы уязвимы для атак.

Если вы подозреваете, что ваша база данных была скомпрометирована, первое, что вам следует сделать, это выключить систему. Затем просмотрите и проанализируйте свои журналы, чтобы найти любые потенциальные дыры, которые могли быть использованы. Вот некоторые ключевые вещи, на которые следует обратить внимание:

- _**SQL-ошибки**_. Атаки почти всегда генерируют ошибки SQL, так что это хорошее место для начала. Это также лучший способ обнаружить атаку в момент ее совершения.
- _**Ошибки прав доступа**_. Всякий раз, когда неавторизованный пользователь пытается получить доступ к базе данных или изменить ее, это может указывать на атаку.
- _**Ссылки на системные таблицы**_. Злоумышленники не всегда знают конкретные имена ваших таблиц, поэтому запросы к системным таблицам должны вызывать тревогу.

## 3 Многопользовательский доступ и разграничение прав

Рассмотрим известные существующие способы разграничения прав доступа с их плюсами и минусами, среди которых можно выделить использование встроенных механизмов аутентификации СУБД и контроль доступа на уровне приложения.

### 3.1 Встроенные механизмы аутентификации

При регистрации каждого сотрудника в системе создается соответствующая запись в базе данных, где ему назначаются нужные привилегии.

Преимущества такого подхода: его простота и прозрачность. Из логов базы данных легко увидеть, какие операции выполняют сотрудники, можно объединять различные привилегии в роли и назначать их сотрудникам "из коробки". Основной недостаток данного способа заключается в отсутствии контроля доступа на уровне отдельных строк. В версии 9.5 была добавлена функция row-level security, но данный механизм работает не так быстро, как желалось, особенно при использовании JOIN.

### 3.2 Проверка на уровне приложения

Разграничение доступа прямо на уровне приложения – важный аспект безопасности. Выбор между внешним сервисом для аутентификации пользователей и хранением хешей паролей в базе данных непосредственно несомненно имеет значение. Важно, что все пользователи в конечном итоге обращаются к базе данных под одной учетной записью. Однако такой подход имеет недостатки, а именно:

1. Отсутствие контроля доступа на уровне строк или его усложнение.
2. В случае утечки пароля пользователя злоумышленник получает полный доступ к данным и может их как просматривать, так и изменять.
3. Приложение становится единственным звеном, регулирующим доступ, что делает необходимым переписывание всего кода при добавлении нового сервиса, работающего с базой данных.

### 3.3. Введение сессии на уровне СУБД

В базе данных создаётся процедура авторизации, которая проверяет логин и пароль пользователя и в случае успеха устанавливает значение некоторой сессионной переменной, которая была бы доступна на чтение до конца текущей сессии.

Минусы:

1. Всю логику работы с данными необходимо оборачивать в хранимые процедуры.
2. Необходимость авторизации пользователя в начале каждой сессии, а если код обёрнут в транзакции, то в начале каждой транзакции. Это может быть некритично для так называемых "толстых клиентов", но для веб приложений уже становится актуальным. В этом случае проблема решается оборачиванием драйвера, который предоставляет доступ к СУБД кастомным кодом таким образом, чтобы авторизация выполнялась перед выполнением каждого запроса.

## 4 Транзакции и точки сохранения

### 4.1 Транзакции

Транзакция в PostgreSQL представляет собой логически связанный блок операций базы данных, который либо выполняется полностью (фиксируется), либо отменяется (откатывается) целиком. Основные характеристики транзакций определяются аббревиатурой ACID:

- **_Атомарность_ (Atomicity)**: Транзакция считается атомарной, если все ее операции либо выполняются успешно и фиксируются, либо ни одна операция не выполняется и транзакция отменяется (откатывается).
- **_Согласованность_ (Consistency)**: Транзакция должна переводить базу данных из одного согласованного состояния в другое согласованное состояние. Если данные нарушают интегритет, транзакция должна быть отменена.
- **_Изолированность_ (Isolation)**: Транзакции выполняются изолированно друг от друга. Изменения, внесенные в рамках одной транзакции, не видны другим транзакциям до их фиксации.
- **_Долговечность_ (Durability)**: Фиксированные изменения должны быть надежно сохранены и не должны быть потеряны из-за сбоев системы.

### 4.2 Точки сохранения (Savepoints)

Точки сохранения представляют собой механизм в PostgreSQL, который позволяет разбить транзакцию на более мелкие части и явно указать места, до которых можно откатиться в случае отмены транзакции. Они предоставляют гибкость и контроль над транзакциями, позволяя разработчикам управлять изменениями в базе данных. Основные причины использования точек сохранения:

1. _**Контроль за состоянием транзакции**_: С точками сохранения можно сохранять промежуточные состояния транзакции, позволяя откатиться к ним при необходимости.
2. _**Частичный откат изменений**_: Возможность откатиться только до определенной точки сохранения, минуя предшествующие операции.
3. _**Уменьшение нагрузки на сервер**_: Позволяют откатывать только часть транзакции, что может быть полезно при выполнении долгих операций.